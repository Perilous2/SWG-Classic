/*
 *	autogen/server/zone/objects/tangible/TangibleObject.cpp generated by engine3 IDL compiler 0.70
 */

#include "TangibleObject.h"

#include "server/zone/objects/creature/CreatureObject.h"

#include "server/zone/objects/tangible/tool/repair/RepairTool.h"

#include "server/zone/objects/area/ActiveArea.h"

#include "server/zone/objects/factorycrate/FactoryCrate.h"

#include "server/zone/objects/tangible/threat/ThreatMap.h"

/*
 *	TangibleObjectStub
 */

enum {RPC_INITIALIZEMEMBERS__ = 3335659148,RPC_ADDTEMPLATESKILLMODS__TANGIBLEOBJECT_,RPC_APPLYSKILLMODSTO__CREATUREOBJECT_,RPC_REMOVESKILLMODSFROM__CREATUREOBJECT_,RPC_ADDSKILLMOD__INT_STRING_INT_BOOL_,RPC_REMOVESKILLMOD__INT_STRING_INT_BOOL_,RPC_REMOVEALLSKILLMODSOFTYPE__INT_BOOL_,RPC_INITIALIZETRANSIENTMEMBERS__,RPC_NOTIFYLOADFROMDATABASE__,RPC_SETCUSTOMOBJECTNAME__UNICODESTRING_BOOL_,RPC_SENDBASELINESTO__SCENEOBJECT_,RPC_SENDTO__SCENEOBJECT_BOOL_BOOL_,RPC_SYNCHRONIZEDUILISTEN__CREATUREOBJECT_INT_,RPC_SYNCHRONIZEDUISTOPLISTEN__CREATUREOBJECT_INT_,RPC_SETDEFENDER__SCENEOBJECT_,RPC_ADDDEFENDER__SCENEOBJECT_,RPC_REMOVEDEFENDER__SCENEOBJECT_,RPC_REMOVEDEFENDERS__,RPC_SETCOMBATSTATE__,RPC_SETUSECOUNT__INT_BOOL_,RPC_DECREASEUSECOUNT__INT_BOOL_,RPC_SETCOUNTDOWNTIMER__INT_BOOL_,RPC_CLEARCOMBATSTATE__BOOL_,RPC_ISATTACKABLEBY__CREATUREOBJECT_,RPC_ISATTACKABLEBY__TANGIBLEOBJECT_,RPC_ISAGGRESSIVETO__CREATUREOBJECT_,RPC_ISHEALABLEBY__CREATUREOBJECT_,RPC_SENDPVPSTATUSTO__CREATUREOBJECT_,RPC_INFLICTDAMAGE__TANGIBLEOBJECT_INT_FLOAT_BOOL_BOOL_BOOL_,RPC_INFLICTDAMAGE__TANGIBLEOBJECT_INT_FLOAT_BOOL_STRING_BOOL_BOOL_,RPC_HEALDAMAGE__TANGIBLEOBJECT_INT_FLOAT_BOOL_,RPC_SETCONDITIONDAMAGE__FLOAT_BOOL_,RPC_ADDVISIBLECOMPONENT__INT_BOOL_,RPC_REMOVEVISIBLECOMPONENT__INT_BOOL_,RPC_REMOVEALLVISIBLECOMPONENTS__BOOL_,RPC_HASVISIBLECOMPONENT__INT_,RPC_SETCUSTOMIZATIONVARIABLE__BYTE_SHORT_BOOL_,RPC_SETCUSTOMIZATIONVARIABLE__STRING_SHORT_BOOL_,RPC_SETOPTIONSBITMASK__INT_BOOL_,RPC_SETOPTIONBIT__INT_BOOL_,RPC_CLEAROPTIONBIT__INT_BOOL_,RPC_NOTIFYOBJECTDESTRUCTIONOBSERVERS__TANGIBLEOBJECT_INT_BOOL_,RPC_DROPFROMDEFENDERLISTS__,RPC_GETOBJECTVISIBLE__,RPC_ISKILLER__,RPC_ISTICKETCOLLECTOR__,RPC_ISTICKETOBJECT__,RPC_ISFSPUZZLEPACK__,RPC_ISPLANTOBJECT__,RPC_ISCONSUMABLE__,RPC_GETUSECOUNT__,RPC_GETMAXCONDITION__,RPC_SETMAXCONDITION__INT_BOOL_,RPC_GETCONDITIONDAMAGE__,RPC_GETUNMITIGATEDDAMAGE__,RPC_ADDUNMITIGATEDDAMAGE__FLOAT_,RPC_GETVOLUME__,RPC_SETCOMPLEXITY__FLOAT_,RPC_GETCOMPLEXITY__,RPC_GETOPTIONSBITMASK__,RPC_ADDMAGICBIT__BOOL_,RPC_REMOVEMAGICBIT__BOOL_,RPC_GETLEVEL__,RPC_GETISCRAFTEDENHANCEDITEM__,RPC_GETPVPSTATUSBITMASK__,RPC_ISTANGIBLEOBJECT__,RPC_GETCUSTOMIZATIONSTRING__STRING_,RPC_GETMAINDEFENDER__,RPC_ISDESTROYED__,RPC_SETFACTION__INT_,RPC_GETFACTION__,RPC_ISREBEL__,RPC_ISIMPERIAL__,RPC_ISNEUTRAL__,RPC_GETFACTIONSTATUS__,RPC_SETFACTIONSTATUS__INT_,RPC_GETFUTUREFACTIONSTATUS__,RPC_SETFUTUREFACTIONSTATUS__INT_,RPC_ISSLICEABLE__,RPC_ISSLICED__,RPC_SETSLICEABLE__BOOL_,RPC_SETSLICED__BOOL_,RPC_ISJEDIROBE__,RPC_ISUNIONRING__,RPC_SETUNIONRING__BOOL_,RPC_SETCUSTOMIZATIONSTRING__STRING_,RPC_SETISCRAFTEDENHANCEDITEM__BOOL_,RPC_SETPVPSTATUSBITMASK__INT_BOOL_,RPC_SETPVPSTATUSBIT__INT_BOOL_,RPC_CLEARPVPSTATUSBIT__INT_BOOL_,RPC_SETCRAFTERSNAME__STRING_,RPC_SETCRAFTERSID__LONG_,RPC_GETCRAFTERSNAME__,RPC_GETCRAFTERSID__,RPC_SETJUNKDEALERNEEDED__INT_,RPC_GETJUNKDEALERNEEDED__,RPC_SETJUNKVALUE__INT_,RPC_GETJUNKVALUE__,RPC_SETSERIALNUMBER__STRING_,RPC_SETLEVEL__INT_BOOL_,RPC_GETSERIALNUMBER__,RPC_CREATEFACTORYCRATE__INT_STRING_BOOL_,RPC_CANREPAIR__CREATUREOBJECT_,RPC_REPAIR__CREATUREOBJECT_REPAIRTOOL_,RPC_REPAIRATTEMPT__INT_,RPC_ISBROKEN__,RPC_GETHITCHANCE__,RPC_BROADCASTPVPSTATUSBITMASK__,RPC_ADDACTIVEAREA__ACTIVEAREA_,RPC_DROPACTIVEAREA__ACTIVEAREA_,RPC_HASACTIVEAREA__ACTIVEAREA_,RPC_HASACTIVEAREA__LONG_,RPC_ISINNOCOMBATAREA__,RPC_SETINNOCOMBATAREA__BOOL_,RPC_GETACTIVEAREASSIZE__,RPC_GETACTIVEREGION__,RPC_ISNOTRADE__,RPC_HASANTIDECAYKIT__,RPC_GETANTIDECAYKITOBJECTID__,RPC_APPLYANTIDECAYKIT__CREATUREOBJECT_SCENEOBJECT_,RPC_REMOVEANTIDECAYKIT__,RPC_DESTROYOBJECTFROMDATABASE__BOOL_,RPC_ISCITYSTREETLAMP__,RPC_ISCITYSTATUE__,RPC_ISCITYFOUNTAIN__,RPC_ISINVISIBLE__,RPC_SETINVISIBLE__BOOL_,RPC_ISCUSTOMINGREDIENT__,RPC_SETLUASTRINGDATA__STRING_STRING_,RPC_DELETELUASTRINGDATA__STRING_,RPC_GETLUASTRINGDATA__STRING_,RPC_SETDISABLED__BOOL_,RPC_ISDISABLED__,RPC_ISINNAVMESH__};

TangibleObject::TangibleObject() : SceneObject(DummyConstructorParameter::instance()) {
	TangibleObjectImplementation* _implementation = new TangibleObjectImplementation();
	_impl = _implementation;
	_impl->_setStub(this);
	_setClassName("TangibleObject");
}

TangibleObject::TangibleObject(DummyConstructorParameter* param) : SceneObject(param) {
	_setClassName("TangibleObject");
}

TangibleObject::~TangibleObject() {
}



void TangibleObject::initializeMembers() {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INITIALIZEMEMBERS__);

		method.executeWithVoidReturn();
	} else {
		_implementation->initializeMembers();
	}
}

void TangibleObject::addTemplateSkillMods(TangibleObject* targetObject) const {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDTEMPLATESKILLMODS__TANGIBLEOBJECT_);
		method.addObjectParameter(targetObject);

		method.executeWithVoidReturn();
	} else {
		_implementation->addTemplateSkillMods(targetObject);
	}
}

void TangibleObject::applySkillModsTo(CreatureObject* creature) const {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_APPLYSKILLMODSTO__CREATUREOBJECT_);
		method.addObjectParameter(creature);

		method.executeWithVoidReturn();
	} else {
		_implementation->applySkillModsTo(creature);
	}
}

void TangibleObject::removeSkillModsFrom(CreatureObject* creature) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVESKILLMODSFROM__CREATUREOBJECT_);
		method.addObjectParameter(creature);

		method.executeWithVoidReturn();
	} else {
		_implementation->removeSkillModsFrom(creature);
	}
}

void TangibleObject::addSkillMod(const int skillType, const String& skillMod, int value, bool notifyClient) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDSKILLMOD__INT_STRING_INT_BOOL_);
		method.addSignedIntParameter(skillType);
		method.addAsciiParameter(skillMod);
		method.addSignedIntParameter(value);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->addSkillMod(skillType, skillMod, value, notifyClient);
	}
}

void TangibleObject::removeSkillMod(const int skillType, const String& skillMod, int value, bool notifyClient) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVESKILLMOD__INT_STRING_INT_BOOL_);
		method.addSignedIntParameter(skillType);
		method.addAsciiParameter(skillMod);
		method.addSignedIntParameter(value);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->removeSkillMod(skillType, skillMod, value, notifyClient);
	}
}

void TangibleObject::removeAllSkillModsOfType(const int skillType, bool notifyClient) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEALLSKILLMODSOFTYPE__INT_BOOL_);
		method.addSignedIntParameter(skillType);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->removeAllSkillModsOfType(skillType, notifyClient);
	}
}

void TangibleObject::removeTemplateSkillMods(TangibleObject* tangibleObject) const {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->removeTemplateSkillMods(tangibleObject);
	}
}

const VectorMap<String, int>* TangibleObject::getTemplateSkillMods() const {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getTemplateSkillMods();
	}
}

void TangibleObject::loadTemplateData(SharedObjectTemplate* templateData) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->loadTemplateData(templateData);
	}
}

void TangibleObject::initializeTransientMembers() {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INITIALIZETRANSIENTMEMBERS__);

		method.executeWithVoidReturn();
	} else {
		_implementation->initializeTransientMembers();
	}
}

void TangibleObject::notifyLoadFromDatabase() {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYLOADFROMDATABASE__);

		method.executeWithVoidReturn();
	} else {
		_implementation->notifyLoadFromDatabase();
	}
}

void TangibleObject::setObjectName(const StringId& stringID, bool notifyClient) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->setObjectName(stringID, notifyClient);
	}
}

void TangibleObject::setCustomObjectName(const UnicodeString& name, bool notifyClient) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCUSTOMOBJECTNAME__UNICODESTRING_BOOL_);
		method.addUnicodeParameter(name);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->setCustomObjectName(name, notifyClient);
	}
}

void TangibleObject::sendBaselinesTo(SceneObject* player) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDBASELINESTO__SCENEOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendBaselinesTo(player);
	}
}

void TangibleObject::sendTo(SceneObject* player, bool doClose, bool forceLoadContainer) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDTO__SCENEOBJECT_BOOL_BOOL_);
		method.addObjectParameter(player);
		method.addBooleanParameter(doClose);
		method.addBooleanParameter(forceLoadContainer);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendTo(player, doClose, forceLoadContainer);
	}
}

void TangibleObject::synchronizedUIListen(CreatureObject* player, int value) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SYNCHRONIZEDUILISTEN__CREATUREOBJECT_INT_);
		method.addObjectParameter(player);
		method.addSignedIntParameter(value);

		method.executeWithVoidReturn();
	} else {
		_implementation->synchronizedUIListen(player, value);
	}
}

void TangibleObject::synchronizedUIStopListen(CreatureObject* player, int value) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SYNCHRONIZEDUISTOPLISTEN__CREATUREOBJECT_INT_);
		method.addObjectParameter(player);
		method.addSignedIntParameter(value);

		method.executeWithVoidReturn();
	} else {
		_implementation->synchronizedUIStopListen(player, value);
	}
}

void TangibleObject::setDefender(SceneObject* defender) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETDEFENDER__SCENEOBJECT_);
		method.addObjectParameter(defender);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setDefender(defender);
	}
}

void TangibleObject::addDefender(SceneObject* defender) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDDEFENDER__SCENEOBJECT_);
		method.addObjectParameter(defender);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->addDefender(defender);
	}
}

void TangibleObject::removeDefender(SceneObject* defender) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEDEFENDER__SCENEOBJECT_);
		method.addObjectParameter(defender);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->removeDefender(defender);
	}
}

void TangibleObject::removeDefenders() {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEDEFENDERS__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->removeDefenders();
	}
}

void TangibleObject::setCombatState() {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCOMBATSTATE__);

		method.executeWithVoidReturn();
	} else {
		_implementation->setCombatState();
	}
}

void TangibleObject::setUseCount(unsigned int newUseCount, bool notifyClient) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETUSECOUNT__INT_BOOL_);
		method.addUnsignedIntParameter(newUseCount);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setUseCount(newUseCount, notifyClient);
	}
}

void TangibleObject::decreaseUseCount(unsigned int decrementAmount, bool notifyClient) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DECREASEUSECOUNT__INT_BOOL_);
		method.addUnsignedIntParameter(decrementAmount);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->decreaseUseCount(decrementAmount, notifyClient);
	}
}

void TangibleObject::setCountdownTimer(unsigned int newCount, bool notifyClient) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCOUNTDOWNTIMER__INT_BOOL_);
		method.addUnsignedIntParameter(newCount);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setCountdownTimer(newCount, notifyClient);
	}
}

void TangibleObject::fillAttributeList(AttributeListMessage* msg, CreatureObject* object) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->fillAttributeList(msg, object);
	}
}

void TangibleObject::clearCombatState(bool clearDefenders) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARCOMBATSTATE__BOOL_);
		method.addBooleanParameter(clearDefenders);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->clearCombatState(clearDefenders);
	}
}

bool TangibleObject::hasDefender(const SceneObject* defender) const {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		assert(this->isLockedByCurrentThread());
		return _implementation->hasDefender(defender);
	}
}

bool TangibleObject::isAttackableBy(CreatureObject* object) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISATTACKABLEBY__CREATUREOBJECT_);
		method.addObjectParameter(object);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isAttackableBy(object);
	}
}

bool TangibleObject::isAttackableBy(TangibleObject* object) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISATTACKABLEBY__TANGIBLEOBJECT_);
		method.addObjectParameter(object);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isAttackableBy(object);
	}
}

bool TangibleObject::isAggressiveTo(CreatureObject* object) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISAGGRESSIVETO__CREATUREOBJECT_);
		method.addObjectParameter(object);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isAggressiveTo(object);
	}
}

bool TangibleObject::isHealableBy(CreatureObject* object) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISHEALABLEBY__CREATUREOBJECT_);
		method.addObjectParameter(object);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isHealableBy(object);
	}
}

void TangibleObject::sendPvpStatusTo(CreatureObject* player) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDPVPSTATUSTO__CREATUREOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendPvpStatusTo(player);
	}
}

int TangibleObject::inflictDamage(TangibleObject* attacker, int damageType, float damage, bool destroy, bool notifyClient, bool isCombatAction) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INFLICTDAMAGE__TANGIBLEOBJECT_INT_FLOAT_BOOL_BOOL_BOOL_);
		method.addObjectParameter(attacker);
		method.addSignedIntParameter(damageType);
		method.addFloatParameter(damage);
		method.addBooleanParameter(destroy);
		method.addBooleanParameter(notifyClient);
		method.addBooleanParameter(isCombatAction);

		return method.executeWithSignedIntReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		assert((attacker == NULL) || attacker->isLockedByCurrentThread());
		return _implementation->inflictDamage(attacker, damageType, damage, destroy, notifyClient, isCombatAction);
	}
}

int TangibleObject::inflictDamage(TangibleObject* attacker, int damageType, float damage, bool destroy, const String& xp, bool notifyClient, bool isCombatAction) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INFLICTDAMAGE__TANGIBLEOBJECT_INT_FLOAT_BOOL_STRING_BOOL_BOOL_);
		method.addObjectParameter(attacker);
		method.addSignedIntParameter(damageType);
		method.addFloatParameter(damage);
		method.addBooleanParameter(destroy);
		method.addAsciiParameter(xp);
		method.addBooleanParameter(notifyClient);
		method.addBooleanParameter(isCombatAction);

		return method.executeWithSignedIntReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		assert((attacker == NULL) || attacker->isLockedByCurrentThread());
		return _implementation->inflictDamage(attacker, damageType, damage, destroy, xp, notifyClient, isCombatAction);
	}
}

int TangibleObject::healDamage(TangibleObject* healer, int damageType, float damageToHeal, bool notifyClient) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HEALDAMAGE__TANGIBLEOBJECT_INT_FLOAT_BOOL_);
		method.addObjectParameter(healer);
		method.addSignedIntParameter(damageType);
		method.addFloatParameter(damageToHeal);
		method.addBooleanParameter(notifyClient);

		return method.executeWithSignedIntReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		return _implementation->healDamage(healer, damageType, damageToHeal, notifyClient);
	}
}

void TangibleObject::setConditionDamage(float condDamage, bool notifyClient) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCONDITIONDAMAGE__FLOAT_BOOL_);
		method.addFloatParameter(condDamage);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setConditionDamage(condDamage, notifyClient);
	}
}

void TangibleObject::addVisibleComponent(int value, bool notifyClient) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDVISIBLECOMPONENT__INT_BOOL_);
		method.addSignedIntParameter(value);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->addVisibleComponent(value, notifyClient);
	}
}

void TangibleObject::removeVisibleComponent(int value, bool notifyClient) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEVISIBLECOMPONENT__INT_BOOL_);
		method.addSignedIntParameter(value);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->removeVisibleComponent(value, notifyClient);
	}
}

void TangibleObject::removeAllVisibleComponents(bool notifyClient) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEALLVISIBLECOMPONENTS__BOOL_);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->removeAllVisibleComponents(notifyClient);
	}
}

bool TangibleObject::hasVisibleComponent(int value) const {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASVISIBLECOMPONENT__INT_);
		method.addSignedIntParameter(value);

		return method.executeWithBooleanReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		return _implementation->hasVisibleComponent(value);
	}
}

void TangibleObject::setCustomizationVariable(byte type, short value, bool notifyClient) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCUSTOMIZATIONVARIABLE__BYTE_SHORT_BOOL_);
		method.addByteParameter(type);
		method.addSignedShortParameter(value);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setCustomizationVariable(type, value, notifyClient);
	}
}

void TangibleObject::setCustomizationVariable(const String& type, short value, bool notifyClient) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCUSTOMIZATIONVARIABLE__STRING_SHORT_BOOL_);
		method.addAsciiParameter(type);
		method.addSignedShortParameter(value);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setCustomizationVariable(type, value, notifyClient);
	}
}

void TangibleObject::setOptionsBitmask(unsigned int bitmask, bool notifyClient) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETOPTIONSBITMASK__INT_BOOL_);
		method.addUnsignedIntParameter(bitmask);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setOptionsBitmask(bitmask, notifyClient);
	}
}

void TangibleObject::setOptionBit(unsigned int option, bool notifyClient) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETOPTIONBIT__INT_BOOL_);
		method.addUnsignedIntParameter(option);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->setOptionBit(option, notifyClient);
	}
}

void TangibleObject::clearOptionBit(unsigned int option, bool notifyClient) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEAROPTIONBIT__INT_BOOL_);
		method.addUnsignedIntParameter(option);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->clearOptionBit(option, notifyClient);
	}
}

void TangibleObject::updateCraftingValues(CraftingValues* values, bool firstUpdate) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->updateCraftingValues(values, firstUpdate);
	}
}

int TangibleObject::notifyObjectDestructionObservers(TangibleObject* attacker, int condition, bool isCombatAction) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYOBJECTDESTRUCTIONOBSERVERS__TANGIBLEOBJECT_INT_BOOL_);
		method.addObjectParameter(attacker);
		method.addSignedIntParameter(condition);
		method.addBooleanParameter(isCombatAction);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->notifyObjectDestructionObservers(attacker, condition, isCombatAction);
	}
}

void TangibleObject::dropFromDefenderLists() {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DROPFROMDEFENDERLISTS__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->dropFromDefenderLists();
	}
}

byte TangibleObject::getObjectVisible() const {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETOBJECTVISIBLE__);

		return method.executeWithByteReturn();
	} else {
		return _implementation->getObjectVisible();
	}
}

bool TangibleObject::isKiller() {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISKILLER__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isKiller();
	}
}

bool TangibleObject::isTicketCollector() {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISTICKETCOLLECTOR__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isTicketCollector();
	}
}

bool TangibleObject::isTicketObject() {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISTICKETOBJECT__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isTicketObject();
	}
}

bool TangibleObject::isFsPuzzlePack() {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISFSPUZZLEPACK__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isFsPuzzlePack();
	}
}

bool TangibleObject::isPlantObject() {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISPLANTOBJECT__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isPlantObject();
	}
}

bool TangibleObject::isConsumable() {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISCONSUMABLE__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isConsumable();
	}
}

CustomizationVariables* TangibleObject::getCustomizationVariables() {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getCustomizationVariables();
	}
}

int TangibleObject::getUseCount() const {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETUSECOUNT__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getUseCount();
	}
}

int TangibleObject::getMaxCondition() const {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMAXCONDITION__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getMaxCondition();
	}
}

void TangibleObject::setMaxCondition(int maxCond, bool notifyClient) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETMAXCONDITION__INT_BOOL_);
		method.addSignedIntParameter(maxCond);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->setMaxCondition(maxCond, notifyClient);
	}
}

int TangibleObject::getConditionDamage() const {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCONDITIONDAMAGE__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getConditionDamage();
	}
}

int TangibleObject::getUnmitigatedDamage() const {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETUNMITIGATEDDAMAGE__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getUnmitigatedDamage();
	}
}

void TangibleObject::addUnmitigatedDamage(float damage) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDUNMITIGATEDDAMAGE__FLOAT_);
		method.addFloatParameter(damage);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->addUnmitigatedDamage(damage);
	}
}

int TangibleObject::getVolume() const {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETVOLUME__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getVolume();
	}
}

void TangibleObject::setComplexity(float value) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCOMPLEXITY__FLOAT_);
		method.addFloatParameter(value);

		method.executeWithVoidReturn();
	} else {
		_implementation->setComplexity(value);
	}
}

float TangibleObject::getComplexity() const {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCOMPLEXITY__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getComplexity();
	}
}

unsigned int TangibleObject::getOptionsBitmask() const {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETOPTIONSBITMASK__);

		return method.executeWithUnsignedIntReturn();
	} else {
		return _implementation->getOptionsBitmask();
	}
}

void TangibleObject::addMagicBit(bool notifyClient) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDMAGICBIT__BOOL_);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->addMagicBit(notifyClient);
	}
}

void TangibleObject::removeMagicBit(bool notifyClient) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEMAGICBIT__BOOL_);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->removeMagicBit(notifyClient);
	}
}

int TangibleObject::getLevel() const {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETLEVEL__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getLevel();
	}
}

bool TangibleObject::getIsCraftedEnhancedItem() const {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETISCRAFTEDENHANCEDITEM__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->getIsCraftedEnhancedItem();
	}
}

unsigned int TangibleObject::getPvpStatusBitmask() const {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETPVPSTATUSBITMASK__);

		return method.executeWithUnsignedIntReturn();
	} else {
		return _implementation->getPvpStatusBitmask();
	}
}

bool TangibleObject::isTangibleObject() {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISTANGIBLEOBJECT__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isTangibleObject();
	}
}

void TangibleObject::getCustomizationString(String& variables) const {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCUSTOMIZATIONSTRING__STRING_);
		method.addAsciiParameter(variables);

		method.executeWithVoidReturn();
	} else {
		_implementation->getCustomizationString(variables);
	}
}

const DeltaVector<ManagedReference<SceneObject* > >* TangibleObject::getDefenderList() const {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getDefenderList();
	}
}

const AutoDeltaSet<int>* TangibleObject::getVisibleComponents() const {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getVisibleComponents();
	}
}

SceneObject* TangibleObject::getMainDefender() const {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMAINDEFENDER__);

		return static_cast<SceneObject*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getMainDefender();
	}
}

bool TangibleObject::isDestroyed() const {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISDESTROYED__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isDestroyed();
	}
}

void TangibleObject::setFaction(unsigned int crc) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETFACTION__INT_);
		method.addUnsignedIntParameter(crc);

		method.executeWithVoidReturn();
	} else {
		_implementation->setFaction(crc);
	}
}

unsigned int TangibleObject::getFaction() const {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETFACTION__);

		return method.executeWithUnsignedIntReturn();
	} else {
		return _implementation->getFaction();
	}
}

bool TangibleObject::isRebel() const {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISREBEL__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isRebel();
	}
}

bool TangibleObject::isImperial() const {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISIMPERIAL__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isImperial();
	}
}

bool TangibleObject::isNeutral() const {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISNEUTRAL__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isNeutral();
	}
}

int TangibleObject::getFactionStatus() const {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETFACTIONSTATUS__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getFactionStatus();
	}
}

void TangibleObject::setFactionStatus(int status) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETFACTIONSTATUS__INT_);
		method.addSignedIntParameter(status);

		method.executeWithVoidReturn();
	} else {
		_implementation->setFactionStatus(status);
	}
}

int TangibleObject::getFutureFactionStatus() const {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETFUTUREFACTIONSTATUS__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getFutureFactionStatus();
	}
}

void TangibleObject::setFutureFactionStatus(int status) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETFUTUREFACTIONSTATUS__INT_);
		method.addSignedIntParameter(status);

		method.executeWithVoidReturn();
	} else {
		_implementation->setFutureFactionStatus(status);
	}
}

TangibleObject* TangibleObject::__asTangibleObject() {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->asTangibleObject();
	}
}

bool TangibleObject::isSliceable() {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISSLICEABLE__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isSliceable();
	}
}

bool TangibleObject::isSliced() const {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISSLICED__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isSliced();
	}
}

void TangibleObject::setSliceable(bool val) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSLICEABLE__BOOL_);
		method.addBooleanParameter(val);

		method.executeWithVoidReturn();
	} else {
		_implementation->setSliceable(val);
	}
}

void TangibleObject::setSliced(bool slice) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSLICED__BOOL_);
		method.addBooleanParameter(slice);

		method.executeWithVoidReturn();
	} else {
		_implementation->setSliced(slice);
	}
}

bool TangibleObject::isJediRobe() const {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISJEDIROBE__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isJediRobe();
	}
}

bool TangibleObject::isUnionRing() const {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISUNIONRING__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isUnionRing();
	}
}

void TangibleObject::setUnionRing(bool val) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETUNIONRING__BOOL_);
		method.addBooleanParameter(val);

		method.executeWithVoidReturn();
	} else {
		_implementation->setUnionRing(val);
	}
}

void TangibleObject::setCustomizationString(const String& vars) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCUSTOMIZATIONSTRING__STRING_);
		method.addAsciiParameter(vars);

		method.executeWithVoidReturn();
	} else {
		_implementation->setCustomizationString(vars);
	}
}

void TangibleObject::setIsCraftedEnhancedItem(bool value) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETISCRAFTEDENHANCEDITEM__BOOL_);
		method.addBooleanParameter(value);

		method.executeWithVoidReturn();
	} else {
		_implementation->setIsCraftedEnhancedItem(value);
	}
}

void TangibleObject::setPvpStatusBitmask(unsigned int bitmask, bool notifyClient) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETPVPSTATUSBITMASK__INT_BOOL_);
		method.addUnsignedIntParameter(bitmask);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->setPvpStatusBitmask(bitmask, notifyClient);
	}
}

void TangibleObject::setPvpStatusBit(unsigned int pvpStatus, bool notifyClient) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETPVPSTATUSBIT__INT_BOOL_);
		method.addUnsignedIntParameter(pvpStatus);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->setPvpStatusBit(pvpStatus, notifyClient);
	}
}

void TangibleObject::clearPvpStatusBit(unsigned int pvpStatus, bool notifyClient) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARPVPSTATUSBIT__INT_BOOL_);
		method.addUnsignedIntParameter(pvpStatus);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->clearPvpStatusBit(pvpStatus, notifyClient);
	}
}

void TangibleObject::setCraftersName(String& name) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCRAFTERSNAME__STRING_);
		method.addAsciiParameter(name);

		method.executeWithVoidReturn();
	} else {
		_implementation->setCraftersName(name);
	}
}

void TangibleObject::setCraftersID(unsigned long long crafterOID) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCRAFTERSID__LONG_);
		method.addUnsignedLongParameter(crafterOID);

		method.executeWithVoidReturn();
	} else {
		_implementation->setCraftersID(crafterOID);
	}
}

String TangibleObject::getCraftersName() {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCRAFTERSNAME__);

		String _return_getCraftersName;
		method.executeWithAsciiReturn(_return_getCraftersName);
		return _return_getCraftersName;
	} else {
		return _implementation->getCraftersName();
	}
}

unsigned long long TangibleObject::getCraftersID() const {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCRAFTERSID__);

		return method.executeWithUnsignedLongReturn();
	} else {
		return _implementation->getCraftersID();
	}
}

void TangibleObject::setJunkDealerNeeded(int jdNeeded) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETJUNKDEALERNEEDED__INT_);
		method.addSignedIntParameter(jdNeeded);

		method.executeWithVoidReturn();
	} else {
		_implementation->setJunkDealerNeeded(jdNeeded);
	}
}

int TangibleObject::getJunkDealerNeeded() {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETJUNKDEALERNEEDED__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getJunkDealerNeeded();
	}
}

void TangibleObject::setJunkValue(int jValue) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETJUNKVALUE__INT_);
		method.addSignedIntParameter(jValue);

		method.executeWithVoidReturn();
	} else {
		_implementation->setJunkValue(jValue);
	}
}

int TangibleObject::getJunkValue() const {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETJUNKVALUE__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getJunkValue();
	}
}

void TangibleObject::setSerialNumber(const String& serial) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSERIALNUMBER__STRING_);
		method.addAsciiParameter(serial);

		method.executeWithVoidReturn();
	} else {
		_implementation->setSerialNumber(serial);
	}
}

void TangibleObject::setLevel(int lev, bool randomHam) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETLEVEL__INT_BOOL_);
		method.addSignedIntParameter(lev);
		method.addBooleanParameter(randomHam);

		method.executeWithVoidReturn();
	} else {
		_implementation->setLevel(lev, randomHam);
	}
}

String TangibleObject::getSerialNumber() {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSERIALNUMBER__);

		String _return_getSerialNumber;
		method.executeWithAsciiReturn(_return_getSerialNumber);
		return _return_getSerialNumber;
	} else {
		return _implementation->getSerialNumber();
	}
}

ThreatMap* TangibleObject::getThreatMap() {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		assert(this->isLockedByCurrentThread());
		return _implementation->getThreatMap();
	}
}

Reference<FactoryCrate* > TangibleObject::createFactoryCrate(int maxSize, String& type, bool insertSelf) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CREATEFACTORYCRATE__INT_STRING_BOOL_);
		method.addSignedIntParameter(maxSize);
		method.addAsciiParameter(type);
		method.addBooleanParameter(insertSelf);

		return static_cast<FactoryCrate*>(method.executeWithObjectReturn());
	} else {
		return _implementation->createFactoryCrate(maxSize, type, insertSelf);
	}
}

bool TangibleObject::canRepair(CreatureObject* player) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CANREPAIR__CREATUREOBJECT_);
		method.addObjectParameter(player);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->canRepair(player);
	}
}

void TangibleObject::repair(CreatureObject* player, RepairTool* repairTool) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REPAIR__CREATUREOBJECT_REPAIRTOOL_);
		method.addObjectParameter(player);
		method.addObjectParameter(repairTool);

		method.executeWithVoidReturn();
	} else {
		_implementation->repair(player, repairTool);
	}
}

String TangibleObject::repairAttempt(int repairChance) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REPAIRATTEMPT__INT_);
		method.addSignedIntParameter(repairChance);

		String _return_repairAttempt;
		method.executeWithAsciiReturn(_return_repairAttempt);
		return _return_repairAttempt;
	} else {
		return _implementation->repairAttempt(repairChance);
	}
}

bool TangibleObject::isBroken() const {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISBROKEN__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isBroken();
	}
}

float TangibleObject::getHitChance() const {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETHITCHANCE__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getHitChance();
	}
}

void TangibleObject::broadcastPvpStatusBitmask() {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_BROADCASTPVPSTATUSBITMASK__);

		method.executeWithVoidReturn();
	} else {
		_implementation->broadcastPvpStatusBitmask();
	}
}

void TangibleObject::addActiveArea(ActiveArea* area) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDACTIVEAREA__ACTIVEAREA_);
		method.addObjectParameter(area);

		method.executeWithVoidReturn();
	} else {
		_implementation->addActiveArea(area);
	}
}

void TangibleObject::dropActiveArea(ActiveArea* area) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DROPACTIVEAREA__ACTIVEAREA_);
		method.addObjectParameter(area);

		method.executeWithVoidReturn();
	} else {
		_implementation->dropActiveArea(area);
	}
}

bool TangibleObject::hasActiveArea(ActiveArea* area) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASACTIVEAREA__ACTIVEAREA_);
		method.addObjectParameter(area);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasActiveArea(area);
	}
}

bool TangibleObject::hasActiveArea(unsigned long long objectid) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASACTIVEAREA__LONG_);
		method.addUnsignedLongParameter(objectid);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasActiveArea(objectid);
	}
}

bool TangibleObject::isInNoCombatArea() const {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISINNOCOMBATAREA__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isInNoCombatArea();
	}
}

void TangibleObject::setInNoCombatArea(bool val) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETINNOCOMBATAREA__BOOL_);
		method.addBooleanParameter(val);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setInNoCombatArea(val);
	}
}

SortedVector<ManagedReference<ActiveArea* > >* TangibleObject::getActiveAreas() {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getActiveAreas();
	}
}

int TangibleObject::getActiveAreasSize() const {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETACTIVEAREASSIZE__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getActiveAreasSize();
	}
}

Reference<ActiveArea* > TangibleObject::getActiveRegion() {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETACTIVEREGION__);

		return static_cast<ActiveArea*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getActiveRegion();
	}
}

bool TangibleObject::isNoTrade() const {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISNOTRADE__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isNoTrade();
	}
}

bool TangibleObject::hasAntiDecayKit() const {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASANTIDECAYKIT__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasAntiDecayKit();
	}
}

unsigned long long TangibleObject::getAntiDecayKitObjectID() const {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETANTIDECAYKITOBJECTID__);

		return method.executeWithUnsignedLongReturn();
	} else {
		return _implementation->getAntiDecayKitObjectID();
	}
}

void TangibleObject::applyAntiDecayKit(CreatureObject* player, SceneObject* adk) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_APPLYANTIDECAYKIT__CREATUREOBJECT_SCENEOBJECT_);
		method.addObjectParameter(player);
		method.addObjectParameter(adk);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->applyAntiDecayKit(player, adk);
	}
}

SceneObject* TangibleObject::removeAntiDecayKit() {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEANTIDECAYKIT__);

		return static_cast<SceneObject*>(method.executeWithObjectReturn());
	} else {
		assert(this->isLockedByCurrentThread());
		return _implementation->removeAntiDecayKit();
	}
}

void TangibleObject::destroyObjectFromDatabase(bool destroyContainedObjects) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DESTROYOBJECTFROMDATABASE__BOOL_);
		method.addBooleanParameter(destroyContainedObjects);

		method.executeWithVoidReturn();
	} else {
		_implementation->destroyObjectFromDatabase(destroyContainedObjects);
	}
}

bool TangibleObject::isCityStreetLamp() const {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISCITYSTREETLAMP__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isCityStreetLamp();
	}
}

bool TangibleObject::isCityStatue() const {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISCITYSTATUE__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isCityStatue();
	}
}

bool TangibleObject::isCityFountain() const {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISCITYFOUNTAIN__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isCityFountain();
	}
}

bool TangibleObject::isInvisible() const {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISINVISIBLE__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isInvisible();
	}
}

void TangibleObject::setInvisible(bool invis) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETINVISIBLE__BOOL_);
		method.addBooleanParameter(invis);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setInvisible(invis);
	}
}

bool TangibleObject::isCustomIngredient() {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISCUSTOMINGREDIENT__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isCustomIngredient();
	}
}

void TangibleObject::setLuaStringData(const String& key, const String& data) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETLUASTRINGDATA__STRING_STRING_);
		method.addAsciiParameter(key);
		method.addAsciiParameter(data);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setLuaStringData(key, data);
	}
}

void TangibleObject::deleteLuaStringData(const String& key) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DELETELUASTRINGDATA__STRING_);
		method.addAsciiParameter(key);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->deleteLuaStringData(key);
	}
}

String TangibleObject::getLuaStringData(const String& key) const {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETLUASTRINGDATA__STRING_);
		method.addAsciiParameter(key);

		String _return_getLuaStringData;
		method.executeWithAsciiReturn(_return_getLuaStringData);
		return _return_getLuaStringData;
	} else {
		return _implementation->getLuaStringData(key);
	}
}

void TangibleObject::setDisabled(bool disabled) {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETDISABLED__BOOL_);
		method.addBooleanParameter(disabled);

		method.executeWithVoidReturn();
	} else {
		_implementation->setDisabled(disabled);
	}
}

bool TangibleObject::isDisabled() const {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISDISABLED__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isDisabled();
	}
}

bool TangibleObject::isInNavMesh() {
	TangibleObjectImplementation* _implementation = static_cast<TangibleObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISINNAVMESH__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isInNavMesh();
	}
}

DistributedObjectServant* TangibleObject::_getImplementation() {

	 if (!_updated) _updated = true;
	return _impl;
}

DistributedObjectServant* TangibleObject::_getImplementationForRead() const {
	return _impl;
}

void TangibleObject::_setImplementation(DistributedObjectServant* servant) {
	_impl = servant;
}

/*
 *	TangibleObjectImplementation
 */

TangibleObjectImplementation::TangibleObjectImplementation(DummyConstructorParameter* param) : SceneObjectImplementation(param) {
	_initializeImplementation();
}


TangibleObjectImplementation::~TangibleObjectImplementation() {
}


void TangibleObjectImplementation::finalize() {
}

void TangibleObjectImplementation::_initializeImplementation() {
	_setClassHelper(TangibleObjectHelper::instance());

	_this = NULL;

	_serializationHelperMethod();
}

void TangibleObjectImplementation::_setStub(DistributedObjectStub* stub) {
	_this = static_cast<TangibleObject*>(stub);
	SceneObjectImplementation::_setStub(stub);
}

DistributedObjectStub* TangibleObjectImplementation::_getStub() {
	return _this.get();
}

TangibleObjectImplementation::operator const TangibleObject*() {
	return _this.get();
}

void TangibleObjectImplementation::lock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->lock(doLock);
}

void TangibleObjectImplementation::lock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->lock(obj);
}

void TangibleObjectImplementation::rlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->rlock(doLock);
}

void TangibleObjectImplementation::wlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->wlock(doLock);
}

void TangibleObjectImplementation::wlock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->wlock(obj);
}

void TangibleObjectImplementation::unlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->unlock(doLock);
}

void TangibleObjectImplementation::runlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->runlock(doLock);
}

void TangibleObjectImplementation::_serializationHelperMethod() {
	SceneObjectImplementation::_serializationHelperMethod();

	_setClassName("TangibleObject");

}

void TangibleObjectImplementation::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(TangibleObjectImplementation::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

	initializeTransientMembers();
}

bool TangibleObjectImplementation::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (SceneObjectImplementation::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0x44d211d4: //TangibleObject.targetable
		TypeInfo<bool >::parseFromBinaryStream(&targetable, stream);
		return true;

	case 0x8ac8d204: //TangibleObject.complexity
		TypeInfo<float >::parseFromBinaryStream(&complexity, stream);
		return true;

	case 0x1e059da5: //TangibleObject.volume
		TypeInfo<int >::parseFromBinaryStream(&volume, stream);
		return true;

	case 0x7aa39254: //TangibleObject.faction
		TypeInfo<unsigned int >::parseFromBinaryStream(&faction, stream);
		return true;

	case 0x26d472b0: //TangibleObject.factionStatus
		TypeInfo<int >::parseFromBinaryStream(&factionStatus, stream);
		return true;

	case 0xa4095b71: //TangibleObject.futureFactionStatus
		TypeInfo<int >::parseFromBinaryStream(&futureFactionStatus, stream);
		return true;

	case 0xc5251423: //TangibleObject.invisible
		TypeInfo<bool >::parseFromBinaryStream(&invisible, stream);
		return true;

	case 0xf53ca7: //TangibleObject.luaStringData
		TypeInfo<VectorMap<String, String> >::parseFromBinaryStream(&luaStringData, stream);
		return true;

	case 0xb56f0247: //TangibleObject.customizationVariables
		TypeInfo<CustomizationVariables >::parseFromBinaryStream(&customizationVariables, stream);
		return true;

	case 0x446e9ce1: //TangibleObject.unmitigatedDamage
		TypeInfo<int >::parseFromBinaryStream(&unmitigatedDamage, stream);
		return true;

	case 0xa4a80d3: //TangibleObject.conditionDamage
		TypeInfo<float >::parseFromBinaryStream(&conditionDamage, stream);
		return true;

	case 0x9c2e3029: //TangibleObject.maxCondition
		TypeInfo<int >::parseFromBinaryStream(&maxCondition, stream);
		return true;

	case 0xe6b8cb07: //TangibleObject.useCount
		TypeInfo<int >::parseFromBinaryStream(&useCount, stream);
		return true;

	case 0xf479fb1c: //TangibleObject.level
		TypeInfo<short >::parseFromBinaryStream(&level, stream);
		return true;

	case 0x6352a44d: //TangibleObject.optionsBitmask
		TypeInfo<unsigned int >::parseFromBinaryStream(&optionsBitmask, stream);
		return true;

	case 0xcbed6feb: //TangibleObject.magicBits
		TypeInfo<AtomicInteger >::parseFromBinaryStream(&magicBits, stream);
		return true;

	case 0x7169fd57: //TangibleObject.visibleComponents
		TypeInfo<AutoDeltaSet<int> >::parseFromBinaryStream(&visibleComponents, stream);
		return true;

	case 0x71d5e6e0: //TangibleObject.isCraftedEnhancedItem
		TypeInfo<bool >::parseFromBinaryStream(&isCraftedEnhancedItem, stream);
		return true;

	case 0x78a68bd7: //TangibleObject.pvpStatusBitmask
		TypeInfo<unsigned int >::parseFromBinaryStream(&pvpStatusBitmask, stream);
		return true;

	case 0x8a9c44bb: //TangibleObject.objectVisible
		TypeInfo<byte >::parseFromBinaryStream(&objectVisible, stream);
		return true;

	case 0xf6530d9d: //TangibleObject.craftersName
		TypeInfo<String >::parseFromBinaryStream(&craftersName, stream);
		return true;

	case 0x2673c744: //TangibleObject.craftersID
		TypeInfo<unsigned long long >::parseFromBinaryStream(&craftersID, stream);
		return true;

	case 0xa090b45c: //TangibleObject.junkDealerNeeded
		TypeInfo<int >::parseFromBinaryStream(&junkDealerNeeded, stream);
		return true;

	case 0x30289553: //TangibleObject.junkValue
		TypeInfo<int >::parseFromBinaryStream(&junkValue, stream);
		return true;

	case 0x4f048d7d: //TangibleObject.objectSerial
		TypeInfo<String >::parseFromBinaryStream(&objectSerial, stream);
		return true;

	case 0x80b5a6a4: //TangibleObject.defenderList
		TypeInfo<DeltaVector<ManagedReference<SceneObject* > > >::parseFromBinaryStream(&defenderList, stream);
		return true;

	case 0x5e49de61: //TangibleObject.sliceable
		TypeInfo<bool >::parseFromBinaryStream(&sliceable, stream);
		return true;

	case 0x85d2a69f: //TangibleObject.sliced
		TypeInfo<bool >::parseFromBinaryStream(&sliced, stream);
		return true;

	case 0x140b08d0: //TangibleObject.activeAreas
		TypeInfo<SortedVector<ManagedReference<ActiveArea* > > >::parseFromBinaryStream(&activeAreas, stream);
		return true;

	case 0x2e41d02d: //TangibleObject.antiDecayKitObject
		TypeInfo<ManagedReference<SceneObject* > >::parseFromBinaryStream(&antiDecayKitObject, stream);
		return true;

	case 0x407b9075: //TangibleObject.jediRobe
		TypeInfo<bool >::parseFromBinaryStream(&jediRobe, stream);
		return true;

	case 0x3bc3bd92: //TangibleObject.unionRing
		TypeInfo<bool >::parseFromBinaryStream(&unionRing, stream);
		return true;

	}

	return false;
}

void TangibleObjectImplementation::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = TangibleObjectImplementation::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int TangibleObjectImplementation::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = SceneObjectImplementation::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	_nameHashCode = 0x44d211d4; //TangibleObject.targetable
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&targetable, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x8ac8d204; //TangibleObject.complexity
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&complexity, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x1e059da5; //TangibleObject.volume
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&volume, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x7aa39254; //TangibleObject.faction
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned int >::toBinaryStream(&faction, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x26d472b0; //TangibleObject.factionStatus
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&factionStatus, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xa4095b71; //TangibleObject.futureFactionStatus
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&futureFactionStatus, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xc5251423; //TangibleObject.invisible
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&invisible, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xf53ca7; //TangibleObject.luaStringData
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<VectorMap<String, String> >::toBinaryStream(&luaStringData, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xb56f0247; //TangibleObject.customizationVariables
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<CustomizationVariables >::toBinaryStream(&customizationVariables, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x446e9ce1; //TangibleObject.unmitigatedDamage
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&unmitigatedDamage, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xa4a80d3; //TangibleObject.conditionDamage
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&conditionDamage, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x9c2e3029; //TangibleObject.maxCondition
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&maxCondition, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xe6b8cb07; //TangibleObject.useCount
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&useCount, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xf479fb1c; //TangibleObject.level
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<short >::toBinaryStream(&level, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x6352a44d; //TangibleObject.optionsBitmask
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned int >::toBinaryStream(&optionsBitmask, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xcbed6feb; //TangibleObject.magicBits
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<AtomicInteger >::toBinaryStream(&magicBits, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x7169fd57; //TangibleObject.visibleComponents
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<AutoDeltaSet<int> >::toBinaryStream(&visibleComponents, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x71d5e6e0; //TangibleObject.isCraftedEnhancedItem
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&isCraftedEnhancedItem, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x78a68bd7; //TangibleObject.pvpStatusBitmask
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned int >::toBinaryStream(&pvpStatusBitmask, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x8a9c44bb; //TangibleObject.objectVisible
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<byte >::toBinaryStream(&objectVisible, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xf6530d9d; //TangibleObject.craftersName
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&craftersName, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x2673c744; //TangibleObject.craftersID
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&craftersID, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xa090b45c; //TangibleObject.junkDealerNeeded
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&junkDealerNeeded, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x30289553; //TangibleObject.junkValue
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&junkValue, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x4f048d7d; //TangibleObject.objectSerial
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&objectSerial, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x80b5a6a4; //TangibleObject.defenderList
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<DeltaVector<ManagedReference<SceneObject* > > >::toBinaryStream(&defenderList, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x5e49de61; //TangibleObject.sliceable
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&sliceable, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x85d2a69f; //TangibleObject.sliced
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&sliced, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x140b08d0; //TangibleObject.activeAreas
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<SortedVector<ManagedReference<ActiveArea* > > >::toBinaryStream(&activeAreas, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x2e41d02d; //TangibleObject.antiDecayKitObject
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedReference<SceneObject* > >::toBinaryStream(&antiDecayKitObject, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x407b9075; //TangibleObject.jediRobe
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&jediRobe, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x3bc3bd92; //TangibleObject.unionRing
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&unionRing, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;


	return _count;
}

void TangibleObjectImplementation::writeJSON(nlohmann::json& j) {
	SceneObjectImplementation::writeJSON(j);

	nlohmann::json thisObject = nlohmann::json::object();
	thisObject["targetable"] = targetable;

	thisObject["complexity"] = complexity;

	thisObject["volume"] = volume;

	thisObject["faction"] = faction;

	thisObject["factionStatus"] = factionStatus;

	thisObject["futureFactionStatus"] = futureFactionStatus;

	thisObject["invisible"] = invisible;

	thisObject["luaStringData"] = luaStringData;

	thisObject["customizationVariables"] = customizationVariables;

	thisObject["unmitigatedDamage"] = unmitigatedDamage;

	thisObject["conditionDamage"] = conditionDamage;

	thisObject["maxCondition"] = maxCondition;

	thisObject["useCount"] = useCount;

	thisObject["level"] = level;

	thisObject["optionsBitmask"] = optionsBitmask;

	thisObject["magicBits"] = magicBits;

	thisObject["visibleComponents"] = visibleComponents;

	thisObject["isCraftedEnhancedItem"] = isCraftedEnhancedItem;

	thisObject["pvpStatusBitmask"] = pvpStatusBitmask;

	thisObject["objectVisible"] = objectVisible;

	thisObject["craftersName"] = craftersName;

	thisObject["craftersID"] = craftersID;

	thisObject["junkDealerNeeded"] = junkDealerNeeded;

	thisObject["junkValue"] = junkValue;

	thisObject["objectSerial"] = objectSerial;

	thisObject["defenderList"] = defenderList;

	thisObject["sliceable"] = sliceable;

	thisObject["sliced"] = sliced;

	thisObject["activeAreas"] = activeAreas;

	thisObject["antiDecayKitObject"] = antiDecayKitObject;

	thisObject["jediRobe"] = jediRobe;

	thisObject["unionRing"] = unionRing;

	j["TangibleObject"] = thisObject;
}

TangibleObjectImplementation::TangibleObjectImplementation() {
	_initializeImplementation();
	// server/zone/objects/tangible/TangibleObject.idl():  		Logger.setLoggingName("TangibleObject");
	Logger::setLoggingName("TangibleObject");
	// server/zone/objects/tangible/TangibleObject.idl():  		initializeMembers();
	initializeMembers();
	// server/zone/objects/tangible/TangibleObject.idl():  		invisible = false;
	invisible = false;
	// server/zone/objects/tangible/TangibleObject.idl():  		antiDecayKitObject = null;
	antiDecayKitObject = NULL;
	// server/zone/objects/tangible/TangibleObject.idl():  		jediRobe = false;
	jediRobe = false;
	// server/zone/objects/tangible/TangibleObject.idl():  		unionRing = false;
	unionRing = false;
	// server/zone/objects/tangible/TangibleObject.idl():  		luaStringData.setAllowOverwriteInsertPlan();
	(&luaStringData)->setAllowOverwriteInsertPlan();
}

void TangibleObjectImplementation::initializeMembers() {
	// server/zone/objects/tangible/TangibleObject.idl():  		faction = 0;
	faction = 0;
	// server/zone/objects/tangible/TangibleObject.idl():  		factionStatus = 0;
	factionStatus = 0;
	// server/zone/objects/tangible/TangibleObject.idl():  		futureFactionStatus = -1;
	futureFactionStatus = -1;
	// server/zone/objects/tangible/TangibleObject.idl():  		level = 1;
	level = 1;
	// server/zone/objects/tangible/TangibleObject.idl():  		useCount = 1;
	useCount = 1;
	// server/zone/objects/tangible/TangibleObject.idl():  		complexity = 100.f;
	complexity = 100.f;
	// server/zone/objects/tangible/TangibleObject.idl():  		volume = 1;
	volume = 1;
	// server/zone/objects/tangible/TangibleObject.idl():  		craftersID = 0;
	craftersID = 0;
	// server/zone/objects/tangible/TangibleObject.idl():  		objectVisible = 1;
	objectVisible = 1;
	// server/zone/objects/tangible/TangibleObject.idl():  		useCount = 1;
	useCount = 1;
	// server/zone/objects/tangible/TangibleObject.idl():  		conditionDamage = 0;
	conditionDamage = 0;
	// server/zone/objects/tangible/TangibleObject.idl():  		unmitigatedDamage = 0;
	unmitigatedDamage = 0;
	// server/zone/objects/tangible/TangibleObject.idl():  		sliceable = false;
	sliceable = false;
	// server/zone/objects/tangible/TangibleObject.idl():  		sliced = false;
	sliced = false;
	// server/zone/objects/tangible/TangibleObject.idl():  		isCraftedEnhancedItem = false;
	isCraftedEnhancedItem = false;
	// server/zone/objects/tangible/TangibleObject.idl():  		threatMap = null;
	threatMap = NULL;
	// server/zone/objects/tangible/TangibleObject.idl():  		junkDealerNeeded = 0;
	junkDealerNeeded = 0;
	// server/zone/objects/tangible/TangibleObject.idl():  		junkValue = 0;
	junkValue = 0;
}

void TangibleObjectImplementation::applySkillModsTo(CreatureObject* creature) const{
}

void TangibleObjectImplementation::removeSkillModsFrom(CreatureObject* creature) {
}

void TangibleObjectImplementation::addSkillMod(const int skillType, const String& skillMod, int value, bool notifyClient) {
}

void TangibleObjectImplementation::removeSkillMod(const int skillType, const String& skillMod, int value, bool notifyClient) {
}

void TangibleObjectImplementation::removeAllSkillModsOfType(const int skillType, bool notifyClient) {
}

void TangibleObjectImplementation::setCombatState() {
}

void TangibleObjectImplementation::clearCombatState(bool clearDefenders) {
	// server/zone/objects/tangible/TangibleObject.idl():  	}
	if (clearDefenders)	// server/zone/objects/tangible/TangibleObject.idl():  			removeDefenders();
	removeDefenders();
}

bool TangibleObjectImplementation::hasDefender(const SceneObject* defender) const{
	// server/zone/objects/tangible/TangibleObject.idl():  		}
	for (	// server/zone/objects/tangible/TangibleObject.idl():  		for (int i = 0;
	int i = 0;
	i < (&defenderList)->size();
 ++i) {
	// server/zone/objects/tangible/TangibleObject.idl():  		}
	if ((&defenderList)->get(i) == defender)	// server/zone/objects/tangible/TangibleObject.idl():  				return true;
	return true;
}
	// server/zone/objects/tangible/TangibleObject.idl():  		return false;
	return false;
}

bool TangibleObjectImplementation::isAggressiveTo(CreatureObject* object) {
	// server/zone/objects/tangible/TangibleObject.idl():  		return false;
	return false;
}

bool TangibleObjectImplementation::isHealableBy(CreatureObject* object) {
	// server/zone/objects/tangible/TangibleObject.idl():  		return false;
	return false;
}

bool TangibleObjectImplementation::hasVisibleComponent(int value) const{
	// server/zone/objects/tangible/TangibleObject.idl():  		return visibleComponents.contains(value);
	return (&visibleComponents)->contains(value);
}

byte TangibleObjectImplementation::getObjectVisible() const{
	// server/zone/objects/tangible/TangibleObject.idl():  		return objectVisible;
	return objectVisible;
}

bool TangibleObjectImplementation::isKiller() {
	// server/zone/objects/tangible/TangibleObject.idl():  		return false;
	return false;
}

bool TangibleObjectImplementation::isTicketCollector() {
	// server/zone/objects/tangible/TangibleObject.idl():  		return false;
	return false;
}

bool TangibleObjectImplementation::isTicketObject() {
	// server/zone/objects/tangible/TangibleObject.idl():  		return false;
	return false;
}

bool TangibleObjectImplementation::isFsPuzzlePack() {
	// server/zone/objects/tangible/TangibleObject.idl():  		return false;
	return false;
}

bool TangibleObjectImplementation::isPlantObject() {
	// server/zone/objects/tangible/TangibleObject.idl():  		return false;
	return false;
}

bool TangibleObjectImplementation::isConsumable() {
	// server/zone/objects/tangible/TangibleObject.idl():  		return false;
	return false;
}

CustomizationVariables* TangibleObjectImplementation::getCustomizationVariables() {
	// server/zone/objects/tangible/TangibleObject.idl():  		return customizationVariables;
	return (&customizationVariables);
}

int TangibleObjectImplementation::getUseCount() const{
	// server/zone/objects/tangible/TangibleObject.idl():  		return useCount;
	return useCount;
}

int TangibleObjectImplementation::getMaxCondition() const{
	// server/zone/objects/tangible/TangibleObject.idl():  		return maxCondition;
	return maxCondition;
}

int TangibleObjectImplementation::getConditionDamage() const{
	// server/zone/objects/tangible/TangibleObject.idl():  		return (int)conditionDamage;
	return (int) conditionDamage;
}

int TangibleObjectImplementation::getUnmitigatedDamage() const{
	// server/zone/objects/tangible/TangibleObject.idl():  		return unmitigatedDamage;
	return unmitigatedDamage;
}

void TangibleObjectImplementation::addUnmitigatedDamage(float damage) {
	// server/zone/objects/tangible/TangibleObject.idl():  		unmitigatedDamage += (int)damage;
	unmitigatedDamage += (int) damage;
}

int TangibleObjectImplementation::getVolume() const{
	// server/zone/objects/tangible/TangibleObject.idl():  		return volume;
	return volume;
}

void TangibleObjectImplementation::setComplexity(float value) {
	// server/zone/objects/tangible/TangibleObject.idl():  		complexity = value;
	complexity = value;
}

float TangibleObjectImplementation::getComplexity() const{
	// server/zone/objects/tangible/TangibleObject.idl():  		return complexity;
	return complexity;
}

unsigned int TangibleObjectImplementation::getOptionsBitmask() const{
	// server/zone/objects/tangible/TangibleObject.idl():  		return optionsBitmask;
	return optionsBitmask;
}

void TangibleObjectImplementation::addMagicBit(bool notifyClient) {
	// server/zone/objects/tangible/TangibleObject.idl():  	}
	if ((&magicBits)->increment() == 1)	// server/zone/objects/tangible/TangibleObject.idl():  			setOptionBit(OptionBitmask.YELLOW, notifyClient);
	setOptionBit(OptionBitmask::YELLOW, notifyClient);
}

void TangibleObjectImplementation::removeMagicBit(bool notifyClient) {
	// server/zone/objects/tangible/TangibleObject.idl():  	}
	if ((&magicBits)->decrement() == 0)	// server/zone/objects/tangible/TangibleObject.idl():  			clearOptionBit(OptionBitmask.YELLOW, notifyClient);
	clearOptionBit(OptionBitmask::YELLOW, notifyClient);
}

int TangibleObjectImplementation::getLevel() const{
	// server/zone/objects/tangible/TangibleObject.idl():  		return level;
	return level;
}

bool TangibleObjectImplementation::getIsCraftedEnhancedItem() const{
	// server/zone/objects/tangible/TangibleObject.idl():  		return isCraftedEnhancedItem;
	return isCraftedEnhancedItem;
}

unsigned int TangibleObjectImplementation::getPvpStatusBitmask() const{
	// server/zone/objects/tangible/TangibleObject.idl():  		return pvpStatusBitmask;
	return pvpStatusBitmask;
}

bool TangibleObjectImplementation::isTangibleObject() {
	// server/zone/objects/tangible/TangibleObject.idl():  		return true;
	return true;
}

void TangibleObjectImplementation::getCustomizationString(String& variables) const{
	// server/zone/objects/tangible/TangibleObject.idl():  		customizationVariables.getData(variables);
	(&customizationVariables)->getData(variables);
}

const DeltaVector<ManagedReference<SceneObject* > >* TangibleObjectImplementation::getDefenderList() const{
	// server/zone/objects/tangible/TangibleObject.idl():  		return defenderList;
	return (&defenderList);
}

const AutoDeltaSet<int>* TangibleObjectImplementation::getVisibleComponents() const{
	// server/zone/objects/tangible/TangibleObject.idl():  		return visibleComponents;
	return (&visibleComponents);
}

SceneObject* TangibleObjectImplementation::getMainDefender() const{
	// server/zone/objects/tangible/TangibleObject.idl():  		return 
	if ((&defenderList)->size() > 0)	// server/zone/objects/tangible/TangibleObject.idl():  			return defenderList.get(0);
	return (&defenderList)->get(0);
	// server/zone/objects/tangible/TangibleObject.idl():  		return null;
	return NULL;
}

bool TangibleObjectImplementation::isDestroyed() const{
	// server/zone/objects/tangible/TangibleObject.idl():  		return conditionDamage >= maxCondition;
	return conditionDamage >= maxCondition;
}

void TangibleObjectImplementation::setFaction(unsigned int crc) {
	// server/zone/objects/tangible/TangibleObject.idl():  		faction = crc;
	faction = crc;
	// server/zone/objects/tangible/TangibleObject.idl():  		notifyObservers(ObserverEventType.FACTIONCHANGED);
	notifyObservers(ObserverEventType::FACTIONCHANGED);
}

unsigned int TangibleObjectImplementation::getFaction() const{
	// server/zone/objects/tangible/TangibleObject.idl():  		return faction;
	return faction;
}

int TangibleObjectImplementation::getFactionStatus() const{
	// server/zone/objects/tangible/TangibleObject.idl():  		return factionStatus;
	return factionStatus;
}

int TangibleObjectImplementation::getFutureFactionStatus() const{
	// server/zone/objects/tangible/TangibleObject.idl():  		return futureFactionStatus;
	return futureFactionStatus;
}

bool TangibleObjectImplementation::isSliceable() {
	// server/zone/objects/tangible/TangibleObject.idl():  		return 
	if (sliced)	// server/zone/objects/tangible/TangibleObject.idl():  			return false;
	return false;

	else 	// server/zone/objects/tangible/TangibleObject.idl():  		return 
	if (isContainerObject())	// server/zone/objects/tangible/TangibleObject.idl():  			return sliceable;
	return sliceable;

	else 	// server/zone/objects/tangible/TangibleObject.idl():  		return 
	if (isMissionTerminal())	// server/zone/objects/tangible/TangibleObject.idl():  			return sliceable;
	return sliceable;

	else 	// server/zone/objects/tangible/TangibleObject.idl():  		return 
	if (isWeaponObject())	// server/zone/objects/tangible/TangibleObject.idl():  			return sliceable;
	return sliceable;

	else 	// server/zone/objects/tangible/TangibleObject.idl():  		return 
	if (isArmorObject())	// server/zone/objects/tangible/TangibleObject.idl():  			return sliceable;
	return sliceable;

	else 	// server/zone/objects/tangible/TangibleObject.idl():  		return 
	if (SceneObjectImplementation::gameObjectType == SceneObjectType::PLAYERLOOTCRATE)	// server/zone/objects/tangible/TangibleObject.idl():  			return sliceable;
	return sliceable;

	else 	// server/zone/objects/tangible/TangibleObject.idl():  		return 
	if (isSecurityTerminal())	// server/zone/objects/tangible/TangibleObject.idl():  			return sliceable;
	return sliceable;
	// server/zone/objects/tangible/TangibleObject.idl():  		return false;
	return false;
}

bool TangibleObjectImplementation::isSliced() const{
	// server/zone/objects/tangible/TangibleObject.idl():  		return sliced;
	return sliced;
}

void TangibleObjectImplementation::setSliceable(bool val) {
	// server/zone/objects/tangible/TangibleObject.idl():  		sliceable = val;
	sliceable = val;
}

void TangibleObjectImplementation::setSliced(bool slice) {
	// server/zone/objects/tangible/TangibleObject.idl():  		sliced = slice;
	sliced = slice;
}

bool TangibleObjectImplementation::isJediRobe() const{
	// server/zone/objects/tangible/TangibleObject.idl():  		return jediRobe;
	return jediRobe;
}

bool TangibleObjectImplementation::isUnionRing() const{
	// server/zone/objects/tangible/TangibleObject.idl():  		return unionRing;
	return unionRing;
}

void TangibleObjectImplementation::setUnionRing(bool val) {
	// server/zone/objects/tangible/TangibleObject.idl():  		unionRing = val;
	unionRing = val;
}

void TangibleObjectImplementation::setCustomizationString(const String& vars) {
	// server/zone/objects/tangible/TangibleObject.idl():  		customizationVariables.parseFromClientString(vars);
	(&customizationVariables)->parseFromClientString(vars);
}

void TangibleObjectImplementation::setCraftersName(String& name) {
	// server/zone/objects/tangible/TangibleObject.idl():  		craftersName = name;
	craftersName = name;
}

void TangibleObjectImplementation::setCraftersID(unsigned long long crafterOID) {
	// server/zone/objects/tangible/TangibleObject.idl():  		craftersID = crafterOID;
	craftersID = crafterOID;
}

String TangibleObjectImplementation::getCraftersName() {
	// server/zone/objects/tangible/TangibleObject.idl():  		return craftersName;
	return craftersName;
}

unsigned long long TangibleObjectImplementation::getCraftersID() const{
	// server/zone/objects/tangible/TangibleObject.idl():  		return craftersID;
	return craftersID;
}

void TangibleObjectImplementation::setJunkDealerNeeded(int jdNeeded) {
	// server/zone/objects/tangible/TangibleObject.idl():  		junkDealerNeeded = jdNeeded;
	junkDealerNeeded = jdNeeded;
}

int TangibleObjectImplementation::getJunkDealerNeeded() {
	// server/zone/objects/tangible/TangibleObject.idl():  		return junkDealerNeeded;
	return junkDealerNeeded;
}

void TangibleObjectImplementation::setJunkValue(int jValue) {
	// server/zone/objects/tangible/TangibleObject.idl():  		junkValue = jValue;
	junkValue = jValue;
}

int TangibleObjectImplementation::getJunkValue() const{
	// server/zone/objects/tangible/TangibleObject.idl():  		return junkValue;
	return junkValue;
}

void TangibleObjectImplementation::setLevel(int lev, bool randomHam) {
	// server/zone/objects/tangible/TangibleObject.idl():  		level = lev;
	level = lev;
}

String TangibleObjectImplementation::getSerialNumber() {
	// server/zone/objects/tangible/TangibleObject.idl():  		return objectSerial;
	return objectSerial;
}

String TangibleObjectImplementation::repairAttempt(int repairChance) {
	// server/zone/objects/tangible/TangibleObject.idl():  		return "Repairing is not implemented for this item";
	return "Repairing is not implemented for this item";
}

bool TangibleObjectImplementation::isBroken() const{
	// server/zone/objects/tangible/TangibleObject.idl():  		return maxCondition < 2 || getConditionDamage() >= getMaxCondition();
	return maxCondition < 2 || getConditionDamage() >= getMaxCondition();
}

float TangibleObjectImplementation::getConditionReduction(float value) const{
	// server/zone/objects/tangible/TangibleObject.idl():  		float 
	if (isBroken())	// server/zone/objects/tangible/TangibleObject.idl():  			return 0.5 * value;
	return 0.5 * value;
	// server/zone/objects/tangible/TangibleObject.idl():  		float ratio = (float)getConditionDamage() / (float)getMaxCondition() * 100.0;
	float ratio = (float) getConditionDamage() / (float) getMaxCondition() * 100.0;
	// server/zone/objects/tangible/TangibleObject.idl():  		float 
	if (ratio < 75.0)	// server/zone/objects/tangible/TangibleObject.idl():  			return 0;
	return 0;
	// server/zone/objects/tangible/TangibleObject.idl():  		float reductionPercent = (ratio - 75.0) / 50;
	float reductionPercent = (ratio - 75.0) / 50;
	// server/zone/objects/tangible/TangibleObject.idl():  		return reductionPercent * value;
	return reductionPercent * value;
}

float TangibleObjectImplementation::getHitChance() const{
	// server/zone/objects/tangible/TangibleObject.idl():  		return 0;
	return 0;
}

void TangibleObjectImplementation::dropActiveArea(ActiveArea* area) {
	// server/zone/objects/tangible/TangibleObject.idl():  		synchronized 
	if (area->isNoCombatArea()){
	// server/zone/objects/tangible/TangibleObject.idl():  			inNoCombatArea = false;
	inNoCombatArea = false;
	// server/zone/objects/tangible/TangibleObject.idl():  			broadcastPvpStatusBitmask();
	broadcastPvpStatusBitmask();
}
	// server/zone/objects/tangible/TangibleObject.idl():  		}
{
	Locker _locker(SceneObjectImplementation::getContainerLock());
	// server/zone/objects/tangible/TangibleObject.idl():  			activeAreas.drop(area);
	(&activeAreas)->drop(area);
}
}

bool TangibleObjectImplementation::hasActiveArea(ActiveArea* area) {
	// server/zone/objects/tangible/TangibleObject.idl():  		}
{
	Locker _locker(SceneObjectImplementation::getContainerLock());
	// server/zone/objects/tangible/TangibleObject.idl():  			return activeAreas.contains(area);
	return (&activeAreas)->contains(area);
}
}

bool TangibleObjectImplementation::hasActiveArea(unsigned long long objectid) {
	// server/zone/objects/tangible/TangibleObject.idl():  		}
{
	Locker _locker(SceneObjectImplementation::getContainerLock());
	// server/zone/objects/tangible/TangibleObject.idl():  			}
	for (	// server/zone/objects/tangible/TangibleObject.idl():  			for (int i = 0;
	int i = 0;
	i < (&activeAreas)->size();
 ++i) {
	// server/zone/objects/tangible/TangibleObject.idl():  				ActiveArea area = activeAreas.get(i);
	ManagedReference<ActiveArea* > area = (&activeAreas)->get(i);
	// server/zone/objects/tangible/TangibleObject.idl():  			}
	if (area->getObjectID() == objectid){
	// server/zone/objects/tangible/TangibleObject.idl():  					return true;
	return true;
}
}
}
	// server/zone/objects/tangible/TangibleObject.idl():  		return false;
	return false;
}

bool TangibleObjectImplementation::isInNoCombatArea() const{
	// server/zone/objects/tangible/TangibleObject.idl():  		return inNoCombatArea;
	return inNoCombatArea;
}

void TangibleObjectImplementation::setInNoCombatArea(bool val) {
	// server/zone/objects/tangible/TangibleObject.idl():  		inNoCombatArea = val;
	inNoCombatArea = val;
}

SortedVector<ManagedReference<ActiveArea* > >* TangibleObjectImplementation::getActiveAreas() {
	// server/zone/objects/tangible/TangibleObject.idl():  		return activeAreas;
	return (&activeAreas);
}

int TangibleObjectImplementation::getActiveAreasSize() const{
	// server/zone/objects/tangible/TangibleObject.idl():  		return activeAreas.size();
	return (&activeAreas)->size();
}

Reference<ActiveArea* > TangibleObjectImplementation::getActiveRegion() {
	// server/zone/objects/tangible/TangibleObject.idl():  		}
{
	Locker _locker(SceneObjectImplementation::getContainerLock());
	// server/zone/objects/tangible/TangibleObject.idl():  			}
	for (	// server/zone/objects/tangible/TangibleObject.idl():  			for (int i = 0;
	int i = 0;
	i < (&activeAreas)->size();
i ++) {
	// server/zone/objects/tangible/TangibleObject.idl():  				ActiveArea region = activeAreas.get(i);
	ManagedReference<ActiveArea* > region = (&activeAreas)->get(i);
	// server/zone/objects/tangible/TangibleObject.idl():  			}
	if (region->isRegion()){
	// server/zone/objects/tangible/TangibleObject.idl():  					return region;
	return region;
}
}
}
	// server/zone/objects/tangible/TangibleObject.idl():  		return null;
	return NULL;
}

bool TangibleObjectImplementation::isNoTrade() const{
	// server/zone/objects/tangible/TangibleObject.idl():  		return 
	if (antiDecayKitObject){
	// server/zone/objects/tangible/TangibleObject.idl():  			return antiDecayKitObject.isNoTrade() || super.isNoTrade();
	return antiDecayKitObject->isNoTrade() || SceneObjectImplementation::isNoTrade();
}
	// server/zone/objects/tangible/TangibleObject.idl():  		return super.isNoTrade();
	return SceneObjectImplementation::isNoTrade();
}

bool TangibleObjectImplementation::hasAntiDecayKit() const{
	// server/zone/objects/tangible/TangibleObject.idl():  		return antiDecayKitObject;
	return antiDecayKitObject;
}

unsigned long long TangibleObjectImplementation::getAntiDecayKitObjectID() const{
	// server/zone/objects/tangible/TangibleObject.idl():  		return 
	if (!hasAntiDecayKit()){
	// server/zone/objects/tangible/TangibleObject.idl():  		 return 0;
	return 0;
}
	// server/zone/objects/tangible/TangibleObject.idl():  		return antiDecayKitObject.getObjectID();
	return antiDecayKitObject->getObjectID();
}

void TangibleObjectImplementation::applyAntiDecayKit(CreatureObject* player, SceneObject* adk) {
	// server/zone/objects/tangible/TangibleObject.idl():  	}
	if (!hasAntiDecayKit()){
	// server/zone/objects/tangible/TangibleObject.idl():  			antiDecayKitObject = adk;
	antiDecayKitObject = adk;
	// server/zone/objects/tangible/TangibleObject.idl():  			SceneObject parent = adk.getParent();
	ManagedReference<SceneObject* > parent = adk->getParent();
	// server/zone/objects/tangible/TangibleObject.idl():  			sendAttributeListTo(
	if (parent)	// server/zone/objects/tangible/TangibleObject.idl():  				adk.destroyObjectFromWorld(true);
	adk->destroyObjectFromWorld(true);
	// server/zone/objects/tangible/TangibleObject.idl():  			sendAttributeListTo(player);
	sendAttributeListTo(player);
}
}

SceneObject* TangibleObjectImplementation::removeAntiDecayKit() {
	// server/zone/objects/tangible/TangibleObject.idl():  		return 
	if (hasAntiDecayKit()){
	// server/zone/objects/tangible/TangibleObject.idl():  			SceneObject adk = antiDecayKitObject;
	ManagedReference<SceneObject* > adk = antiDecayKitObject;
	// server/zone/objects/tangible/TangibleObject.idl():  			antiDecayKitObject = null;
	antiDecayKitObject = NULL;
	// server/zone/objects/tangible/TangibleObject.idl():  			return adk;
	return adk;
}
	// server/zone/objects/tangible/TangibleObject.idl():  		return null;
	return NULL;
}

bool TangibleObjectImplementation::isInvisible() const{
	// server/zone/objects/tangible/TangibleObject.idl():  		return invisible;
	return invisible;
}

void TangibleObjectImplementation::setInvisible(bool invis) {
	// server/zone/objects/tangible/TangibleObject.idl():  		invisible = invis;
	invisible = invis;
}

bool TangibleObjectImplementation::isCustomIngredient() {
	// server/zone/objects/tangible/TangibleObject.idl():  		return false;
	return false;
}

void TangibleObjectImplementation::setLuaStringData(const String& key, const String& data) {
	// server/zone/objects/tangible/TangibleObject.idl():  		luaStringData.put(key, data);
	(&luaStringData)->put(key, data);
}

void TangibleObjectImplementation::deleteLuaStringData(const String& key) {
	// server/zone/objects/tangible/TangibleObject.idl():  		luaStringData.drop(key);
	(&luaStringData)->drop(key);
}

String TangibleObjectImplementation::getLuaStringData(const String& key) const{
	// server/zone/objects/tangible/TangibleObject.idl():  		return luaStringData.get(key);
	return (&luaStringData)->get(key);
}

/*
 *	TangibleObjectAdapter
 */


#include "engine/orb/messages/InvokeMethodMessage.h"


TangibleObjectAdapter::TangibleObjectAdapter(TangibleObject* obj) : SceneObjectAdapter(obj) {
}

void TangibleObjectAdapter::invokeMethod(uint32 methid, DistributedMethod* inv) {
	DOBMessage* resp = inv->getInvocationMessage();

	switch (methid) {
	case RPC_INITIALIZEMEMBERS__:
		{
			
			initializeMembers();
			
		}
		break;
	case RPC_ADDTEMPLATESKILLMODS__TANGIBLEOBJECT_:
		{
			TangibleObject* targetObject = static_cast<TangibleObject*>(inv->getObjectParameter());
			
			addTemplateSkillMods(targetObject);
			
		}
		break;
	case RPC_APPLYSKILLMODSTO__CREATUREOBJECT_:
		{
			CreatureObject* creature = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			applySkillModsTo(creature);
			
		}
		break;
	case RPC_REMOVESKILLMODSFROM__CREATUREOBJECT_:
		{
			CreatureObject* creature = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			removeSkillModsFrom(creature);
			
		}
		break;
	case RPC_ADDSKILLMOD__INT_STRING_INT_BOOL_:
		{
			 int skillType = inv->getSignedIntParameter();
			 String skillMod; inv->getAsciiParameter(skillMod);
			int value = inv->getSignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			addSkillMod(skillType, skillMod, value, notifyClient);
			
		}
		break;
	case RPC_REMOVESKILLMOD__INT_STRING_INT_BOOL_:
		{
			 int skillType = inv->getSignedIntParameter();
			 String skillMod; inv->getAsciiParameter(skillMod);
			int value = inv->getSignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			removeSkillMod(skillType, skillMod, value, notifyClient);
			
		}
		break;
	case RPC_REMOVEALLSKILLMODSOFTYPE__INT_BOOL_:
		{
			 int skillType = inv->getSignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			removeAllSkillModsOfType(skillType, notifyClient);
			
		}
		break;
	case RPC_INITIALIZETRANSIENTMEMBERS__:
		{
			
			initializeTransientMembers();
			
		}
		break;
	case RPC_NOTIFYLOADFROMDATABASE__:
		{
			
			notifyLoadFromDatabase();
			
		}
		break;
	case RPC_SETCUSTOMOBJECTNAME__UNICODESTRING_BOOL_:
		{
			 UnicodeString name; inv->getUnicodeParameter(name);
			bool notifyClient = inv->getBooleanParameter();
			
			setCustomObjectName(name, notifyClient);
			
		}
		break;
	case RPC_SENDBASELINESTO__SCENEOBJECT_:
		{
			SceneObject* player = static_cast<SceneObject*>(inv->getObjectParameter());
			
			sendBaselinesTo(player);
			
		}
		break;
	case RPC_SENDTO__SCENEOBJECT_BOOL_BOOL_:
		{
			SceneObject* player = static_cast<SceneObject*>(inv->getObjectParameter());
			bool doClose = inv->getBooleanParameter();
			bool forceLoadContainer = inv->getBooleanParameter();
			
			sendTo(player, doClose, forceLoadContainer);
			
		}
		break;
	case RPC_SYNCHRONIZEDUILISTEN__CREATUREOBJECT_INT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			int value = inv->getSignedIntParameter();
			
			synchronizedUIListen(player, value);
			
		}
		break;
	case RPC_SYNCHRONIZEDUISTOPLISTEN__CREATUREOBJECT_INT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			int value = inv->getSignedIntParameter();
			
			synchronizedUIStopListen(player, value);
			
		}
		break;
	case RPC_SETDEFENDER__SCENEOBJECT_:
		{
			SceneObject* defender = static_cast<SceneObject*>(inv->getObjectParameter());
			
			setDefender(defender);
			
		}
		break;
	case RPC_ADDDEFENDER__SCENEOBJECT_:
		{
			SceneObject* defender = static_cast<SceneObject*>(inv->getObjectParameter());
			
			addDefender(defender);
			
		}
		break;
	case RPC_REMOVEDEFENDER__SCENEOBJECT_:
		{
			SceneObject* defender = static_cast<SceneObject*>(inv->getObjectParameter());
			
			removeDefender(defender);
			
		}
		break;
	case RPC_REMOVEDEFENDERS__:
		{
			
			removeDefenders();
			
		}
		break;
	case RPC_SETCOMBATSTATE__:
		{
			
			setCombatState();
			
		}
		break;
	case RPC_SETUSECOUNT__INT_BOOL_:
		{
			unsigned int newUseCount = inv->getUnsignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setUseCount(newUseCount, notifyClient);
			
		}
		break;
	case RPC_DECREASEUSECOUNT__INT_BOOL_:
		{
			unsigned int decrementAmount = inv->getUnsignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			decreaseUseCount(decrementAmount, notifyClient);
			
		}
		break;
	case RPC_SETCOUNTDOWNTIMER__INT_BOOL_:
		{
			unsigned int newCount = inv->getUnsignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setCountdownTimer(newCount, notifyClient);
			
		}
		break;
	case RPC_CLEARCOMBATSTATE__BOOL_:
		{
			bool clearDefenders = inv->getBooleanParameter();
			
			clearCombatState(clearDefenders);
			
		}
		break;
	case RPC_ISATTACKABLEBY__CREATUREOBJECT_:
		{
			CreatureObject* object = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			bool _m_res = isAttackableBy(object);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISATTACKABLEBY__TANGIBLEOBJECT_:
		{
			TangibleObject* object = static_cast<TangibleObject*>(inv->getObjectParameter());
			
			bool _m_res = isAttackableBy(object);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISAGGRESSIVETO__CREATUREOBJECT_:
		{
			CreatureObject* object = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			bool _m_res = isAggressiveTo(object);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISHEALABLEBY__CREATUREOBJECT_:
		{
			CreatureObject* object = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			bool _m_res = isHealableBy(object);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SENDPVPSTATUSTO__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			sendPvpStatusTo(player);
			
		}
		break;
	case RPC_INFLICTDAMAGE__TANGIBLEOBJECT_INT_FLOAT_BOOL_BOOL_BOOL_:
		{
			TangibleObject* attacker = static_cast<TangibleObject*>(inv->getObjectParameter());
			int damageType = inv->getSignedIntParameter();
			float damage = inv->getFloatParameter();
			bool destroy = inv->getBooleanParameter();
			bool notifyClient = inv->getBooleanParameter();
			bool isCombatAction = inv->getBooleanParameter();
			
			int _m_res = inflictDamage(attacker, damageType, damage, destroy, notifyClient, isCombatAction);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_INFLICTDAMAGE__TANGIBLEOBJECT_INT_FLOAT_BOOL_STRING_BOOL_BOOL_:
		{
			TangibleObject* attacker = static_cast<TangibleObject*>(inv->getObjectParameter());
			int damageType = inv->getSignedIntParameter();
			float damage = inv->getFloatParameter();
			bool destroy = inv->getBooleanParameter();
			 String xp; inv->getAsciiParameter(xp);
			bool notifyClient = inv->getBooleanParameter();
			bool isCombatAction = inv->getBooleanParameter();
			
			int _m_res = inflictDamage(attacker, damageType, damage, destroy, xp, notifyClient, isCombatAction);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_HEALDAMAGE__TANGIBLEOBJECT_INT_FLOAT_BOOL_:
		{
			TangibleObject* healer = static_cast<TangibleObject*>(inv->getObjectParameter());
			int damageType = inv->getSignedIntParameter();
			float damageToHeal = inv->getFloatParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			int _m_res = healDamage(healer, damageType, damageToHeal, notifyClient);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_SETCONDITIONDAMAGE__FLOAT_BOOL_:
		{
			float condDamage = inv->getFloatParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setConditionDamage(condDamage, notifyClient);
			
		}
		break;
	case RPC_ADDVISIBLECOMPONENT__INT_BOOL_:
		{
			int value = inv->getSignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			addVisibleComponent(value, notifyClient);
			
		}
		break;
	case RPC_REMOVEVISIBLECOMPONENT__INT_BOOL_:
		{
			int value = inv->getSignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			removeVisibleComponent(value, notifyClient);
			
		}
		break;
	case RPC_REMOVEALLVISIBLECOMPONENTS__BOOL_:
		{
			bool notifyClient = inv->getBooleanParameter();
			
			removeAllVisibleComponents(notifyClient);
			
		}
		break;
	case RPC_HASVISIBLECOMPONENT__INT_:
		{
			int value = inv->getSignedIntParameter();
			
			bool _m_res = hasVisibleComponent(value);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETCUSTOMIZATIONVARIABLE__BYTE_SHORT_BOOL_:
		{
			byte type = inv->getByteParameter();
			short value = inv->getSignedShortParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setCustomizationVariable(type, value, notifyClient);
			
		}
		break;
	case RPC_SETCUSTOMIZATIONVARIABLE__STRING_SHORT_BOOL_:
		{
			 String type; inv->getAsciiParameter(type);
			short value = inv->getSignedShortParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setCustomizationVariable(type, value, notifyClient);
			
		}
		break;
	case RPC_SETOPTIONSBITMASK__INT_BOOL_:
		{
			unsigned int bitmask = inv->getUnsignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setOptionsBitmask(bitmask, notifyClient);
			
		}
		break;
	case RPC_SETOPTIONBIT__INT_BOOL_:
		{
			unsigned int option = inv->getUnsignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setOptionBit(option, notifyClient);
			
		}
		break;
	case RPC_CLEAROPTIONBIT__INT_BOOL_:
		{
			unsigned int option = inv->getUnsignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			clearOptionBit(option, notifyClient);
			
		}
		break;
	case RPC_NOTIFYOBJECTDESTRUCTIONOBSERVERS__TANGIBLEOBJECT_INT_BOOL_:
		{
			TangibleObject* attacker = static_cast<TangibleObject*>(inv->getObjectParameter());
			int condition = inv->getSignedIntParameter();
			bool isCombatAction = inv->getBooleanParameter();
			
			int _m_res = notifyObjectDestructionObservers(attacker, condition, isCombatAction);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_DROPFROMDEFENDERLISTS__:
		{
			
			dropFromDefenderLists();
			
		}
		break;
	case RPC_GETOBJECTVISIBLE__:
		{
			
			byte _m_res = getObjectVisible();
			resp->insertByte(_m_res);
		}
		break;
	case RPC_ISKILLER__:
		{
			
			bool _m_res = isKiller();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISTICKETCOLLECTOR__:
		{
			
			bool _m_res = isTicketCollector();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISTICKETOBJECT__:
		{
			
			bool _m_res = isTicketObject();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISFSPUZZLEPACK__:
		{
			
			bool _m_res = isFsPuzzlePack();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISPLANTOBJECT__:
		{
			
			bool _m_res = isPlantObject();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISCONSUMABLE__:
		{
			
			bool _m_res = isConsumable();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETUSECOUNT__:
		{
			
			int _m_res = getUseCount();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETMAXCONDITION__:
		{
			
			int _m_res = getMaxCondition();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_SETMAXCONDITION__INT_BOOL_:
		{
			int maxCond = inv->getSignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setMaxCondition(maxCond, notifyClient);
			
		}
		break;
	case RPC_GETCONDITIONDAMAGE__:
		{
			
			int _m_res = getConditionDamage();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETUNMITIGATEDDAMAGE__:
		{
			
			int _m_res = getUnmitigatedDamage();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_ADDUNMITIGATEDDAMAGE__FLOAT_:
		{
			float damage = inv->getFloatParameter();
			
			addUnmitigatedDamage(damage);
			
		}
		break;
	case RPC_GETVOLUME__:
		{
			
			int _m_res = getVolume();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_SETCOMPLEXITY__FLOAT_:
		{
			float value = inv->getFloatParameter();
			
			setComplexity(value);
			
		}
		break;
	case RPC_GETCOMPLEXITY__:
		{
			
			float _m_res = getComplexity();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETOPTIONSBITMASK__:
		{
			
			unsigned int _m_res = getOptionsBitmask();
			resp->insertInt(_m_res);
		}
		break;
	case RPC_ADDMAGICBIT__BOOL_:
		{
			bool notifyClient = inv->getBooleanParameter();
			
			addMagicBit(notifyClient);
			
		}
		break;
	case RPC_REMOVEMAGICBIT__BOOL_:
		{
			bool notifyClient = inv->getBooleanParameter();
			
			removeMagicBit(notifyClient);
			
		}
		break;
	case RPC_GETLEVEL__:
		{
			
			int _m_res = getLevel();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETISCRAFTEDENHANCEDITEM__:
		{
			
			bool _m_res = getIsCraftedEnhancedItem();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETPVPSTATUSBITMASK__:
		{
			
			unsigned int _m_res = getPvpStatusBitmask();
			resp->insertInt(_m_res);
		}
		break;
	case RPC_ISTANGIBLEOBJECT__:
		{
			
			bool _m_res = isTangibleObject();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETCUSTOMIZATIONSTRING__STRING_:
		{
			String variables; inv->getAsciiParameter(variables);
			
			getCustomizationString(variables);
			
		}
		break;
	case RPC_GETMAINDEFENDER__:
		{
			
			DistributedObject* _m_res = getMainDefender();
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_ISDESTROYED__:
		{
			
			bool _m_res = isDestroyed();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETFACTION__INT_:
		{
			unsigned int crc = inv->getUnsignedIntParameter();
			
			setFaction(crc);
			
		}
		break;
	case RPC_GETFACTION__:
		{
			
			unsigned int _m_res = getFaction();
			resp->insertInt(_m_res);
		}
		break;
	case RPC_ISREBEL__:
		{
			
			bool _m_res = isRebel();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISIMPERIAL__:
		{
			
			bool _m_res = isImperial();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISNEUTRAL__:
		{
			
			bool _m_res = isNeutral();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETFACTIONSTATUS__:
		{
			
			int _m_res = getFactionStatus();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_SETFACTIONSTATUS__INT_:
		{
			int status = inv->getSignedIntParameter();
			
			setFactionStatus(status);
			
		}
		break;
	case RPC_GETFUTUREFACTIONSTATUS__:
		{
			
			int _m_res = getFutureFactionStatus();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_SETFUTUREFACTIONSTATUS__INT_:
		{
			int status = inv->getSignedIntParameter();
			
			setFutureFactionStatus(status);
			
		}
		break;
	case RPC_ISSLICEABLE__:
		{
			
			bool _m_res = isSliceable();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISSLICED__:
		{
			
			bool _m_res = isSliced();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETSLICEABLE__BOOL_:
		{
			bool val = inv->getBooleanParameter();
			
			setSliceable(val);
			
		}
		break;
	case RPC_SETSLICED__BOOL_:
		{
			bool slice = inv->getBooleanParameter();
			
			setSliced(slice);
			
		}
		break;
	case RPC_ISJEDIROBE__:
		{
			
			bool _m_res = isJediRobe();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISUNIONRING__:
		{
			
			bool _m_res = isUnionRing();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETUNIONRING__BOOL_:
		{
			bool val = inv->getBooleanParameter();
			
			setUnionRing(val);
			
		}
		break;
	case RPC_SETCUSTOMIZATIONSTRING__STRING_:
		{
			 String vars; inv->getAsciiParameter(vars);
			
			setCustomizationString(vars);
			
		}
		break;
	case RPC_SETISCRAFTEDENHANCEDITEM__BOOL_:
		{
			bool value = inv->getBooleanParameter();
			
			setIsCraftedEnhancedItem(value);
			
		}
		break;
	case RPC_SETPVPSTATUSBITMASK__INT_BOOL_:
		{
			unsigned int bitmask = inv->getUnsignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setPvpStatusBitmask(bitmask, notifyClient);
			
		}
		break;
	case RPC_SETPVPSTATUSBIT__INT_BOOL_:
		{
			unsigned int pvpStatus = inv->getUnsignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setPvpStatusBit(pvpStatus, notifyClient);
			
		}
		break;
	case RPC_CLEARPVPSTATUSBIT__INT_BOOL_:
		{
			unsigned int pvpStatus = inv->getUnsignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			clearPvpStatusBit(pvpStatus, notifyClient);
			
		}
		break;
	case RPC_SETCRAFTERSNAME__STRING_:
		{
			String name; inv->getAsciiParameter(name);
			
			setCraftersName(name);
			
		}
		break;
	case RPC_SETCRAFTERSID__LONG_:
		{
			unsigned long long crafterOID = inv->getUnsignedLongParameter();
			
			setCraftersID(crafterOID);
			
		}
		break;
	case RPC_GETCRAFTERSNAME__:
		{
			
			String _m_res = getCraftersName();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_GETCRAFTERSID__:
		{
			
			unsigned long long _m_res = getCraftersID();
			resp->insertLong(_m_res);
		}
		break;
	case RPC_SETJUNKDEALERNEEDED__INT_:
		{
			int jdNeeded = inv->getSignedIntParameter();
			
			setJunkDealerNeeded(jdNeeded);
			
		}
		break;
	case RPC_GETJUNKDEALERNEEDED__:
		{
			
			int _m_res = getJunkDealerNeeded();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_SETJUNKVALUE__INT_:
		{
			int jValue = inv->getSignedIntParameter();
			
			setJunkValue(jValue);
			
		}
		break;
	case RPC_GETJUNKVALUE__:
		{
			
			int _m_res = getJunkValue();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_SETSERIALNUMBER__STRING_:
		{
			 String serial; inv->getAsciiParameter(serial);
			
			setSerialNumber(serial);
			
		}
		break;
	case RPC_SETLEVEL__INT_BOOL_:
		{
			int lev = inv->getSignedIntParameter();
			bool randomHam = inv->getBooleanParameter();
			
			setLevel(lev, randomHam);
			
		}
		break;
	case RPC_GETSERIALNUMBER__:
		{
			
			String _m_res = getSerialNumber();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_CREATEFACTORYCRATE__INT_STRING_BOOL_:
		{
			int maxSize = inv->getSignedIntParameter();
			String type; inv->getAsciiParameter(type);
			bool insertSelf = inv->getBooleanParameter();
			
			DistributedObject* _m_res = createFactoryCrate(maxSize, type, insertSelf);
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_CANREPAIR__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			bool _m_res = canRepair(player);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_REPAIR__CREATUREOBJECT_REPAIRTOOL_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			RepairTool* repairTool = static_cast<RepairTool*>(inv->getObjectParameter());
			
			repair(player, repairTool);
			
		}
		break;
	case RPC_REPAIRATTEMPT__INT_:
		{
			int repairChance = inv->getSignedIntParameter();
			
			String _m_res = repairAttempt(repairChance);
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_ISBROKEN__:
		{
			
			bool _m_res = isBroken();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETHITCHANCE__:
		{
			
			float _m_res = getHitChance();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_BROADCASTPVPSTATUSBITMASK__:
		{
			
			broadcastPvpStatusBitmask();
			
		}
		break;
	case RPC_ADDACTIVEAREA__ACTIVEAREA_:
		{
			ActiveArea* area = static_cast<ActiveArea*>(inv->getObjectParameter());
			
			addActiveArea(area);
			
		}
		break;
	case RPC_DROPACTIVEAREA__ACTIVEAREA_:
		{
			ActiveArea* area = static_cast<ActiveArea*>(inv->getObjectParameter());
			
			dropActiveArea(area);
			
		}
		break;
	case RPC_HASACTIVEAREA__ACTIVEAREA_:
		{
			ActiveArea* area = static_cast<ActiveArea*>(inv->getObjectParameter());
			
			bool _m_res = hasActiveArea(area);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_HASACTIVEAREA__LONG_:
		{
			unsigned long long objectid = inv->getUnsignedLongParameter();
			
			bool _m_res = hasActiveArea(objectid);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISINNOCOMBATAREA__:
		{
			
			bool _m_res = isInNoCombatArea();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETINNOCOMBATAREA__BOOL_:
		{
			bool val = inv->getBooleanParameter();
			
			setInNoCombatArea(val);
			
		}
		break;
	case RPC_GETACTIVEAREASSIZE__:
		{
			
			int _m_res = getActiveAreasSize();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETACTIVEREGION__:
		{
			
			DistributedObject* _m_res = getActiveRegion();
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_ISNOTRADE__:
		{
			
			bool _m_res = isNoTrade();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_HASANTIDECAYKIT__:
		{
			
			bool _m_res = hasAntiDecayKit();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETANTIDECAYKITOBJECTID__:
		{
			
			unsigned long long _m_res = getAntiDecayKitObjectID();
			resp->insertLong(_m_res);
		}
		break;
	case RPC_APPLYANTIDECAYKIT__CREATUREOBJECT_SCENEOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			SceneObject* adk = static_cast<SceneObject*>(inv->getObjectParameter());
			
			applyAntiDecayKit(player, adk);
			
		}
		break;
	case RPC_REMOVEANTIDECAYKIT__:
		{
			
			DistributedObject* _m_res = removeAntiDecayKit();
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_DESTROYOBJECTFROMDATABASE__BOOL_:
		{
			bool destroyContainedObjects = inv->getBooleanParameter();
			
			destroyObjectFromDatabase(destroyContainedObjects);
			
		}
		break;
	case RPC_ISCITYSTREETLAMP__:
		{
			
			bool _m_res = isCityStreetLamp();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISCITYSTATUE__:
		{
			
			bool _m_res = isCityStatue();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISCITYFOUNTAIN__:
		{
			
			bool _m_res = isCityFountain();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISINVISIBLE__:
		{
			
			bool _m_res = isInvisible();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETINVISIBLE__BOOL_:
		{
			bool invis = inv->getBooleanParameter();
			
			setInvisible(invis);
			
		}
		break;
	case RPC_ISCUSTOMINGREDIENT__:
		{
			
			bool _m_res = isCustomIngredient();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETLUASTRINGDATA__STRING_STRING_:
		{
			 String key; inv->getAsciiParameter(key);
			 String data; inv->getAsciiParameter(data);
			
			setLuaStringData(key, data);
			
		}
		break;
	case RPC_DELETELUASTRINGDATA__STRING_:
		{
			 String key; inv->getAsciiParameter(key);
			
			deleteLuaStringData(key);
			
		}
		break;
	case RPC_GETLUASTRINGDATA__STRING_:
		{
			 String key; inv->getAsciiParameter(key);
			
			String _m_res = getLuaStringData(key);
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_SETDISABLED__BOOL_:
		{
			bool disabled = inv->getBooleanParameter();
			
			setDisabled(disabled);
			
		}
		break;
	case RPC_ISDISABLED__:
		{
			
			bool _m_res = isDisabled();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISINNAVMESH__:
		{
			
			bool _m_res = isInNavMesh();
			resp->insertBoolean(_m_res);
		}
		break;
	default:
		SceneObjectAdapter::invokeMethod(methid, inv);
	}
}

void TangibleObjectAdapter::initializeMembers() {
	(static_cast<TangibleObject*>(stub))->initializeMembers();
}

void TangibleObjectAdapter::addTemplateSkillMods(TangibleObject* targetObject) const {
	(static_cast<TangibleObject*>(stub))->addTemplateSkillMods(targetObject);
}

void TangibleObjectAdapter::applySkillModsTo(CreatureObject* creature) const {
	(static_cast<TangibleObject*>(stub))->applySkillModsTo(creature);
}

void TangibleObjectAdapter::removeSkillModsFrom(CreatureObject* creature) {
	(static_cast<TangibleObject*>(stub))->removeSkillModsFrom(creature);
}

void TangibleObjectAdapter::addSkillMod(const int skillType, const String& skillMod, int value, bool notifyClient) {
	(static_cast<TangibleObject*>(stub))->addSkillMod(skillType, skillMod, value, notifyClient);
}

void TangibleObjectAdapter::removeSkillMod(const int skillType, const String& skillMod, int value, bool notifyClient) {
	(static_cast<TangibleObject*>(stub))->removeSkillMod(skillType, skillMod, value, notifyClient);
}

void TangibleObjectAdapter::removeAllSkillModsOfType(const int skillType, bool notifyClient) {
	(static_cast<TangibleObject*>(stub))->removeAllSkillModsOfType(skillType, notifyClient);
}

void TangibleObjectAdapter::initializeTransientMembers() {
	(static_cast<TangibleObject*>(stub))->initializeTransientMembers();
}

void TangibleObjectAdapter::notifyLoadFromDatabase() {
	(static_cast<TangibleObject*>(stub))->notifyLoadFromDatabase();
}

void TangibleObjectAdapter::setCustomObjectName(const UnicodeString& name, bool notifyClient) {
	(static_cast<TangibleObject*>(stub))->setCustomObjectName(name, notifyClient);
}

void TangibleObjectAdapter::sendBaselinesTo(SceneObject* player) {
	(static_cast<TangibleObject*>(stub))->sendBaselinesTo(player);
}

void TangibleObjectAdapter::sendTo(SceneObject* player, bool doClose, bool forceLoadContainer) {
	(static_cast<TangibleObject*>(stub))->sendTo(player, doClose, forceLoadContainer);
}

void TangibleObjectAdapter::synchronizedUIListen(CreatureObject* player, int value) {
	(static_cast<TangibleObject*>(stub))->synchronizedUIListen(player, value);
}

void TangibleObjectAdapter::synchronizedUIStopListen(CreatureObject* player, int value) {
	(static_cast<TangibleObject*>(stub))->synchronizedUIStopListen(player, value);
}

void TangibleObjectAdapter::setDefender(SceneObject* defender) {
	(static_cast<TangibleObject*>(stub))->setDefender(defender);
}

void TangibleObjectAdapter::addDefender(SceneObject* defender) {
	(static_cast<TangibleObject*>(stub))->addDefender(defender);
}

void TangibleObjectAdapter::removeDefender(SceneObject* defender) {
	(static_cast<TangibleObject*>(stub))->removeDefender(defender);
}

void TangibleObjectAdapter::removeDefenders() {
	(static_cast<TangibleObject*>(stub))->removeDefenders();
}

void TangibleObjectAdapter::setCombatState() {
	(static_cast<TangibleObject*>(stub))->setCombatState();
}

void TangibleObjectAdapter::setUseCount(unsigned int newUseCount, bool notifyClient) {
	(static_cast<TangibleObject*>(stub))->setUseCount(newUseCount, notifyClient);
}

void TangibleObjectAdapter::decreaseUseCount(unsigned int decrementAmount, bool notifyClient) {
	(static_cast<TangibleObject*>(stub))->decreaseUseCount(decrementAmount, notifyClient);
}

void TangibleObjectAdapter::setCountdownTimer(unsigned int newCount, bool notifyClient) {
	(static_cast<TangibleObject*>(stub))->setCountdownTimer(newCount, notifyClient);
}

void TangibleObjectAdapter::clearCombatState(bool clearDefenders) {
	(static_cast<TangibleObject*>(stub))->clearCombatState(clearDefenders);
}

bool TangibleObjectAdapter::isAttackableBy(CreatureObject* object) {
	return (static_cast<TangibleObject*>(stub))->isAttackableBy(object);
}

bool TangibleObjectAdapter::isAttackableBy(TangibleObject* object) {
	return (static_cast<TangibleObject*>(stub))->isAttackableBy(object);
}

bool TangibleObjectAdapter::isAggressiveTo(CreatureObject* object) {
	return (static_cast<TangibleObject*>(stub))->isAggressiveTo(object);
}

bool TangibleObjectAdapter::isHealableBy(CreatureObject* object) {
	return (static_cast<TangibleObject*>(stub))->isHealableBy(object);
}

void TangibleObjectAdapter::sendPvpStatusTo(CreatureObject* player) {
	(static_cast<TangibleObject*>(stub))->sendPvpStatusTo(player);
}

int TangibleObjectAdapter::inflictDamage(TangibleObject* attacker, int damageType, float damage, bool destroy, bool notifyClient, bool isCombatAction) {
	return (static_cast<TangibleObject*>(stub))->inflictDamage(attacker, damageType, damage, destroy, notifyClient, isCombatAction);
}

int TangibleObjectAdapter::inflictDamage(TangibleObject* attacker, int damageType, float damage, bool destroy, const String& xp, bool notifyClient, bool isCombatAction) {
	return (static_cast<TangibleObject*>(stub))->inflictDamage(attacker, damageType, damage, destroy, xp, notifyClient, isCombatAction);
}

int TangibleObjectAdapter::healDamage(TangibleObject* healer, int damageType, float damageToHeal, bool notifyClient) {
	return (static_cast<TangibleObject*>(stub))->healDamage(healer, damageType, damageToHeal, notifyClient);
}

void TangibleObjectAdapter::setConditionDamage(float condDamage, bool notifyClient) {
	(static_cast<TangibleObject*>(stub))->setConditionDamage(condDamage, notifyClient);
}

void TangibleObjectAdapter::addVisibleComponent(int value, bool notifyClient) {
	(static_cast<TangibleObject*>(stub))->addVisibleComponent(value, notifyClient);
}

void TangibleObjectAdapter::removeVisibleComponent(int value, bool notifyClient) {
	(static_cast<TangibleObject*>(stub))->removeVisibleComponent(value, notifyClient);
}

void TangibleObjectAdapter::removeAllVisibleComponents(bool notifyClient) {
	(static_cast<TangibleObject*>(stub))->removeAllVisibleComponents(notifyClient);
}

bool TangibleObjectAdapter::hasVisibleComponent(int value) const {
	return (static_cast<TangibleObject*>(stub))->hasVisibleComponent(value);
}

void TangibleObjectAdapter::setCustomizationVariable(byte type, short value, bool notifyClient) {
	(static_cast<TangibleObject*>(stub))->setCustomizationVariable(type, value, notifyClient);
}

void TangibleObjectAdapter::setCustomizationVariable(const String& type, short value, bool notifyClient) {
	(static_cast<TangibleObject*>(stub))->setCustomizationVariable(type, value, notifyClient);
}

void TangibleObjectAdapter::setOptionsBitmask(unsigned int bitmask, bool notifyClient) {
	(static_cast<TangibleObject*>(stub))->setOptionsBitmask(bitmask, notifyClient);
}

void TangibleObjectAdapter::setOptionBit(unsigned int option, bool notifyClient) {
	(static_cast<TangibleObject*>(stub))->setOptionBit(option, notifyClient);
}

void TangibleObjectAdapter::clearOptionBit(unsigned int option, bool notifyClient) {
	(static_cast<TangibleObject*>(stub))->clearOptionBit(option, notifyClient);
}

int TangibleObjectAdapter::notifyObjectDestructionObservers(TangibleObject* attacker, int condition, bool isCombatAction) {
	return (static_cast<TangibleObject*>(stub))->notifyObjectDestructionObservers(attacker, condition, isCombatAction);
}

void TangibleObjectAdapter::dropFromDefenderLists() {
	(static_cast<TangibleObject*>(stub))->dropFromDefenderLists();
}

byte TangibleObjectAdapter::getObjectVisible() const {
	return (static_cast<TangibleObject*>(stub))->getObjectVisible();
}

bool TangibleObjectAdapter::isKiller() {
	return (static_cast<TangibleObject*>(stub))->isKiller();
}

bool TangibleObjectAdapter::isTicketCollector() {
	return (static_cast<TangibleObject*>(stub))->isTicketCollector();
}

bool TangibleObjectAdapter::isTicketObject() {
	return (static_cast<TangibleObject*>(stub))->isTicketObject();
}

bool TangibleObjectAdapter::isFsPuzzlePack() {
	return (static_cast<TangibleObject*>(stub))->isFsPuzzlePack();
}

bool TangibleObjectAdapter::isPlantObject() {
	return (static_cast<TangibleObject*>(stub))->isPlantObject();
}

bool TangibleObjectAdapter::isConsumable() {
	return (static_cast<TangibleObject*>(stub))->isConsumable();
}

int TangibleObjectAdapter::getUseCount() const {
	return (static_cast<TangibleObject*>(stub))->getUseCount();
}

int TangibleObjectAdapter::getMaxCondition() const {
	return (static_cast<TangibleObject*>(stub))->getMaxCondition();
}

void TangibleObjectAdapter::setMaxCondition(int maxCond, bool notifyClient) {
	(static_cast<TangibleObject*>(stub))->setMaxCondition(maxCond, notifyClient);
}

int TangibleObjectAdapter::getConditionDamage() const {
	return (static_cast<TangibleObject*>(stub))->getConditionDamage();
}

int TangibleObjectAdapter::getUnmitigatedDamage() const {
	return (static_cast<TangibleObject*>(stub))->getUnmitigatedDamage();
}

void TangibleObjectAdapter::addUnmitigatedDamage(float damage) {
	(static_cast<TangibleObject*>(stub))->addUnmitigatedDamage(damage);
}

int TangibleObjectAdapter::getVolume() const {
	return (static_cast<TangibleObject*>(stub))->getVolume();
}

void TangibleObjectAdapter::setComplexity(float value) {
	(static_cast<TangibleObject*>(stub))->setComplexity(value);
}

float TangibleObjectAdapter::getComplexity() const {
	return (static_cast<TangibleObject*>(stub))->getComplexity();
}

unsigned int TangibleObjectAdapter::getOptionsBitmask() const {
	return (static_cast<TangibleObject*>(stub))->getOptionsBitmask();
}

void TangibleObjectAdapter::addMagicBit(bool notifyClient) {
	(static_cast<TangibleObject*>(stub))->addMagicBit(notifyClient);
}

void TangibleObjectAdapter::removeMagicBit(bool notifyClient) {
	(static_cast<TangibleObject*>(stub))->removeMagicBit(notifyClient);
}

int TangibleObjectAdapter::getLevel() const {
	return (static_cast<TangibleObject*>(stub))->getLevel();
}

bool TangibleObjectAdapter::getIsCraftedEnhancedItem() const {
	return (static_cast<TangibleObject*>(stub))->getIsCraftedEnhancedItem();
}

unsigned int TangibleObjectAdapter::getPvpStatusBitmask() const {
	return (static_cast<TangibleObject*>(stub))->getPvpStatusBitmask();
}

bool TangibleObjectAdapter::isTangibleObject() {
	return (static_cast<TangibleObject*>(stub))->isTangibleObject();
}

void TangibleObjectAdapter::getCustomizationString(String& variables) const {
	(static_cast<TangibleObject*>(stub))->getCustomizationString(variables);
}

SceneObject* TangibleObjectAdapter::getMainDefender() const {
	return (static_cast<TangibleObject*>(stub))->getMainDefender();
}

bool TangibleObjectAdapter::isDestroyed() const {
	return (static_cast<TangibleObject*>(stub))->isDestroyed();
}

void TangibleObjectAdapter::setFaction(unsigned int crc) {
	(static_cast<TangibleObject*>(stub))->setFaction(crc);
}

unsigned int TangibleObjectAdapter::getFaction() const {
	return (static_cast<TangibleObject*>(stub))->getFaction();
}

bool TangibleObjectAdapter::isRebel() const {
	return (static_cast<TangibleObject*>(stub))->isRebel();
}

bool TangibleObjectAdapter::isImperial() const {
	return (static_cast<TangibleObject*>(stub))->isImperial();
}

bool TangibleObjectAdapter::isNeutral() const {
	return (static_cast<TangibleObject*>(stub))->isNeutral();
}

int TangibleObjectAdapter::getFactionStatus() const {
	return (static_cast<TangibleObject*>(stub))->getFactionStatus();
}

void TangibleObjectAdapter::setFactionStatus(int status) {
	(static_cast<TangibleObject*>(stub))->setFactionStatus(status);
}

int TangibleObjectAdapter::getFutureFactionStatus() const {
	return (static_cast<TangibleObject*>(stub))->getFutureFactionStatus();
}

void TangibleObjectAdapter::setFutureFactionStatus(int status) {
	(static_cast<TangibleObject*>(stub))->setFutureFactionStatus(status);
}

bool TangibleObjectAdapter::isSliceable() {
	return (static_cast<TangibleObject*>(stub))->isSliceable();
}

bool TangibleObjectAdapter::isSliced() const {
	return (static_cast<TangibleObject*>(stub))->isSliced();
}

void TangibleObjectAdapter::setSliceable(bool val) {
	(static_cast<TangibleObject*>(stub))->setSliceable(val);
}

void TangibleObjectAdapter::setSliced(bool slice) {
	(static_cast<TangibleObject*>(stub))->setSliced(slice);
}

bool TangibleObjectAdapter::isJediRobe() const {
	return (static_cast<TangibleObject*>(stub))->isJediRobe();
}

bool TangibleObjectAdapter::isUnionRing() const {
	return (static_cast<TangibleObject*>(stub))->isUnionRing();
}

void TangibleObjectAdapter::setUnionRing(bool val) {
	(static_cast<TangibleObject*>(stub))->setUnionRing(val);
}

void TangibleObjectAdapter::setCustomizationString(const String& vars) {
	(static_cast<TangibleObject*>(stub))->setCustomizationString(vars);
}

void TangibleObjectAdapter::setIsCraftedEnhancedItem(bool value) {
	(static_cast<TangibleObject*>(stub))->setIsCraftedEnhancedItem(value);
}

void TangibleObjectAdapter::setPvpStatusBitmask(unsigned int bitmask, bool notifyClient) {
	(static_cast<TangibleObject*>(stub))->setPvpStatusBitmask(bitmask, notifyClient);
}

void TangibleObjectAdapter::setPvpStatusBit(unsigned int pvpStatus, bool notifyClient) {
	(static_cast<TangibleObject*>(stub))->setPvpStatusBit(pvpStatus, notifyClient);
}

void TangibleObjectAdapter::clearPvpStatusBit(unsigned int pvpStatus, bool notifyClient) {
	(static_cast<TangibleObject*>(stub))->clearPvpStatusBit(pvpStatus, notifyClient);
}

void TangibleObjectAdapter::setCraftersName(String& name) {
	(static_cast<TangibleObject*>(stub))->setCraftersName(name);
}

void TangibleObjectAdapter::setCraftersID(unsigned long long crafterOID) {
	(static_cast<TangibleObject*>(stub))->setCraftersID(crafterOID);
}

String TangibleObjectAdapter::getCraftersName() {
	return (static_cast<TangibleObject*>(stub))->getCraftersName();
}

unsigned long long TangibleObjectAdapter::getCraftersID() const {
	return (static_cast<TangibleObject*>(stub))->getCraftersID();
}

void TangibleObjectAdapter::setJunkDealerNeeded(int jdNeeded) {
	(static_cast<TangibleObject*>(stub))->setJunkDealerNeeded(jdNeeded);
}

int TangibleObjectAdapter::getJunkDealerNeeded() {
	return (static_cast<TangibleObject*>(stub))->getJunkDealerNeeded();
}

void TangibleObjectAdapter::setJunkValue(int jValue) {
	(static_cast<TangibleObject*>(stub))->setJunkValue(jValue);
}

int TangibleObjectAdapter::getJunkValue() const {
	return (static_cast<TangibleObject*>(stub))->getJunkValue();
}

void TangibleObjectAdapter::setSerialNumber(const String& serial) {
	(static_cast<TangibleObject*>(stub))->setSerialNumber(serial);
}

void TangibleObjectAdapter::setLevel(int lev, bool randomHam) {
	(static_cast<TangibleObject*>(stub))->setLevel(lev, randomHam);
}

String TangibleObjectAdapter::getSerialNumber() {
	return (static_cast<TangibleObject*>(stub))->getSerialNumber();
}

Reference<FactoryCrate* > TangibleObjectAdapter::createFactoryCrate(int maxSize, String& type, bool insertSelf) {
	return (static_cast<TangibleObject*>(stub))->createFactoryCrate(maxSize, type, insertSelf);
}

bool TangibleObjectAdapter::canRepair(CreatureObject* player) {
	return (static_cast<TangibleObject*>(stub))->canRepair(player);
}

void TangibleObjectAdapter::repair(CreatureObject* player, RepairTool* repairTool) {
	(static_cast<TangibleObject*>(stub))->repair(player, repairTool);
}

String TangibleObjectAdapter::repairAttempt(int repairChance) {
	return (static_cast<TangibleObject*>(stub))->repairAttempt(repairChance);
}

bool TangibleObjectAdapter::isBroken() const {
	return (static_cast<TangibleObject*>(stub))->isBroken();
}

float TangibleObjectAdapter::getHitChance() const {
	return (static_cast<TangibleObject*>(stub))->getHitChance();
}

void TangibleObjectAdapter::broadcastPvpStatusBitmask() {
	(static_cast<TangibleObject*>(stub))->broadcastPvpStatusBitmask();
}

void TangibleObjectAdapter::addActiveArea(ActiveArea* area) {
	(static_cast<TangibleObject*>(stub))->addActiveArea(area);
}

void TangibleObjectAdapter::dropActiveArea(ActiveArea* area) {
	(static_cast<TangibleObject*>(stub))->dropActiveArea(area);
}

bool TangibleObjectAdapter::hasActiveArea(ActiveArea* area) {
	return (static_cast<TangibleObject*>(stub))->hasActiveArea(area);
}

bool TangibleObjectAdapter::hasActiveArea(unsigned long long objectid) {
	return (static_cast<TangibleObject*>(stub))->hasActiveArea(objectid);
}

bool TangibleObjectAdapter::isInNoCombatArea() const {
	return (static_cast<TangibleObject*>(stub))->isInNoCombatArea();
}

void TangibleObjectAdapter::setInNoCombatArea(bool val) {
	(static_cast<TangibleObject*>(stub))->setInNoCombatArea(val);
}

int TangibleObjectAdapter::getActiveAreasSize() const {
	return (static_cast<TangibleObject*>(stub))->getActiveAreasSize();
}

Reference<ActiveArea* > TangibleObjectAdapter::getActiveRegion() {
	return (static_cast<TangibleObject*>(stub))->getActiveRegion();
}

bool TangibleObjectAdapter::isNoTrade() const {
	return (static_cast<TangibleObject*>(stub))->isNoTrade();
}

bool TangibleObjectAdapter::hasAntiDecayKit() const {
	return (static_cast<TangibleObject*>(stub))->hasAntiDecayKit();
}

unsigned long long TangibleObjectAdapter::getAntiDecayKitObjectID() const {
	return (static_cast<TangibleObject*>(stub))->getAntiDecayKitObjectID();
}

void TangibleObjectAdapter::applyAntiDecayKit(CreatureObject* player, SceneObject* adk) {
	(static_cast<TangibleObject*>(stub))->applyAntiDecayKit(player, adk);
}

SceneObject* TangibleObjectAdapter::removeAntiDecayKit() {
	return (static_cast<TangibleObject*>(stub))->removeAntiDecayKit();
}

void TangibleObjectAdapter::destroyObjectFromDatabase(bool destroyContainedObjects) {
	(static_cast<TangibleObject*>(stub))->destroyObjectFromDatabase(destroyContainedObjects);
}

bool TangibleObjectAdapter::isCityStreetLamp() const {
	return (static_cast<TangibleObject*>(stub))->isCityStreetLamp();
}

bool TangibleObjectAdapter::isCityStatue() const {
	return (static_cast<TangibleObject*>(stub))->isCityStatue();
}

bool TangibleObjectAdapter::isCityFountain() const {
	return (static_cast<TangibleObject*>(stub))->isCityFountain();
}

bool TangibleObjectAdapter::isInvisible() const {
	return (static_cast<TangibleObject*>(stub))->isInvisible();
}

void TangibleObjectAdapter::setInvisible(bool invis) {
	(static_cast<TangibleObject*>(stub))->setInvisible(invis);
}

bool TangibleObjectAdapter::isCustomIngredient() {
	return (static_cast<TangibleObject*>(stub))->isCustomIngredient();
}

void TangibleObjectAdapter::setLuaStringData(const String& key, const String& data) {
	(static_cast<TangibleObject*>(stub))->setLuaStringData(key, data);
}

void TangibleObjectAdapter::deleteLuaStringData(const String& key) {
	(static_cast<TangibleObject*>(stub))->deleteLuaStringData(key);
}

String TangibleObjectAdapter::getLuaStringData(const String& key) const {
	return (static_cast<TangibleObject*>(stub))->getLuaStringData(key);
}

void TangibleObjectAdapter::setDisabled(bool disabled) {
	(static_cast<TangibleObject*>(stub))->setDisabled(disabled);
}

bool TangibleObjectAdapter::isDisabled() const {
	return (static_cast<TangibleObject*>(stub))->isDisabled();
}

bool TangibleObjectAdapter::isInNavMesh() {
	return (static_cast<TangibleObject*>(stub))->isInNavMesh();
}

/*
 *	TangibleObjectHelper
 */

TangibleObjectHelper* TangibleObjectHelper::staticInitializer = TangibleObjectHelper::instance();

TangibleObjectHelper::TangibleObjectHelper() {
	className = "TangibleObject";

	Core::getObjectBroker()->registerClass(className, this);
}

void TangibleObjectHelper::finalizeHelper() {
	TangibleObjectHelper::finalize();
}

DistributedObject* TangibleObjectHelper::instantiateObject() {
	return new TangibleObject(DummyConstructorParameter::instance());
}

DistributedObjectServant* TangibleObjectHelper::instantiateServant() {
	return new TangibleObjectImplementation();
}

DistributedObjectPOD* TangibleObjectHelper::instantiatePOD() {
	return new TangibleObjectPOD();
}

DistributedObjectAdapter* TangibleObjectHelper::createAdapter(DistributedObjectStub* obj) {
	DistributedObjectAdapter* adapter = new TangibleObjectAdapter(static_cast<TangibleObject*>(obj));

	obj->_setClassName(className);
	obj->_setClassHelper(this);

	adapter->setStub(obj);

	return adapter;
}

/*
 *	TangibleObjectPOD
 */

TangibleObjectPOD::~TangibleObjectPOD() {
	finalize();
}

TangibleObjectPOD::TangibleObjectPOD(void) {
	_className = "TangibleObject";
}


void TangibleObjectPOD::writeJSON(nlohmann::json& j) {
	SceneObjectPOD::writeJSON(j);

	nlohmann::json thisObject = nlohmann::json::object();
	if (targetable)
		thisObject["targetable"] = targetable.value();

	if (complexity)
		thisObject["complexity"] = complexity.value();

	if (volume)
		thisObject["volume"] = volume.value();

	if (faction)
		thisObject["faction"] = faction.value();

	if (factionStatus)
		thisObject["factionStatus"] = factionStatus.value();

	if (futureFactionStatus)
		thisObject["futureFactionStatus"] = futureFactionStatus.value();

	if (invisible)
		thisObject["invisible"] = invisible.value();

	if (luaStringData)
		thisObject["luaStringData"] = luaStringData.value();

	if (customizationVariables)
		thisObject["customizationVariables"] = customizationVariables.value();

	if (unmitigatedDamage)
		thisObject["unmitigatedDamage"] = unmitigatedDamage.value();

	if (conditionDamage)
		thisObject["conditionDamage"] = conditionDamage.value();

	if (maxCondition)
		thisObject["maxCondition"] = maxCondition.value();

	if (useCount)
		thisObject["useCount"] = useCount.value();

	if (level)
		thisObject["level"] = level.value();

	if (optionsBitmask)
		thisObject["optionsBitmask"] = optionsBitmask.value();

	if (magicBits)
		thisObject["magicBits"] = magicBits.value();

	if (visibleComponents)
		thisObject["visibleComponents"] = visibleComponents.value();

	if (isCraftedEnhancedItem)
		thisObject["isCraftedEnhancedItem"] = isCraftedEnhancedItem.value();

	if (pvpStatusBitmask)
		thisObject["pvpStatusBitmask"] = pvpStatusBitmask.value();

	if (objectVisible)
		thisObject["objectVisible"] = objectVisible.value();

	if (craftersName)
		thisObject["craftersName"] = craftersName.value();

	if (craftersID)
		thisObject["craftersID"] = craftersID.value();

	if (junkDealerNeeded)
		thisObject["junkDealerNeeded"] = junkDealerNeeded.value();

	if (junkValue)
		thisObject["junkValue"] = junkValue.value();

	if (objectSerial)
		thisObject["objectSerial"] = objectSerial.value();

	if (defenderList)
		thisObject["defenderList"] = defenderList.value();

	if (sliceable)
		thisObject["sliceable"] = sliceable.value();

	if (sliced)
		thisObject["sliced"] = sliced.value();

	if (activeAreas)
		thisObject["activeAreas"] = activeAreas.value();

	if (antiDecayKitObject)
		thisObject["antiDecayKitObject"] = antiDecayKitObject.value();

	if (jediRobe)
		thisObject["jediRobe"] = jediRobe.value();

	if (unionRing)
		thisObject["unionRing"] = unionRing.value();

	j["TangibleObject"] = thisObject;
}


void TangibleObjectPOD::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = TangibleObjectPOD::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int TangibleObjectPOD::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = SceneObjectPOD::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	if (targetable) {
	_nameHashCode = 0x44d211d4; //TangibleObject.targetable
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&targetable.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (complexity) {
	_nameHashCode = 0x8ac8d204; //TangibleObject.complexity
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&complexity.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (volume) {
	_nameHashCode = 0x1e059da5; //TangibleObject.volume
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&volume.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (faction) {
	_nameHashCode = 0x7aa39254; //TangibleObject.faction
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned int >::toBinaryStream(&faction.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (factionStatus) {
	_nameHashCode = 0x26d472b0; //TangibleObject.factionStatus
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&factionStatus.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (futureFactionStatus) {
	_nameHashCode = 0xa4095b71; //TangibleObject.futureFactionStatus
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&futureFactionStatus.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (invisible) {
	_nameHashCode = 0xc5251423; //TangibleObject.invisible
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&invisible.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (luaStringData) {
	_nameHashCode = 0xf53ca7; //TangibleObject.luaStringData
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<VectorMap<String, String> >::toBinaryStream(&luaStringData.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (customizationVariables) {
	_nameHashCode = 0xb56f0247; //TangibleObject.customizationVariables
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<CustomizationVariables >::toBinaryStream(&customizationVariables.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (unmitigatedDamage) {
	_nameHashCode = 0x446e9ce1; //TangibleObject.unmitigatedDamage
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&unmitigatedDamage.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (conditionDamage) {
	_nameHashCode = 0xa4a80d3; //TangibleObject.conditionDamage
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&conditionDamage.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (maxCondition) {
	_nameHashCode = 0x9c2e3029; //TangibleObject.maxCondition
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&maxCondition.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (useCount) {
	_nameHashCode = 0xe6b8cb07; //TangibleObject.useCount
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&useCount.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (level) {
	_nameHashCode = 0xf479fb1c; //TangibleObject.level
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<short >::toBinaryStream(&level.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (optionsBitmask) {
	_nameHashCode = 0x6352a44d; //TangibleObject.optionsBitmask
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned int >::toBinaryStream(&optionsBitmask.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (magicBits) {
	_nameHashCode = 0xcbed6feb; //TangibleObject.magicBits
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<AtomicInteger >::toBinaryStream(&magicBits.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (visibleComponents) {
	_nameHashCode = 0x7169fd57; //TangibleObject.visibleComponents
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<AutoDeltaSet<int> >::toBinaryStream(&visibleComponents.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (isCraftedEnhancedItem) {
	_nameHashCode = 0x71d5e6e0; //TangibleObject.isCraftedEnhancedItem
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&isCraftedEnhancedItem.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (pvpStatusBitmask) {
	_nameHashCode = 0x78a68bd7; //TangibleObject.pvpStatusBitmask
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned int >::toBinaryStream(&pvpStatusBitmask.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (objectVisible) {
	_nameHashCode = 0x8a9c44bb; //TangibleObject.objectVisible
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<byte >::toBinaryStream(&objectVisible.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (craftersName) {
	_nameHashCode = 0xf6530d9d; //TangibleObject.craftersName
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&craftersName.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (craftersID) {
	_nameHashCode = 0x2673c744; //TangibleObject.craftersID
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&craftersID.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (junkDealerNeeded) {
	_nameHashCode = 0xa090b45c; //TangibleObject.junkDealerNeeded
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&junkDealerNeeded.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (junkValue) {
	_nameHashCode = 0x30289553; //TangibleObject.junkValue
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&junkValue.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (objectSerial) {
	_nameHashCode = 0x4f048d7d; //TangibleObject.objectSerial
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&objectSerial.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (defenderList) {
	_nameHashCode = 0x80b5a6a4; //TangibleObject.defenderList
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<DeltaVector<ManagedReference<SceneObjectPOD* > > >::toBinaryStream(&defenderList.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (sliceable) {
	_nameHashCode = 0x5e49de61; //TangibleObject.sliceable
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&sliceable.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (sliced) {
	_nameHashCode = 0x85d2a69f; //TangibleObject.sliced
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&sliced.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (activeAreas) {
	_nameHashCode = 0x140b08d0; //TangibleObject.activeAreas
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<SortedVector<ManagedReference<ActiveAreaPOD* > > >::toBinaryStream(&activeAreas.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (antiDecayKitObject) {
	_nameHashCode = 0x2e41d02d; //TangibleObject.antiDecayKitObject
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedReference<SceneObjectPOD* > >::toBinaryStream(&antiDecayKitObject.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (jediRobe) {
	_nameHashCode = 0x407b9075; //TangibleObject.jediRobe
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&jediRobe.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (unionRing) {
	_nameHashCode = 0x3bc3bd92; //TangibleObject.unionRing
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&unionRing.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}


	return _count;
}

bool TangibleObjectPOD::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (SceneObjectPOD::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0x44d211d4: //TangibleObject.targetable
		{
			bool _mntargetable;
			TypeInfo<bool >::parseFromBinaryStream(&_mntargetable, stream);
			targetable = std::move(_mntargetable);
		}
		return true;

	case 0x8ac8d204: //TangibleObject.complexity
		{
			float _mncomplexity;
			TypeInfo<float >::parseFromBinaryStream(&_mncomplexity, stream);
			complexity = std::move(_mncomplexity);
		}
		return true;

	case 0x1e059da5: //TangibleObject.volume
		{
			int _mnvolume;
			TypeInfo<int >::parseFromBinaryStream(&_mnvolume, stream);
			volume = std::move(_mnvolume);
		}
		return true;

	case 0x7aa39254: //TangibleObject.faction
		{
			unsigned int _mnfaction;
			TypeInfo<unsigned int >::parseFromBinaryStream(&_mnfaction, stream);
			faction = std::move(_mnfaction);
		}
		return true;

	case 0x26d472b0: //TangibleObject.factionStatus
		{
			int _mnfactionStatus;
			TypeInfo<int >::parseFromBinaryStream(&_mnfactionStatus, stream);
			factionStatus = std::move(_mnfactionStatus);
		}
		return true;

	case 0xa4095b71: //TangibleObject.futureFactionStatus
		{
			int _mnfutureFactionStatus;
			TypeInfo<int >::parseFromBinaryStream(&_mnfutureFactionStatus, stream);
			futureFactionStatus = std::move(_mnfutureFactionStatus);
		}
		return true;

	case 0xc5251423: //TangibleObject.invisible
		{
			bool _mninvisible;
			TypeInfo<bool >::parseFromBinaryStream(&_mninvisible, stream);
			invisible = std::move(_mninvisible);
		}
		return true;

	case 0xf53ca7: //TangibleObject.luaStringData
		{
			VectorMap<String, String> _mnluaStringData;
			TypeInfo<VectorMap<String, String> >::parseFromBinaryStream(&_mnluaStringData, stream);
			luaStringData = std::move(_mnluaStringData);
		}
		return true;

	case 0xb56f0247: //TangibleObject.customizationVariables
		{
			CustomizationVariables _mncustomizationVariables;
			TypeInfo<CustomizationVariables >::parseFromBinaryStream(&_mncustomizationVariables, stream);
			customizationVariables = std::move(_mncustomizationVariables);
		}
		return true;

	case 0x446e9ce1: //TangibleObject.unmitigatedDamage
		{
			int _mnunmitigatedDamage;
			TypeInfo<int >::parseFromBinaryStream(&_mnunmitigatedDamage, stream);
			unmitigatedDamage = std::move(_mnunmitigatedDamage);
		}
		return true;

	case 0xa4a80d3: //TangibleObject.conditionDamage
		{
			float _mnconditionDamage;
			TypeInfo<float >::parseFromBinaryStream(&_mnconditionDamage, stream);
			conditionDamage = std::move(_mnconditionDamage);
		}
		return true;

	case 0x9c2e3029: //TangibleObject.maxCondition
		{
			int _mnmaxCondition;
			TypeInfo<int >::parseFromBinaryStream(&_mnmaxCondition, stream);
			maxCondition = std::move(_mnmaxCondition);
		}
		return true;

	case 0xe6b8cb07: //TangibleObject.useCount
		{
			int _mnuseCount;
			TypeInfo<int >::parseFromBinaryStream(&_mnuseCount, stream);
			useCount = std::move(_mnuseCount);
		}
		return true;

	case 0xf479fb1c: //TangibleObject.level
		{
			short _mnlevel;
			TypeInfo<short >::parseFromBinaryStream(&_mnlevel, stream);
			level = std::move(_mnlevel);
		}
		return true;

	case 0x6352a44d: //TangibleObject.optionsBitmask
		{
			unsigned int _mnoptionsBitmask;
			TypeInfo<unsigned int >::parseFromBinaryStream(&_mnoptionsBitmask, stream);
			optionsBitmask = std::move(_mnoptionsBitmask);
		}
		return true;

	case 0xcbed6feb: //TangibleObject.magicBits
		{
			AtomicInteger _mnmagicBits;
			TypeInfo<AtomicInteger >::parseFromBinaryStream(&_mnmagicBits, stream);
			magicBits = std::move(_mnmagicBits);
		}
		return true;

	case 0x7169fd57: //TangibleObject.visibleComponents
		{
			AutoDeltaSet<int> _mnvisibleComponents;
			TypeInfo<AutoDeltaSet<int> >::parseFromBinaryStream(&_mnvisibleComponents, stream);
			visibleComponents = std::move(_mnvisibleComponents);
		}
		return true;

	case 0x71d5e6e0: //TangibleObject.isCraftedEnhancedItem
		{
			bool _mnisCraftedEnhancedItem;
			TypeInfo<bool >::parseFromBinaryStream(&_mnisCraftedEnhancedItem, stream);
			isCraftedEnhancedItem = std::move(_mnisCraftedEnhancedItem);
		}
		return true;

	case 0x78a68bd7: //TangibleObject.pvpStatusBitmask
		{
			unsigned int _mnpvpStatusBitmask;
			TypeInfo<unsigned int >::parseFromBinaryStream(&_mnpvpStatusBitmask, stream);
			pvpStatusBitmask = std::move(_mnpvpStatusBitmask);
		}
		return true;

	case 0x8a9c44bb: //TangibleObject.objectVisible
		{
			byte _mnobjectVisible;
			TypeInfo<byte >::parseFromBinaryStream(&_mnobjectVisible, stream);
			objectVisible = std::move(_mnobjectVisible);
		}
		return true;

	case 0xf6530d9d: //TangibleObject.craftersName
		{
			String _mncraftersName;
			TypeInfo<String >::parseFromBinaryStream(&_mncraftersName, stream);
			craftersName = std::move(_mncraftersName);
		}
		return true;

	case 0x2673c744: //TangibleObject.craftersID
		{
			unsigned long long _mncraftersID;
			TypeInfo<unsigned long long >::parseFromBinaryStream(&_mncraftersID, stream);
			craftersID = std::move(_mncraftersID);
		}
		return true;

	case 0xa090b45c: //TangibleObject.junkDealerNeeded
		{
			int _mnjunkDealerNeeded;
			TypeInfo<int >::parseFromBinaryStream(&_mnjunkDealerNeeded, stream);
			junkDealerNeeded = std::move(_mnjunkDealerNeeded);
		}
		return true;

	case 0x30289553: //TangibleObject.junkValue
		{
			int _mnjunkValue;
			TypeInfo<int >::parseFromBinaryStream(&_mnjunkValue, stream);
			junkValue = std::move(_mnjunkValue);
		}
		return true;

	case 0x4f048d7d: //TangibleObject.objectSerial
		{
			String _mnobjectSerial;
			TypeInfo<String >::parseFromBinaryStream(&_mnobjectSerial, stream);
			objectSerial = std::move(_mnobjectSerial);
		}
		return true;

	case 0x80b5a6a4: //TangibleObject.defenderList
		{
			DeltaVector<ManagedReference<SceneObjectPOD* > > _mndefenderList;
			TypeInfo<DeltaVector<ManagedReference<SceneObjectPOD* > > >::parseFromBinaryStream(&_mndefenderList, stream);
			defenderList = std::move(_mndefenderList);
		}
		return true;

	case 0x5e49de61: //TangibleObject.sliceable
		{
			bool _mnsliceable;
			TypeInfo<bool >::parseFromBinaryStream(&_mnsliceable, stream);
			sliceable = std::move(_mnsliceable);
		}
		return true;

	case 0x85d2a69f: //TangibleObject.sliced
		{
			bool _mnsliced;
			TypeInfo<bool >::parseFromBinaryStream(&_mnsliced, stream);
			sliced = std::move(_mnsliced);
		}
		return true;

	case 0x140b08d0: //TangibleObject.activeAreas
		{
			SortedVector<ManagedReference<ActiveAreaPOD* > > _mnactiveAreas;
			TypeInfo<SortedVector<ManagedReference<ActiveAreaPOD* > > >::parseFromBinaryStream(&_mnactiveAreas, stream);
			activeAreas = std::move(_mnactiveAreas);
		}
		return true;

	case 0x2e41d02d: //TangibleObject.antiDecayKitObject
		{
			ManagedReference<SceneObjectPOD* > _mnantiDecayKitObject;
			TypeInfo<ManagedReference<SceneObjectPOD* > >::parseFromBinaryStream(&_mnantiDecayKitObject, stream);
			antiDecayKitObject = std::move(_mnantiDecayKitObject);
		}
		return true;

	case 0x407b9075: //TangibleObject.jediRobe
		{
			bool _mnjediRobe;
			TypeInfo<bool >::parseFromBinaryStream(&_mnjediRobe, stream);
			jediRobe = std::move(_mnjediRobe);
		}
		return true;

	case 0x3bc3bd92: //TangibleObject.unionRing
		{
			bool _mnunionRing;
			TypeInfo<bool >::parseFromBinaryStream(&_mnunionRing, stream);
			unionRing = std::move(_mnunionRing);
		}
		return true;

	}

	return false;
}

void TangibleObjectPOD::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(TangibleObjectPOD::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

}

void TangibleObjectPOD::writeObjectCompact(ObjectOutputStream* stream) {
	SceneObjectPOD::writeObjectCompact(stream);

	TypeInfo<bool >::toBinaryStream(&targetable.value(), stream);

	TypeInfo<float >::toBinaryStream(&complexity.value(), stream);

	TypeInfo<int >::toBinaryStream(&volume.value(), stream);

	TypeInfo<unsigned int >::toBinaryStream(&faction.value(), stream);

	TypeInfo<int >::toBinaryStream(&factionStatus.value(), stream);

	TypeInfo<int >::toBinaryStream(&futureFactionStatus.value(), stream);

	TypeInfo<bool >::toBinaryStream(&invisible.value(), stream);

	TypeInfo<VectorMap<String, String> >::toBinaryStream(&luaStringData.value(), stream);

	TypeInfo<CustomizationVariables >::toBinaryStream(&customizationVariables.value(), stream);

	TypeInfo<int >::toBinaryStream(&unmitigatedDamage.value(), stream);

	TypeInfo<float >::toBinaryStream(&conditionDamage.value(), stream);

	TypeInfo<int >::toBinaryStream(&maxCondition.value(), stream);

	TypeInfo<int >::toBinaryStream(&useCount.value(), stream);

	TypeInfo<short >::toBinaryStream(&level.value(), stream);

	TypeInfo<unsigned int >::toBinaryStream(&optionsBitmask.value(), stream);

	TypeInfo<AtomicInteger >::toBinaryStream(&magicBits.value(), stream);

	TypeInfo<AutoDeltaSet<int> >::toBinaryStream(&visibleComponents.value(), stream);

	TypeInfo<bool >::toBinaryStream(&isCraftedEnhancedItem.value(), stream);

	TypeInfo<unsigned int >::toBinaryStream(&pvpStatusBitmask.value(), stream);

	TypeInfo<byte >::toBinaryStream(&objectVisible.value(), stream);

	TypeInfo<String >::toBinaryStream(&craftersName.value(), stream);

	TypeInfo<unsigned long long >::toBinaryStream(&craftersID.value(), stream);

	TypeInfo<int >::toBinaryStream(&junkDealerNeeded.value(), stream);

	TypeInfo<int >::toBinaryStream(&junkValue.value(), stream);

	TypeInfo<String >::toBinaryStream(&objectSerial.value(), stream);

	TypeInfo<DeltaVector<ManagedReference<SceneObjectPOD* > > >::toBinaryStream(&defenderList.value(), stream);

	TypeInfo<bool >::toBinaryStream(&sliceable.value(), stream);

	TypeInfo<bool >::toBinaryStream(&sliced.value(), stream);

	TypeInfo<SortedVector<ManagedReference<ActiveAreaPOD* > > >::toBinaryStream(&activeAreas.value(), stream);

	TypeInfo<ManagedReference<SceneObjectPOD* > >::toBinaryStream(&antiDecayKitObject.value(), stream);

	TypeInfo<bool >::toBinaryStream(&jediRobe.value(), stream);

	TypeInfo<bool >::toBinaryStream(&unionRing.value(), stream);


}

