/*
 *	autogen/server/zone/objects/tangible/deed/pet/PetDeed.cpp generated by engine3 IDL compiler 0.70
 */

#include "PetDeed.h"

#include "server/zone/packets/object/ObjectMenuResponse.h"

#include "server/zone/objects/creature/CreatureObject.h"

/*
 *	PetDeedStub
 */

enum {RPC_SETSPECIALRESIST__INT_ = 3403443374,RPC_ISSPECIALRESIST__INT_,RPC_GETSAMPLECOUNT__,RPC_INCREMENTSAMPLECOUNT__,RPC_INITIALIZETRANSIENTMEMBERS__,RPC_GETQUALITY__,RPC_GETLEVEL__,RPC_GETATTACKSPEED__,RPC_GETHITCHANCE__,RPC_GETHEALTH__,RPC_GETACTION__,RPC_GETMIND__,RPC_GETMINDAMAGE__,RPC_GETMAXDAMAGE__,RPC_GETKINETIC__,RPC_GETENERGY__,RPC_GETBLAST__,RPC_GETCOLD__,RPC_GETHEAT__,RPC_GETELECTRIC__,RPC_GETACID__,RPC_GETSTUN__,RPC_GETSABER__,RPC_GETRANGED__,RPC_GETARMOR__,RPC_HANDLEOBJECTMENUSELECT__CREATUREOBJECT_BYTE_,RPC_ISPETDEEDOBJECT__,RPC_GETSPECIAL1__,RPC_GETSPECIAL2__,RPC_GETCLEVERNESS__,RPC_GETENDURANCE__,RPC_GETFIERCENESS__,RPC_GETPOWER__,RPC_GETINTELLECT__,RPC_GETCOURAGE__,RPC_GETDEPENDABILITY__,RPC_GETDEXTERITY__,RPC_GETFORTITUDE__,RPC_GETHARDINESS__,};

PetDeed::PetDeed() : Deed(DummyConstructorParameter::instance()) {
	PetDeedImplementation* _implementation = new PetDeedImplementation();
	_impl = _implementation;
	_impl->_setStub(this);
	_setClassName("PetDeed");
}

PetDeed::PetDeed(DummyConstructorParameter* param) : Deed(param) {
	_setClassName("PetDeed");
}

PetDeed::~PetDeed() {
}



void PetDeed::setSpecialResist(int type) {
	PetDeedImplementation* _implementation = static_cast<PetDeedImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSPECIALRESIST__INT_);
		method.addSignedIntParameter(type);

		method.executeWithVoidReturn();
	} else {
		_implementation->setSpecialResist(type);
	}
}

bool PetDeed::isSpecialResist(int type) const {
	PetDeedImplementation* _implementation = static_cast<PetDeedImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISSPECIALRESIST__INT_);
		method.addSignedIntParameter(type);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isSpecialResist(type);
	}
}

int PetDeed::getSampleCount() const {
	PetDeedImplementation* _implementation = static_cast<PetDeedImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSAMPLECOUNT__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getSampleCount();
	}
}

void PetDeed::incrementSampleCount() {
	PetDeedImplementation* _implementation = static_cast<PetDeedImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INCREMENTSAMPLECOUNT__);

		method.executeWithVoidReturn();
	} else {
		_implementation->incrementSampleCount();
	}
}

void PetDeed::initializeTransientMembers() {
	PetDeedImplementation* _implementation = static_cast<PetDeedImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INITIALIZETRANSIENTMEMBERS__);

		method.executeWithVoidReturn();
	} else {
		_implementation->initializeTransientMembers();
	}
}

const CreatureAttackMap* PetDeed::getAttacks() const {
	PetDeedImplementation* _implementation = static_cast<PetDeedImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getAttacks();
	}
}

int PetDeed::getQuality() const {
	PetDeedImplementation* _implementation = static_cast<PetDeedImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETQUALITY__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getQuality();
	}
}

int PetDeed::getLevel() const {
	PetDeedImplementation* _implementation = static_cast<PetDeedImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETLEVEL__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getLevel();
	}
}

float PetDeed::getAttackSpeed() const {
	PetDeedImplementation* _implementation = static_cast<PetDeedImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETATTACKSPEED__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getAttackSpeed();
	}
}

float PetDeed::getHitChance() const {
	PetDeedImplementation* _implementation = static_cast<PetDeedImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETHITCHANCE__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getHitChance();
	}
}

int PetDeed::getHealth() const {
	PetDeedImplementation* _implementation = static_cast<PetDeedImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETHEALTH__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getHealth();
	}
}

int PetDeed::getAction() const {
	PetDeedImplementation* _implementation = static_cast<PetDeedImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETACTION__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getAction();
	}
}

int PetDeed::getMind() const {
	PetDeedImplementation* _implementation = static_cast<PetDeedImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMIND__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getMind();
	}
}

int PetDeed::getMinDamage() const {
	PetDeedImplementation* _implementation = static_cast<PetDeedImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMINDAMAGE__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getMinDamage();
	}
}

int PetDeed::getMaxDamage() const {
	PetDeedImplementation* _implementation = static_cast<PetDeedImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMAXDAMAGE__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getMaxDamage();
	}
}

float PetDeed::getKinetic() const {
	PetDeedImplementation* _implementation = static_cast<PetDeedImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETKINETIC__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getKinetic();
	}
}

float PetDeed::getEnergy() const {
	PetDeedImplementation* _implementation = static_cast<PetDeedImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETENERGY__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getEnergy();
	}
}

float PetDeed::getBlast() const {
	PetDeedImplementation* _implementation = static_cast<PetDeedImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETBLAST__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getBlast();
	}
}

float PetDeed::getCold() const {
	PetDeedImplementation* _implementation = static_cast<PetDeedImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCOLD__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getCold();
	}
}

float PetDeed::getHeat() const {
	PetDeedImplementation* _implementation = static_cast<PetDeedImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETHEAT__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getHeat();
	}
}

float PetDeed::getElectric() const {
	PetDeedImplementation* _implementation = static_cast<PetDeedImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETELECTRIC__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getElectric();
	}
}

float PetDeed::getAcid() const {
	PetDeedImplementation* _implementation = static_cast<PetDeedImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETACID__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getAcid();
	}
}

float PetDeed::getStun() const {
	PetDeedImplementation* _implementation = static_cast<PetDeedImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSTUN__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getStun();
	}
}

float PetDeed::getSaber() const {
	PetDeedImplementation* _implementation = static_cast<PetDeedImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSABER__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getSaber();
	}
}

bool PetDeed::getRanged() const {
	PetDeedImplementation* _implementation = static_cast<PetDeedImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETRANGED__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->getRanged();
	}
}

int PetDeed::getArmor() const {
	PetDeedImplementation* _implementation = static_cast<PetDeedImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETARMOR__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getArmor();
	}
}

void PetDeed::loadTemplateData(SharedObjectTemplate* templateData) {
	PetDeedImplementation* _implementation = static_cast<PetDeedImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->loadTemplateData(templateData);
	}
}

void PetDeed::fillAttributeList(AttributeListMessage* alm, CreatureObject* object) {
	PetDeedImplementation* _implementation = static_cast<PetDeedImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->fillAttributeList(alm, object);
	}
}

void PetDeed::fillObjectMenuResponse(ObjectMenuResponse* menuResponse, CreatureObject* player) {
	PetDeedImplementation* _implementation = static_cast<PetDeedImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->fillObjectMenuResponse(menuResponse, player);
	}
}

int PetDeed::handleObjectMenuSelect(CreatureObject* player, byte selectedID) {
	PetDeedImplementation* _implementation = static_cast<PetDeedImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HANDLEOBJECTMENUSELECT__CREATUREOBJECT_BYTE_);
		method.addObjectParameter(player);
		method.addByteParameter(selectedID);

		return method.executeWithSignedIntReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		assert((player == NULL) || player->isLockedByCurrentThread());
		return _implementation->handleObjectMenuSelect(player, selectedID);
	}
}

void PetDeed::updateCraftingValues(CraftingValues* values, bool firstUpdate) {
	PetDeedImplementation* _implementation = static_cast<PetDeedImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->updateCraftingValues(values, firstUpdate);
	}
}

bool PetDeed::isPetDeedObject() {
	PetDeedImplementation* _implementation = static_cast<PetDeedImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISPETDEEDOBJECT__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isPetDeedObject();
	}
}

String PetDeed::getSpecial1() const {
	PetDeedImplementation* _implementation = static_cast<PetDeedImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSPECIAL1__);

		String _return_getSpecial1;
		method.executeWithAsciiReturn(_return_getSpecial1);
		return _return_getSpecial1;
	} else {
		return _implementation->getSpecial1();
	}
}

String PetDeed::getSpecial2() const {
	PetDeedImplementation* _implementation = static_cast<PetDeedImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSPECIAL2__);

		String _return_getSpecial2;
		method.executeWithAsciiReturn(_return_getSpecial2);
		return _return_getSpecial2;
	} else {
		return _implementation->getSpecial2();
	}
}

float PetDeed::getCleverness() const {
	PetDeedImplementation* _implementation = static_cast<PetDeedImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCLEVERNESS__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getCleverness();
	}
}

float PetDeed::getEndurance() const {
	PetDeedImplementation* _implementation = static_cast<PetDeedImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETENDURANCE__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getEndurance();
	}
}

float PetDeed::getFierceness() const {
	PetDeedImplementation* _implementation = static_cast<PetDeedImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETFIERCENESS__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getFierceness();
	}
}

float PetDeed::getPower() const {
	PetDeedImplementation* _implementation = static_cast<PetDeedImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETPOWER__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getPower();
	}
}

float PetDeed::getIntellect() const {
	PetDeedImplementation* _implementation = static_cast<PetDeedImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETINTELLECT__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getIntellect();
	}
}

float PetDeed::getCourage() const {
	PetDeedImplementation* _implementation = static_cast<PetDeedImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCOURAGE__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getCourage();
	}
}

float PetDeed::getDependability() const {
	PetDeedImplementation* _implementation = static_cast<PetDeedImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETDEPENDABILITY__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getDependability();
	}
}

float PetDeed::getDexterity() const {
	PetDeedImplementation* _implementation = static_cast<PetDeedImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETDEXTERITY__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getDexterity();
	}
}

float PetDeed::getFortitude() const {
	PetDeedImplementation* _implementation = static_cast<PetDeedImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETFORTITUDE__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getFortitude();
	}
}

float PetDeed::getHardiness() const {
	PetDeedImplementation* _implementation = static_cast<PetDeedImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETHARDINESS__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getHardiness();
	}
}

String PetDeed::getTemplateName() const {
	PetDeedImplementation* _implementation = static_cast<PetDeedImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getTemplateName();
	}
}

void PetDeed::setupAttacks() {
	PetDeedImplementation* _implementation = static_cast<PetDeedImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->setupAttacks();
	}
}

int PetDeed::calculatePetLevel() {
	PetDeedImplementation* _implementation = static_cast<PetDeedImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->calculatePetLevel();
	}
}

void PetDeed::adjustPetLevel(CreatureObject* player, CreatureObject* pet) {
	PetDeedImplementation* _implementation = static_cast<PetDeedImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->adjustPetLevel(player, pet);
	}
}

bool PetDeed::adjustPetStats(CreatureObject* player, CreatureObject* pet) {
	PetDeedImplementation* _implementation = static_cast<PetDeedImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->adjustPetStats(player, pet);
	}
}

DistributedObjectServant* PetDeed::_getImplementation() {

	 if (!_updated) _updated = true;
	return _impl;
}

DistributedObjectServant* PetDeed::_getImplementationForRead() const {
	return _impl;
}

void PetDeed::_setImplementation(DistributedObjectServant* servant) {
	_impl = servant;
}

/*
 *	PetDeedImplementation
 */

PetDeedImplementation::PetDeedImplementation(DummyConstructorParameter* param) : DeedImplementation(param) {
	_initializeImplementation();
}


PetDeedImplementation::~PetDeedImplementation() {
}


void PetDeedImplementation::finalize() {
}

void PetDeedImplementation::_initializeImplementation() {
	_setClassHelper(PetDeedHelper::instance());

	_this = NULL;

	_serializationHelperMethod();
}

void PetDeedImplementation::_setStub(DistributedObjectStub* stub) {
	_this = static_cast<PetDeed*>(stub);
	DeedImplementation::_setStub(stub);
}

DistributedObjectStub* PetDeedImplementation::_getStub() {
	return _this.get();
}

PetDeedImplementation::operator const PetDeed*() {
	return _this.get();
}

void PetDeedImplementation::lock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->lock(doLock);
}

void PetDeedImplementation::lock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->lock(obj);
}

void PetDeedImplementation::rlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->rlock(doLock);
}

void PetDeedImplementation::wlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->wlock(doLock);
}

void PetDeedImplementation::wlock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->wlock(obj);
}

void PetDeedImplementation::unlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->unlock(doLock);
}

void PetDeedImplementation::runlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->runlock(doLock);
}

void PetDeedImplementation::_serializationHelperMethod() {
	DeedImplementation::_serializationHelperMethod();

	_setClassName("PetDeed");

}

void PetDeedImplementation::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(PetDeedImplementation::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

	initializeTransientMembers();
}

bool PetDeedImplementation::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (DeedImplementation::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0x4b7dc854: //PetDeed.quality
		TypeInfo<int >::parseFromBinaryStream(&quality, stream);
		return true;

	case 0xfacef493: //PetDeed.level
		TypeInfo<int >::parseFromBinaryStream(&level, stream);
		return true;

	case 0xcc2fc84d: //PetDeed.chanceHit
		TypeInfo<float >::parseFromBinaryStream(&chanceHit, stream);
		return true;

	case 0x3f1c3cb0: //PetDeed.attackSpeed
		TypeInfo<float >::parseFromBinaryStream(&attackSpeed, stream);
		return true;

	case 0x36bbae6: //PetDeed.damageMin
		TypeInfo<int >::parseFromBinaryStream(&damageMin, stream);
		return true;

	case 0xdfb46f76: //PetDeed.damageMax
		TypeInfo<int >::parseFromBinaryStream(&damageMax, stream);
		return true;

	case 0x724b3bb5: //PetDeed.armor
		TypeInfo<int >::parseFromBinaryStream(&armor, stream);
		return true;

	case 0x6c400b95: //PetDeed.kinResist
		TypeInfo<float >::parseFromBinaryStream(&kinResist, stream);
		return true;

	case 0x74ad1e50: //PetDeed.energyResist
		TypeInfo<float >::parseFromBinaryStream(&energyResist, stream);
		return true;

	case 0xcc571853: //PetDeed.blastResist
		TypeInfo<float >::parseFromBinaryStream(&blastResist, stream);
		return true;

	case 0xacf0b4a4: //PetDeed.coldResist
		TypeInfo<float >::parseFromBinaryStream(&coldResist, stream);
		return true;

	case 0x539aeeb7: //PetDeed.heatResist
		TypeInfo<float >::parseFromBinaryStream(&heatResist, stream);
		return true;

	case 0xd758b406: //PetDeed.elecResist
		TypeInfo<float >::parseFromBinaryStream(&elecResist, stream);
		return true;

	case 0xd3f4d7fc: //PetDeed.acidResist
		TypeInfo<float >::parseFromBinaryStream(&acidResist, stream);
		return true;

	case 0xc857a962: //PetDeed.stunResist
		TypeInfo<float >::parseFromBinaryStream(&stunResist, stream);
		return true;

	case 0xce82cd9d: //PetDeed.saberResist
		TypeInfo<float >::parseFromBinaryStream(&saberResist, stream);
		return true;

	case 0x41ae256d: //PetDeed.health
		TypeInfo<int >::parseFromBinaryStream(&health, stream);
		return true;

	case 0x926a20e6: //PetDeed.action
		TypeInfo<int >::parseFromBinaryStream(&action, stream);
		return true;

	case 0x8d871551: //PetDeed.mind
		TypeInfo<int >::parseFromBinaryStream(&mind, stream);
		return true;

	case 0x9fcbee99: //PetDeed.regen
		TypeInfo<int >::parseFromBinaryStream(&regen, stream);
		return true;

	case 0x887f0773: //PetDeed.special1
		TypeInfo<String >::parseFromBinaryStream(&special1, stream);
		return true;

	case 0x853c21aa: //PetDeed.special2
		TypeInfo<String >::parseFromBinaryStream(&special2, stream);
		return true;

	case 0x268b2b92: //PetDeed.ranged
		TypeInfo<bool >::parseFromBinaryStream(&ranged, stream);
		return true;

	case 0x5fe2df88: //PetDeed.controlDeviceObjectTemplate
		TypeInfo<String >::parseFromBinaryStream(&controlDeviceObjectTemplate, stream);
		return true;

	case 0x876bd86e: //PetDeed.mobileTemplate
		TypeInfo<String >::parseFromBinaryStream(&mobileTemplate, stream);
		return true;

	case 0x17add007: //PetDeed.cleverness
		TypeInfo<float >::parseFromBinaryStream(&cleverness, stream);
		return true;

	case 0xeb9fff0d: //PetDeed.endurance
		TypeInfo<float >::parseFromBinaryStream(&endurance, stream);
		return true;

	case 0xb0e1584e: //PetDeed.fierceness
		TypeInfo<float >::parseFromBinaryStream(&fierceness, stream);
		return true;

	case 0x2cb61934: //PetDeed.power
		TypeInfo<float >::parseFromBinaryStream(&power, stream);
		return true;

	case 0x9d7412df: //PetDeed.intellect
		TypeInfo<float >::parseFromBinaryStream(&intellect, stream);
		return true;

	case 0x12a5e8ab: //PetDeed.courage
		TypeInfo<float >::parseFromBinaryStream(&courage, stream);
		return true;

	case 0x898537fe: //PetDeed.dependability
		TypeInfo<float >::parseFromBinaryStream(&dependability, stream);
		return true;

	case 0x22d48997: //PetDeed.dexterity
		TypeInfo<float >::parseFromBinaryStream(&dexterity, stream);
		return true;

	case 0x90df2a88: //PetDeed.fortitude
		TypeInfo<float >::parseFromBinaryStream(&fortitude, stream);
		return true;

	case 0x5ab3092e: //PetDeed.hardiness
		TypeInfo<float >::parseFromBinaryStream(&hardiness, stream);
		return true;

	case 0x7c55a5ed: //PetDeed.sampleCount
		TypeInfo<int >::parseFromBinaryStream(&sampleCount, stream);
		return true;

	case 0x41917681: //PetDeed.specialResists
		TypeInfo<int >::parseFromBinaryStream(&specialResists, stream);
		return true;

	case 0x8a56db81: //PetDeed.attacks
		TypeInfo<CreatureAttackMap >::parseFromBinaryStream(&attacks, stream);
		return true;

	}

	return false;
}

void PetDeedImplementation::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = PetDeedImplementation::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int PetDeedImplementation::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = DeedImplementation::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	_nameHashCode = 0x4b7dc854; //PetDeed.quality
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&quality, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xfacef493; //PetDeed.level
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&level, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xcc2fc84d; //PetDeed.chanceHit
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&chanceHit, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x3f1c3cb0; //PetDeed.attackSpeed
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&attackSpeed, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x36bbae6; //PetDeed.damageMin
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&damageMin, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xdfb46f76; //PetDeed.damageMax
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&damageMax, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x724b3bb5; //PetDeed.armor
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&armor, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x6c400b95; //PetDeed.kinResist
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&kinResist, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x74ad1e50; //PetDeed.energyResist
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&energyResist, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xcc571853; //PetDeed.blastResist
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&blastResist, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xacf0b4a4; //PetDeed.coldResist
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&coldResist, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x539aeeb7; //PetDeed.heatResist
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&heatResist, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xd758b406; //PetDeed.elecResist
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&elecResist, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xd3f4d7fc; //PetDeed.acidResist
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&acidResist, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xc857a962; //PetDeed.stunResist
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&stunResist, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xce82cd9d; //PetDeed.saberResist
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&saberResist, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x41ae256d; //PetDeed.health
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&health, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x926a20e6; //PetDeed.action
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&action, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x8d871551; //PetDeed.mind
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&mind, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x9fcbee99; //PetDeed.regen
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&regen, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x887f0773; //PetDeed.special1
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&special1, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x853c21aa; //PetDeed.special2
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&special2, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x268b2b92; //PetDeed.ranged
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&ranged, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x5fe2df88; //PetDeed.controlDeviceObjectTemplate
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&controlDeviceObjectTemplate, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x876bd86e; //PetDeed.mobileTemplate
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&mobileTemplate, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x17add007; //PetDeed.cleverness
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&cleverness, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xeb9fff0d; //PetDeed.endurance
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&endurance, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xb0e1584e; //PetDeed.fierceness
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&fierceness, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x2cb61934; //PetDeed.power
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&power, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x9d7412df; //PetDeed.intellect
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&intellect, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x12a5e8ab; //PetDeed.courage
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&courage, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x898537fe; //PetDeed.dependability
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&dependability, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x22d48997; //PetDeed.dexterity
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&dexterity, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x90df2a88; //PetDeed.fortitude
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&fortitude, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x5ab3092e; //PetDeed.hardiness
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&hardiness, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x7c55a5ed; //PetDeed.sampleCount
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&sampleCount, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x41917681; //PetDeed.specialResists
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&specialResists, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x8a56db81; //PetDeed.attacks
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<CreatureAttackMap >::toBinaryStream(&attacks, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;


	return _count;
}

void PetDeedImplementation::writeJSON(nlohmann::json& j) {
	DeedImplementation::writeJSON(j);

	nlohmann::json thisObject = nlohmann::json::object();
	thisObject["quality"] = quality;

	thisObject["level"] = level;

	thisObject["chanceHit"] = chanceHit;

	thisObject["attackSpeed"] = attackSpeed;

	thisObject["damageMin"] = damageMin;

	thisObject["damageMax"] = damageMax;

	thisObject["armor"] = armor;

	thisObject["kinResist"] = kinResist;

	thisObject["energyResist"] = energyResist;

	thisObject["blastResist"] = blastResist;

	thisObject["coldResist"] = coldResist;

	thisObject["heatResist"] = heatResist;

	thisObject["elecResist"] = elecResist;

	thisObject["acidResist"] = acidResist;

	thisObject["stunResist"] = stunResist;

	thisObject["saberResist"] = saberResist;

	thisObject["health"] = health;

	thisObject["action"] = action;

	thisObject["mind"] = mind;

	thisObject["regen"] = regen;

	thisObject["special1"] = special1;

	thisObject["special2"] = special2;

	thisObject["ranged"] = ranged;

	thisObject["controlDeviceObjectTemplate"] = controlDeviceObjectTemplate;

	thisObject["mobileTemplate"] = mobileTemplate;

	thisObject["cleverness"] = cleverness;

	thisObject["endurance"] = endurance;

	thisObject["fierceness"] = fierceness;

	thisObject["power"] = power;

	thisObject["intellect"] = intellect;

	thisObject["courage"] = courage;

	thisObject["dependability"] = dependability;

	thisObject["dexterity"] = dexterity;

	thisObject["fortitude"] = fortitude;

	thisObject["hardiness"] = hardiness;

	thisObject["sampleCount"] = sampleCount;

	thisObject["specialResists"] = specialResists;

	thisObject["attacks"] = attacks;

	j["PetDeed"] = thisObject;
}

PetDeedImplementation::PetDeedImplementation() {
	_initializeImplementation();
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		Logger.setLoggingName("PetDeed");
	Logger::setLoggingName("PetDeed");
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		damageMin = 20;
	damageMin = 20;
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		damageMax = 20;
	damageMax = 20;
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		armor = 0;
	armor = 0;
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		kinResist = 0;
	kinResist = 0;
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		blastResist = 0;
	blastResist = 0;
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		coldResist = 0;
	coldResist = 0;
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		heatResist = 0;
	heatResist = 0;
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		elecResist = 0;
	elecResist = 0;
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		acidResist = 0;
	acidResist = 0;
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		stunResist = 0;
	stunResist = 0;
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		saberResist = -1;
	saberResist = -1;
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		health = 10;
	health = 10;
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		action = 10;
	action = 10;
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		mind = 10;
	mind = 10;
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		special1 = "none";
	special1 = "none";
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		special2 = "none";
	special2 = "none";
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		ranged = false;
	ranged = false;
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		chanceHit = 0;
	chanceHit = 0;
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		attackSpeed = 0;
	attackSpeed = 0;
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		level = 1;
	level = 1;
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		fortitude = 0.f;
	fortitude = 0.f;
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		hardiness = 0.f;
	hardiness = 0.f;
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		dexterity = 0.f;
	dexterity = 0.f;
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		endurance = 0.f;
	endurance = 0.f;
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		intellect = 0.f;
	intellect = 0.f;
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		cleverness = 0.f;
	cleverness = 0.f;
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		dependability = 0.f;
	dependability = 0.f;
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		courage = 0.f;
	courage = 0.f;
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		fierceness = 0.f;
	fierceness = 0.f;
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		power = 0.f;
	power = 0.f;
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		quality = 7;
	quality = 7;
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		sampleCount = 0;
	sampleCount = 0;
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		specialResists = 0;
	specialResists = 0;
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		regen = 1;
	regen = 1;
}

int PetDeedImplementation::getSampleCount() const{
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		return sampleCount;
	return sampleCount;
}

void PetDeedImplementation::incrementSampleCount() {
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		sampleCount += 1;
	sampleCount += 1;
}

int PetDeedImplementation::getQuality() const{
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		return quality;
	return quality;
}

int PetDeedImplementation::getLevel() const{
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		return level;
	return level;
}

float PetDeedImplementation::getAttackSpeed() const{
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		return attackSpeed;
	return attackSpeed;
}

float PetDeedImplementation::getHitChance() const{
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		return chanceHit;
	return chanceHit;
}

int PetDeedImplementation::getHealth() const{
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		return health;
	return health;
}

int PetDeedImplementation::getAction() const{
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		return action;
	return action;
}

int PetDeedImplementation::getMind() const{
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		return mind;
	return mind;
}

int PetDeedImplementation::getMinDamage() const{
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		return damageMin;
	return damageMin;
}

int PetDeedImplementation::getMaxDamage() const{
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		return damageMax;
	return damageMax;
}

float PetDeedImplementation::getKinetic() const{
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		return kinResist;
	return kinResist;
}

float PetDeedImplementation::getEnergy() const{
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		return energyResist;
	return energyResist;
}

float PetDeedImplementation::getBlast() const{
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		return blastResist;
	return blastResist;
}

float PetDeedImplementation::getCold() const{
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		return coldResist;
	return coldResist;
}

float PetDeedImplementation::getHeat() const{
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		return heatResist;
	return heatResist;
}

float PetDeedImplementation::getElectric() const{
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		return elecResist;
	return elecResist;
}

float PetDeedImplementation::getAcid() const{
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		return acidResist;
	return acidResist;
}

float PetDeedImplementation::getStun() const{
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		return stunResist;
	return stunResist;
}

float PetDeedImplementation::getSaber() const{
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		return saberResist;
	return saberResist;
}

bool PetDeedImplementation::getRanged() const{
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		return ranged;
	return ranged;
}

int PetDeedImplementation::getArmor() const{
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		return armor;
	return armor;
}

bool PetDeedImplementation::isPetDeedObject() {
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		return true;
	return true;
}

String PetDeedImplementation::getSpecial1() const{
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		return special1;
	return special1;
}

String PetDeedImplementation::getSpecial2() const{
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		return special2;
	return special2;
}

float PetDeedImplementation::getCleverness() const{
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		return cleverness;
	return cleverness;
}

float PetDeedImplementation::getEndurance() const{
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		return endurance;
	return endurance;
}

float PetDeedImplementation::getFierceness() const{
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		return fierceness;
	return fierceness;
}

float PetDeedImplementation::getPower() const{
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		return power;
	return power;
}

float PetDeedImplementation::getIntellect() const{
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		return intellect;
	return intellect;
}

float PetDeedImplementation::getCourage() const{
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		return courage;
	return courage;
}

float PetDeedImplementation::getDependability() const{
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		return dependability;
	return dependability;
}

float PetDeedImplementation::getDexterity() const{
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		return dexterity;
	return dexterity;
}

float PetDeedImplementation::getFortitude() const{
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		return fortitude;
	return fortitude;
}

float PetDeedImplementation::getHardiness() const{
	// server/zone/objects/tangible/deed/pet/PetDeed.idl():  		return hardiness;
	return hardiness;
}

/*
 *	PetDeedAdapter
 */


#include "engine/orb/messages/InvokeMethodMessage.h"


PetDeedAdapter::PetDeedAdapter(PetDeed* obj) : DeedAdapter(obj) {
}

void PetDeedAdapter::invokeMethod(uint32 methid, DistributedMethod* inv) {
	DOBMessage* resp = inv->getInvocationMessage();

	switch (methid) {
	case RPC_SETSPECIALRESIST__INT_:
		{
			int type = inv->getSignedIntParameter();
			
			setSpecialResist(type);
			
		}
		break;
	case RPC_ISSPECIALRESIST__INT_:
		{
			int type = inv->getSignedIntParameter();
			
			bool _m_res = isSpecialResist(type);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETSAMPLECOUNT__:
		{
			
			int _m_res = getSampleCount();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_INCREMENTSAMPLECOUNT__:
		{
			
			incrementSampleCount();
			
		}
		break;
	case RPC_INITIALIZETRANSIENTMEMBERS__:
		{
			
			initializeTransientMembers();
			
		}
		break;
	case RPC_GETQUALITY__:
		{
			
			int _m_res = getQuality();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETLEVEL__:
		{
			
			int _m_res = getLevel();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETATTACKSPEED__:
		{
			
			float _m_res = getAttackSpeed();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETHITCHANCE__:
		{
			
			float _m_res = getHitChance();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETHEALTH__:
		{
			
			int _m_res = getHealth();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETACTION__:
		{
			
			int _m_res = getAction();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETMIND__:
		{
			
			int _m_res = getMind();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETMINDAMAGE__:
		{
			
			int _m_res = getMinDamage();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETMAXDAMAGE__:
		{
			
			int _m_res = getMaxDamage();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETKINETIC__:
		{
			
			float _m_res = getKinetic();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETENERGY__:
		{
			
			float _m_res = getEnergy();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETBLAST__:
		{
			
			float _m_res = getBlast();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETCOLD__:
		{
			
			float _m_res = getCold();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETHEAT__:
		{
			
			float _m_res = getHeat();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETELECTRIC__:
		{
			
			float _m_res = getElectric();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETACID__:
		{
			
			float _m_res = getAcid();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETSTUN__:
		{
			
			float _m_res = getStun();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETSABER__:
		{
			
			float _m_res = getSaber();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETRANGED__:
		{
			
			bool _m_res = getRanged();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETARMOR__:
		{
			
			int _m_res = getArmor();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_HANDLEOBJECTMENUSELECT__CREATUREOBJECT_BYTE_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			byte selectedID = inv->getByteParameter();
			
			int _m_res = handleObjectMenuSelect(player, selectedID);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_ISPETDEEDOBJECT__:
		{
			
			bool _m_res = isPetDeedObject();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETSPECIAL1__:
		{
			
			String _m_res = getSpecial1();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_GETSPECIAL2__:
		{
			
			String _m_res = getSpecial2();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_GETCLEVERNESS__:
		{
			
			float _m_res = getCleverness();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETENDURANCE__:
		{
			
			float _m_res = getEndurance();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETFIERCENESS__:
		{
			
			float _m_res = getFierceness();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETPOWER__:
		{
			
			float _m_res = getPower();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETINTELLECT__:
		{
			
			float _m_res = getIntellect();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETCOURAGE__:
		{
			
			float _m_res = getCourage();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETDEPENDABILITY__:
		{
			
			float _m_res = getDependability();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETDEXTERITY__:
		{
			
			float _m_res = getDexterity();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETFORTITUDE__:
		{
			
			float _m_res = getFortitude();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETHARDINESS__:
		{
			
			float _m_res = getHardiness();
			resp->insertFloat(_m_res);
		}
		break;
	default:
		DeedAdapter::invokeMethod(methid, inv);
	}
}

void PetDeedAdapter::setSpecialResist(int type) {
	(static_cast<PetDeed*>(stub))->setSpecialResist(type);
}

bool PetDeedAdapter::isSpecialResist(int type) const {
	return (static_cast<PetDeed*>(stub))->isSpecialResist(type);
}

int PetDeedAdapter::getSampleCount() const {
	return (static_cast<PetDeed*>(stub))->getSampleCount();
}

void PetDeedAdapter::incrementSampleCount() {
	(static_cast<PetDeed*>(stub))->incrementSampleCount();
}

void PetDeedAdapter::initializeTransientMembers() {
	(static_cast<PetDeed*>(stub))->initializeTransientMembers();
}

int PetDeedAdapter::getQuality() const {
	return (static_cast<PetDeed*>(stub))->getQuality();
}

int PetDeedAdapter::getLevel() const {
	return (static_cast<PetDeed*>(stub))->getLevel();
}

float PetDeedAdapter::getAttackSpeed() const {
	return (static_cast<PetDeed*>(stub))->getAttackSpeed();
}

float PetDeedAdapter::getHitChance() const {
	return (static_cast<PetDeed*>(stub))->getHitChance();
}

int PetDeedAdapter::getHealth() const {
	return (static_cast<PetDeed*>(stub))->getHealth();
}

int PetDeedAdapter::getAction() const {
	return (static_cast<PetDeed*>(stub))->getAction();
}

int PetDeedAdapter::getMind() const {
	return (static_cast<PetDeed*>(stub))->getMind();
}

int PetDeedAdapter::getMinDamage() const {
	return (static_cast<PetDeed*>(stub))->getMinDamage();
}

int PetDeedAdapter::getMaxDamage() const {
	return (static_cast<PetDeed*>(stub))->getMaxDamage();
}

float PetDeedAdapter::getKinetic() const {
	return (static_cast<PetDeed*>(stub))->getKinetic();
}

float PetDeedAdapter::getEnergy() const {
	return (static_cast<PetDeed*>(stub))->getEnergy();
}

float PetDeedAdapter::getBlast() const {
	return (static_cast<PetDeed*>(stub))->getBlast();
}

float PetDeedAdapter::getCold() const {
	return (static_cast<PetDeed*>(stub))->getCold();
}

float PetDeedAdapter::getHeat() const {
	return (static_cast<PetDeed*>(stub))->getHeat();
}

float PetDeedAdapter::getElectric() const {
	return (static_cast<PetDeed*>(stub))->getElectric();
}

float PetDeedAdapter::getAcid() const {
	return (static_cast<PetDeed*>(stub))->getAcid();
}

float PetDeedAdapter::getStun() const {
	return (static_cast<PetDeed*>(stub))->getStun();
}

float PetDeedAdapter::getSaber() const {
	return (static_cast<PetDeed*>(stub))->getSaber();
}

bool PetDeedAdapter::getRanged() const {
	return (static_cast<PetDeed*>(stub))->getRanged();
}

int PetDeedAdapter::getArmor() const {
	return (static_cast<PetDeed*>(stub))->getArmor();
}

int PetDeedAdapter::handleObjectMenuSelect(CreatureObject* player, byte selectedID) {
	return (static_cast<PetDeed*>(stub))->handleObjectMenuSelect(player, selectedID);
}

bool PetDeedAdapter::isPetDeedObject() {
	return (static_cast<PetDeed*>(stub))->isPetDeedObject();
}

String PetDeedAdapter::getSpecial1() const {
	return (static_cast<PetDeed*>(stub))->getSpecial1();
}

String PetDeedAdapter::getSpecial2() const {
	return (static_cast<PetDeed*>(stub))->getSpecial2();
}

float PetDeedAdapter::getCleverness() const {
	return (static_cast<PetDeed*>(stub))->getCleverness();
}

float PetDeedAdapter::getEndurance() const {
	return (static_cast<PetDeed*>(stub))->getEndurance();
}

float PetDeedAdapter::getFierceness() const {
	return (static_cast<PetDeed*>(stub))->getFierceness();
}

float PetDeedAdapter::getPower() const {
	return (static_cast<PetDeed*>(stub))->getPower();
}

float PetDeedAdapter::getIntellect() const {
	return (static_cast<PetDeed*>(stub))->getIntellect();
}

float PetDeedAdapter::getCourage() const {
	return (static_cast<PetDeed*>(stub))->getCourage();
}

float PetDeedAdapter::getDependability() const {
	return (static_cast<PetDeed*>(stub))->getDependability();
}

float PetDeedAdapter::getDexterity() const {
	return (static_cast<PetDeed*>(stub))->getDexterity();
}

float PetDeedAdapter::getFortitude() const {
	return (static_cast<PetDeed*>(stub))->getFortitude();
}

float PetDeedAdapter::getHardiness() const {
	return (static_cast<PetDeed*>(stub))->getHardiness();
}

/*
 *	PetDeedHelper
 */

PetDeedHelper* PetDeedHelper::staticInitializer = PetDeedHelper::instance();

PetDeedHelper::PetDeedHelper() {
	className = "PetDeed";

	Core::getObjectBroker()->registerClass(className, this);
}

void PetDeedHelper::finalizeHelper() {
	PetDeedHelper::finalize();
}

DistributedObject* PetDeedHelper::instantiateObject() {
	return new PetDeed(DummyConstructorParameter::instance());
}

DistributedObjectServant* PetDeedHelper::instantiateServant() {
	return new PetDeedImplementation();
}

DistributedObjectPOD* PetDeedHelper::instantiatePOD() {
	return new PetDeedPOD();
}

DistributedObjectAdapter* PetDeedHelper::createAdapter(DistributedObjectStub* obj) {
	DistributedObjectAdapter* adapter = new PetDeedAdapter(static_cast<PetDeed*>(obj));

	obj->_setClassName(className);
	obj->_setClassHelper(this);

	adapter->setStub(obj);

	return adapter;
}

/*
 *	PetDeedPOD
 */

PetDeedPOD::~PetDeedPOD() {
	finalize();
}

PetDeedPOD::PetDeedPOD(void) {
	_className = "PetDeed";
}


void PetDeedPOD::writeJSON(nlohmann::json& j) {
	DeedPOD::writeJSON(j);

	nlohmann::json thisObject = nlohmann::json::object();
	if (quality)
		thisObject["quality"] = quality.value();

	if (level)
		thisObject["level"] = level.value();

	if (chanceHit)
		thisObject["chanceHit"] = chanceHit.value();

	if (attackSpeed)
		thisObject["attackSpeed"] = attackSpeed.value();

	if (damageMin)
		thisObject["damageMin"] = damageMin.value();

	if (damageMax)
		thisObject["damageMax"] = damageMax.value();

	if (armor)
		thisObject["armor"] = armor.value();

	if (kinResist)
		thisObject["kinResist"] = kinResist.value();

	if (energyResist)
		thisObject["energyResist"] = energyResist.value();

	if (blastResist)
		thisObject["blastResist"] = blastResist.value();

	if (coldResist)
		thisObject["coldResist"] = coldResist.value();

	if (heatResist)
		thisObject["heatResist"] = heatResist.value();

	if (elecResist)
		thisObject["elecResist"] = elecResist.value();

	if (acidResist)
		thisObject["acidResist"] = acidResist.value();

	if (stunResist)
		thisObject["stunResist"] = stunResist.value();

	if (saberResist)
		thisObject["saberResist"] = saberResist.value();

	if (health)
		thisObject["health"] = health.value();

	if (action)
		thisObject["action"] = action.value();

	if (mind)
		thisObject["mind"] = mind.value();

	if (regen)
		thisObject["regen"] = regen.value();

	if (special1)
		thisObject["special1"] = special1.value();

	if (special2)
		thisObject["special2"] = special2.value();

	if (ranged)
		thisObject["ranged"] = ranged.value();

	if (controlDeviceObjectTemplate)
		thisObject["controlDeviceObjectTemplate"] = controlDeviceObjectTemplate.value();

	if (mobileTemplate)
		thisObject["mobileTemplate"] = mobileTemplate.value();

	if (cleverness)
		thisObject["cleverness"] = cleverness.value();

	if (endurance)
		thisObject["endurance"] = endurance.value();

	if (fierceness)
		thisObject["fierceness"] = fierceness.value();

	if (power)
		thisObject["power"] = power.value();

	if (intellect)
		thisObject["intellect"] = intellect.value();

	if (courage)
		thisObject["courage"] = courage.value();

	if (dependability)
		thisObject["dependability"] = dependability.value();

	if (dexterity)
		thisObject["dexterity"] = dexterity.value();

	if (fortitude)
		thisObject["fortitude"] = fortitude.value();

	if (hardiness)
		thisObject["hardiness"] = hardiness.value();

	if (sampleCount)
		thisObject["sampleCount"] = sampleCount.value();

	if (specialResists)
		thisObject["specialResists"] = specialResists.value();

	if (attacks)
		thisObject["attacks"] = attacks.value();

	j["PetDeed"] = thisObject;
}


void PetDeedPOD::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = PetDeedPOD::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int PetDeedPOD::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = DeedPOD::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	if (quality) {
	_nameHashCode = 0x4b7dc854; //PetDeed.quality
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&quality.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (level) {
	_nameHashCode = 0xfacef493; //PetDeed.level
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&level.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (chanceHit) {
	_nameHashCode = 0xcc2fc84d; //PetDeed.chanceHit
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&chanceHit.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (attackSpeed) {
	_nameHashCode = 0x3f1c3cb0; //PetDeed.attackSpeed
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&attackSpeed.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (damageMin) {
	_nameHashCode = 0x36bbae6; //PetDeed.damageMin
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&damageMin.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (damageMax) {
	_nameHashCode = 0xdfb46f76; //PetDeed.damageMax
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&damageMax.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (armor) {
	_nameHashCode = 0x724b3bb5; //PetDeed.armor
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&armor.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (kinResist) {
	_nameHashCode = 0x6c400b95; //PetDeed.kinResist
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&kinResist.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (energyResist) {
	_nameHashCode = 0x74ad1e50; //PetDeed.energyResist
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&energyResist.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (blastResist) {
	_nameHashCode = 0xcc571853; //PetDeed.blastResist
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&blastResist.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (coldResist) {
	_nameHashCode = 0xacf0b4a4; //PetDeed.coldResist
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&coldResist.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (heatResist) {
	_nameHashCode = 0x539aeeb7; //PetDeed.heatResist
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&heatResist.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (elecResist) {
	_nameHashCode = 0xd758b406; //PetDeed.elecResist
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&elecResist.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (acidResist) {
	_nameHashCode = 0xd3f4d7fc; //PetDeed.acidResist
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&acidResist.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (stunResist) {
	_nameHashCode = 0xc857a962; //PetDeed.stunResist
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&stunResist.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (saberResist) {
	_nameHashCode = 0xce82cd9d; //PetDeed.saberResist
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&saberResist.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (health) {
	_nameHashCode = 0x41ae256d; //PetDeed.health
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&health.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (action) {
	_nameHashCode = 0x926a20e6; //PetDeed.action
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&action.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (mind) {
	_nameHashCode = 0x8d871551; //PetDeed.mind
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&mind.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (regen) {
	_nameHashCode = 0x9fcbee99; //PetDeed.regen
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&regen.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (special1) {
	_nameHashCode = 0x887f0773; //PetDeed.special1
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&special1.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (special2) {
	_nameHashCode = 0x853c21aa; //PetDeed.special2
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&special2.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (ranged) {
	_nameHashCode = 0x268b2b92; //PetDeed.ranged
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&ranged.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (controlDeviceObjectTemplate) {
	_nameHashCode = 0x5fe2df88; //PetDeed.controlDeviceObjectTemplate
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&controlDeviceObjectTemplate.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (mobileTemplate) {
	_nameHashCode = 0x876bd86e; //PetDeed.mobileTemplate
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&mobileTemplate.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (cleverness) {
	_nameHashCode = 0x17add007; //PetDeed.cleverness
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&cleverness.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (endurance) {
	_nameHashCode = 0xeb9fff0d; //PetDeed.endurance
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&endurance.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (fierceness) {
	_nameHashCode = 0xb0e1584e; //PetDeed.fierceness
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&fierceness.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (power) {
	_nameHashCode = 0x2cb61934; //PetDeed.power
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&power.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (intellect) {
	_nameHashCode = 0x9d7412df; //PetDeed.intellect
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&intellect.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (courage) {
	_nameHashCode = 0x12a5e8ab; //PetDeed.courage
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&courage.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (dependability) {
	_nameHashCode = 0x898537fe; //PetDeed.dependability
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&dependability.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (dexterity) {
	_nameHashCode = 0x22d48997; //PetDeed.dexterity
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&dexterity.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (fortitude) {
	_nameHashCode = 0x90df2a88; //PetDeed.fortitude
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&fortitude.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (hardiness) {
	_nameHashCode = 0x5ab3092e; //PetDeed.hardiness
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&hardiness.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (sampleCount) {
	_nameHashCode = 0x7c55a5ed; //PetDeed.sampleCount
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&sampleCount.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (specialResists) {
	_nameHashCode = 0x41917681; //PetDeed.specialResists
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&specialResists.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (attacks) {
	_nameHashCode = 0x8a56db81; //PetDeed.attacks
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<CreatureAttackMap >::toBinaryStream(&attacks.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}


	return _count;
}

bool PetDeedPOD::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (DeedPOD::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0x4b7dc854: //PetDeed.quality
		{
			int _mnquality;
			TypeInfo<int >::parseFromBinaryStream(&_mnquality, stream);
			quality = std::move(_mnquality);
		}
		return true;

	case 0xfacef493: //PetDeed.level
		{
			int _mnlevel;
			TypeInfo<int >::parseFromBinaryStream(&_mnlevel, stream);
			level = std::move(_mnlevel);
		}
		return true;

	case 0xcc2fc84d: //PetDeed.chanceHit
		{
			float _mnchanceHit;
			TypeInfo<float >::parseFromBinaryStream(&_mnchanceHit, stream);
			chanceHit = std::move(_mnchanceHit);
		}
		return true;

	case 0x3f1c3cb0: //PetDeed.attackSpeed
		{
			float _mnattackSpeed;
			TypeInfo<float >::parseFromBinaryStream(&_mnattackSpeed, stream);
			attackSpeed = std::move(_mnattackSpeed);
		}
		return true;

	case 0x36bbae6: //PetDeed.damageMin
		{
			int _mndamageMin;
			TypeInfo<int >::parseFromBinaryStream(&_mndamageMin, stream);
			damageMin = std::move(_mndamageMin);
		}
		return true;

	case 0xdfb46f76: //PetDeed.damageMax
		{
			int _mndamageMax;
			TypeInfo<int >::parseFromBinaryStream(&_mndamageMax, stream);
			damageMax = std::move(_mndamageMax);
		}
		return true;

	case 0x724b3bb5: //PetDeed.armor
		{
			int _mnarmor;
			TypeInfo<int >::parseFromBinaryStream(&_mnarmor, stream);
			armor = std::move(_mnarmor);
		}
		return true;

	case 0x6c400b95: //PetDeed.kinResist
		{
			float _mnkinResist;
			TypeInfo<float >::parseFromBinaryStream(&_mnkinResist, stream);
			kinResist = std::move(_mnkinResist);
		}
		return true;

	case 0x74ad1e50: //PetDeed.energyResist
		{
			float _mnenergyResist;
			TypeInfo<float >::parseFromBinaryStream(&_mnenergyResist, stream);
			energyResist = std::move(_mnenergyResist);
		}
		return true;

	case 0xcc571853: //PetDeed.blastResist
		{
			float _mnblastResist;
			TypeInfo<float >::parseFromBinaryStream(&_mnblastResist, stream);
			blastResist = std::move(_mnblastResist);
		}
		return true;

	case 0xacf0b4a4: //PetDeed.coldResist
		{
			float _mncoldResist;
			TypeInfo<float >::parseFromBinaryStream(&_mncoldResist, stream);
			coldResist = std::move(_mncoldResist);
		}
		return true;

	case 0x539aeeb7: //PetDeed.heatResist
		{
			float _mnheatResist;
			TypeInfo<float >::parseFromBinaryStream(&_mnheatResist, stream);
			heatResist = std::move(_mnheatResist);
		}
		return true;

	case 0xd758b406: //PetDeed.elecResist
		{
			float _mnelecResist;
			TypeInfo<float >::parseFromBinaryStream(&_mnelecResist, stream);
			elecResist = std::move(_mnelecResist);
		}
		return true;

	case 0xd3f4d7fc: //PetDeed.acidResist
		{
			float _mnacidResist;
			TypeInfo<float >::parseFromBinaryStream(&_mnacidResist, stream);
			acidResist = std::move(_mnacidResist);
		}
		return true;

	case 0xc857a962: //PetDeed.stunResist
		{
			float _mnstunResist;
			TypeInfo<float >::parseFromBinaryStream(&_mnstunResist, stream);
			stunResist = std::move(_mnstunResist);
		}
		return true;

	case 0xce82cd9d: //PetDeed.saberResist
		{
			float _mnsaberResist;
			TypeInfo<float >::parseFromBinaryStream(&_mnsaberResist, stream);
			saberResist = std::move(_mnsaberResist);
		}
		return true;

	case 0x41ae256d: //PetDeed.health
		{
			int _mnhealth;
			TypeInfo<int >::parseFromBinaryStream(&_mnhealth, stream);
			health = std::move(_mnhealth);
		}
		return true;

	case 0x926a20e6: //PetDeed.action
		{
			int _mnaction;
			TypeInfo<int >::parseFromBinaryStream(&_mnaction, stream);
			action = std::move(_mnaction);
		}
		return true;

	case 0x8d871551: //PetDeed.mind
		{
			int _mnmind;
			TypeInfo<int >::parseFromBinaryStream(&_mnmind, stream);
			mind = std::move(_mnmind);
		}
		return true;

	case 0x9fcbee99: //PetDeed.regen
		{
			int _mnregen;
			TypeInfo<int >::parseFromBinaryStream(&_mnregen, stream);
			regen = std::move(_mnregen);
		}
		return true;

	case 0x887f0773: //PetDeed.special1
		{
			String _mnspecial1;
			TypeInfo<String >::parseFromBinaryStream(&_mnspecial1, stream);
			special1 = std::move(_mnspecial1);
		}
		return true;

	case 0x853c21aa: //PetDeed.special2
		{
			String _mnspecial2;
			TypeInfo<String >::parseFromBinaryStream(&_mnspecial2, stream);
			special2 = std::move(_mnspecial2);
		}
		return true;

	case 0x268b2b92: //PetDeed.ranged
		{
			bool _mnranged;
			TypeInfo<bool >::parseFromBinaryStream(&_mnranged, stream);
			ranged = std::move(_mnranged);
		}
		return true;

	case 0x5fe2df88: //PetDeed.controlDeviceObjectTemplate
		{
			String _mncontrolDeviceObjectTemplate;
			TypeInfo<String >::parseFromBinaryStream(&_mncontrolDeviceObjectTemplate, stream);
			controlDeviceObjectTemplate = std::move(_mncontrolDeviceObjectTemplate);
		}
		return true;

	case 0x876bd86e: //PetDeed.mobileTemplate
		{
			String _mnmobileTemplate;
			TypeInfo<String >::parseFromBinaryStream(&_mnmobileTemplate, stream);
			mobileTemplate = std::move(_mnmobileTemplate);
		}
		return true;

	case 0x17add007: //PetDeed.cleverness
		{
			float _mncleverness;
			TypeInfo<float >::parseFromBinaryStream(&_mncleverness, stream);
			cleverness = std::move(_mncleverness);
		}
		return true;

	case 0xeb9fff0d: //PetDeed.endurance
		{
			float _mnendurance;
			TypeInfo<float >::parseFromBinaryStream(&_mnendurance, stream);
			endurance = std::move(_mnendurance);
		}
		return true;

	case 0xb0e1584e: //PetDeed.fierceness
		{
			float _mnfierceness;
			TypeInfo<float >::parseFromBinaryStream(&_mnfierceness, stream);
			fierceness = std::move(_mnfierceness);
		}
		return true;

	case 0x2cb61934: //PetDeed.power
		{
			float _mnpower;
			TypeInfo<float >::parseFromBinaryStream(&_mnpower, stream);
			power = std::move(_mnpower);
		}
		return true;

	case 0x9d7412df: //PetDeed.intellect
		{
			float _mnintellect;
			TypeInfo<float >::parseFromBinaryStream(&_mnintellect, stream);
			intellect = std::move(_mnintellect);
		}
		return true;

	case 0x12a5e8ab: //PetDeed.courage
		{
			float _mncourage;
			TypeInfo<float >::parseFromBinaryStream(&_mncourage, stream);
			courage = std::move(_mncourage);
		}
		return true;

	case 0x898537fe: //PetDeed.dependability
		{
			float _mndependability;
			TypeInfo<float >::parseFromBinaryStream(&_mndependability, stream);
			dependability = std::move(_mndependability);
		}
		return true;

	case 0x22d48997: //PetDeed.dexterity
		{
			float _mndexterity;
			TypeInfo<float >::parseFromBinaryStream(&_mndexterity, stream);
			dexterity = std::move(_mndexterity);
		}
		return true;

	case 0x90df2a88: //PetDeed.fortitude
		{
			float _mnfortitude;
			TypeInfo<float >::parseFromBinaryStream(&_mnfortitude, stream);
			fortitude = std::move(_mnfortitude);
		}
		return true;

	case 0x5ab3092e: //PetDeed.hardiness
		{
			float _mnhardiness;
			TypeInfo<float >::parseFromBinaryStream(&_mnhardiness, stream);
			hardiness = std::move(_mnhardiness);
		}
		return true;

	case 0x7c55a5ed: //PetDeed.sampleCount
		{
			int _mnsampleCount;
			TypeInfo<int >::parseFromBinaryStream(&_mnsampleCount, stream);
			sampleCount = std::move(_mnsampleCount);
		}
		return true;

	case 0x41917681: //PetDeed.specialResists
		{
			int _mnspecialResists;
			TypeInfo<int >::parseFromBinaryStream(&_mnspecialResists, stream);
			specialResists = std::move(_mnspecialResists);
		}
		return true;

	case 0x8a56db81: //PetDeed.attacks
		{
			CreatureAttackMap _mnattacks;
			TypeInfo<CreatureAttackMap >::parseFromBinaryStream(&_mnattacks, stream);
			attacks = std::move(_mnattacks);
		}
		return true;

	}

	return false;
}

void PetDeedPOD::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(PetDeedPOD::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

}

void PetDeedPOD::writeObjectCompact(ObjectOutputStream* stream) {
	DeedPOD::writeObjectCompact(stream);

	TypeInfo<int >::toBinaryStream(&quality.value(), stream);

	TypeInfo<int >::toBinaryStream(&level.value(), stream);

	TypeInfo<float >::toBinaryStream(&chanceHit.value(), stream);

	TypeInfo<float >::toBinaryStream(&attackSpeed.value(), stream);

	TypeInfo<int >::toBinaryStream(&damageMin.value(), stream);

	TypeInfo<int >::toBinaryStream(&damageMax.value(), stream);

	TypeInfo<int >::toBinaryStream(&armor.value(), stream);

	TypeInfo<float >::toBinaryStream(&kinResist.value(), stream);

	TypeInfo<float >::toBinaryStream(&energyResist.value(), stream);

	TypeInfo<float >::toBinaryStream(&blastResist.value(), stream);

	TypeInfo<float >::toBinaryStream(&coldResist.value(), stream);

	TypeInfo<float >::toBinaryStream(&heatResist.value(), stream);

	TypeInfo<float >::toBinaryStream(&elecResist.value(), stream);

	TypeInfo<float >::toBinaryStream(&acidResist.value(), stream);

	TypeInfo<float >::toBinaryStream(&stunResist.value(), stream);

	TypeInfo<float >::toBinaryStream(&saberResist.value(), stream);

	TypeInfo<int >::toBinaryStream(&health.value(), stream);

	TypeInfo<int >::toBinaryStream(&action.value(), stream);

	TypeInfo<int >::toBinaryStream(&mind.value(), stream);

	TypeInfo<int >::toBinaryStream(&regen.value(), stream);

	TypeInfo<String >::toBinaryStream(&special1.value(), stream);

	TypeInfo<String >::toBinaryStream(&special2.value(), stream);

	TypeInfo<bool >::toBinaryStream(&ranged.value(), stream);

	TypeInfo<String >::toBinaryStream(&controlDeviceObjectTemplate.value(), stream);

	TypeInfo<String >::toBinaryStream(&mobileTemplate.value(), stream);

	TypeInfo<float >::toBinaryStream(&cleverness.value(), stream);

	TypeInfo<float >::toBinaryStream(&endurance.value(), stream);

	TypeInfo<float >::toBinaryStream(&fierceness.value(), stream);

	TypeInfo<float >::toBinaryStream(&power.value(), stream);

	TypeInfo<float >::toBinaryStream(&intellect.value(), stream);

	TypeInfo<float >::toBinaryStream(&courage.value(), stream);

	TypeInfo<float >::toBinaryStream(&dependability.value(), stream);

	TypeInfo<float >::toBinaryStream(&dexterity.value(), stream);

	TypeInfo<float >::toBinaryStream(&fortitude.value(), stream);

	TypeInfo<float >::toBinaryStream(&hardiness.value(), stream);

	TypeInfo<int >::toBinaryStream(&sampleCount.value(), stream);

	TypeInfo<int >::toBinaryStream(&specialResists.value(), stream);

	TypeInfo<CreatureAttackMap >::toBinaryStream(&attacks.value(), stream);


}

