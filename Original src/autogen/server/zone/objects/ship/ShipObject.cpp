/*
 *	autogen/server/zone/objects/ship/ShipObject.cpp generated by engine3 IDL compiler 0.70
 */

#include "ShipObject.h"

/*
 *	ShipObjectStub
 */

enum {RPC_GETUNIQUEID__ = 2034796776,RPC_INITIALIZETRANSIENTMEMBERS__,RPC_SENDTO__SCENEOBJECT_BOOL_BOOL_,RPC_SENDBASELINESTO__SCENEOBJECT_,RPC_SETMAXYAWACCELERATION__FLOAT_BOOL_,RPC_SETCURRENTYAWACCELERATION__FLOAT_BOOL_,RPC_SETMAXPITCHACCELERATION__FLOAT_BOOL_,RPC_SETCURRENTPITCHACCELERATION__FLOAT_BOOL_,RPC_SETMAXROLLACCELERATION__FLOAT_BOOL_,RPC_SETCURRENTROLLACCELERATION__FLOAT_BOOL_,RPC_GETMAXYAWACCELERATION__,RPC_GETMAXROLLACCELERATION__,RPC_GETMAXPITCHACCELERATION__,RPC_GETTOTALMASS__,RPC_GETMAXSPEED__,RPC_ISSHIPOBJECT__};

ShipObject::ShipObject() : TangibleObject(DummyConstructorParameter::instance()) {
	ShipObjectImplementation* _implementation = new ShipObjectImplementation();
	_impl = _implementation;
	_impl->_setStub(this);
	_setClassName("ShipObject");
}

ShipObject::ShipObject(DummyConstructorParameter* param) : TangibleObject(param) {
	_setClassName("ShipObject");
}

ShipObject::~ShipObject() {
}



unsigned short ShipObject::getUniqueID() {
	ShipObjectImplementation* _implementation = static_cast<ShipObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETUNIQUEID__);

		return method.executeWithUnsignedShortReturn();
	} else {
		return _implementation->getUniqueID();
	}
}

void ShipObject::initializeTransientMembers() {
	ShipObjectImplementation* _implementation = static_cast<ShipObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INITIALIZETRANSIENTMEMBERS__);

		method.executeWithVoidReturn();
	} else {
		_implementation->initializeTransientMembers();
	}
}

void ShipObject::sendTo(SceneObject* player, bool doClose, bool forceLoadContainer) {
	ShipObjectImplementation* _implementation = static_cast<ShipObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDTO__SCENEOBJECT_BOOL_BOOL_);
		method.addObjectParameter(player);
		method.addBooleanParameter(doClose);
		method.addBooleanParameter(forceLoadContainer);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendTo(player, doClose, forceLoadContainer);
	}
}

void ShipObject::sendBaselinesTo(SceneObject* player) {
	ShipObjectImplementation* _implementation = static_cast<ShipObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDBASELINESTO__SCENEOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendBaselinesTo(player);
	}
}

void ShipObject::setMaxYawAcceleration(float radians, bool notifyClient) {
	ShipObjectImplementation* _implementation = static_cast<ShipObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETMAXYAWACCELERATION__FLOAT_BOOL_);
		method.addFloatParameter(radians);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->setMaxYawAcceleration(radians, notifyClient);
	}
}

void ShipObject::setCurrentYawAcceleration(float scale, bool notifyClient) {
	ShipObjectImplementation* _implementation = static_cast<ShipObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCURRENTYAWACCELERATION__FLOAT_BOOL_);
		method.addFloatParameter(scale);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->setCurrentYawAcceleration(scale, notifyClient);
	}
}

void ShipObject::setMaxPitchAcceleration(float radians, bool notifyClient) {
	ShipObjectImplementation* _implementation = static_cast<ShipObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETMAXPITCHACCELERATION__FLOAT_BOOL_);
		method.addFloatParameter(radians);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->setMaxPitchAcceleration(radians, notifyClient);
	}
}

void ShipObject::setCurrentPitchAcceleration(float scale, bool notifyClient) {
	ShipObjectImplementation* _implementation = static_cast<ShipObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCURRENTPITCHACCELERATION__FLOAT_BOOL_);
		method.addFloatParameter(scale);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->setCurrentPitchAcceleration(scale, notifyClient);
	}
}

void ShipObject::setMaxRollAcceleration(float radians, bool notifyClient) {
	ShipObjectImplementation* _implementation = static_cast<ShipObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETMAXROLLACCELERATION__FLOAT_BOOL_);
		method.addFloatParameter(radians);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->setMaxRollAcceleration(radians, notifyClient);
	}
}

void ShipObject::setCurrentRollAcceleration(float scale, bool notifyClient) {
	ShipObjectImplementation* _implementation = static_cast<ShipObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCURRENTROLLACCELERATION__FLOAT_BOOL_);
		method.addFloatParameter(scale);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->setCurrentRollAcceleration(scale, notifyClient);
	}
}

float ShipObject::getMaxYawAcceleration() const {
	ShipObjectImplementation* _implementation = static_cast<ShipObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMAXYAWACCELERATION__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getMaxYawAcceleration();
	}
}

float ShipObject::getMaxRollAcceleration() const {
	ShipObjectImplementation* _implementation = static_cast<ShipObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMAXROLLACCELERATION__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getMaxRollAcceleration();
	}
}

float ShipObject::getMaxPitchAcceleration() const {
	ShipObjectImplementation* _implementation = static_cast<ShipObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMAXPITCHACCELERATION__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getMaxPitchAcceleration();
	}
}

float ShipObject::getTotalMass() const {
	ShipObjectImplementation* _implementation = static_cast<ShipObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETTOTALMASS__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getTotalMass();
	}
}

float ShipObject::getMaxSpeed() const {
	ShipObjectImplementation* _implementation = static_cast<ShipObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMAXSPEED__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getMaxSpeed();
	}
}

bool ShipObject::isShipObject() {
	ShipObjectImplementation* _implementation = static_cast<ShipObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISSHIPOBJECT__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isShipObject();
	}
}

DistributedObjectServant* ShipObject::_getImplementation() {

	 if (!_updated) _updated = true;
	return _impl;
}

DistributedObjectServant* ShipObject::_getImplementationForRead() const {
	return _impl;
}

void ShipObject::_setImplementation(DistributedObjectServant* servant) {
	_impl = servant;
}

/*
 *	ShipObjectImplementation
 */

ShipObjectImplementation::ShipObjectImplementation(DummyConstructorParameter* param) : TangibleObjectImplementation(param) {
	_initializeImplementation();
}


ShipObjectImplementation::~ShipObjectImplementation() {
}


void ShipObjectImplementation::finalize() {
}

void ShipObjectImplementation::_initializeImplementation() {
	_setClassHelper(ShipObjectHelper::instance());

	_this = NULL;

	_serializationHelperMethod();
}

void ShipObjectImplementation::_setStub(DistributedObjectStub* stub) {
	_this = static_cast<ShipObject*>(stub);
	TangibleObjectImplementation::_setStub(stub);
}

DistributedObjectStub* ShipObjectImplementation::_getStub() {
	return _this.get();
}

ShipObjectImplementation::operator const ShipObject*() {
	return _this.get();
}

void ShipObjectImplementation::lock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->lock(doLock);
}

void ShipObjectImplementation::lock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->lock(obj);
}

void ShipObjectImplementation::rlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->rlock(doLock);
}

void ShipObjectImplementation::wlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->wlock(doLock);
}

void ShipObjectImplementation::wlock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->wlock(obj);
}

void ShipObjectImplementation::unlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->unlock(doLock);
}

void ShipObjectImplementation::runlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->runlock(doLock);
}

void ShipObjectImplementation::_serializationHelperMethod() {
	TangibleObjectImplementation::_serializationHelperMethod();

	_setClassName("ShipObject");

}

void ShipObjectImplementation::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(ShipObjectImplementation::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

	initializeTransientMembers();
}

bool ShipObjectImplementation::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (TangibleObjectImplementation::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0x6222f244: //ShipObject.totalMass
		TypeInfo<float >::parseFromBinaryStream(&totalMass, stream);
		return true;

	case 0x434bee0: //ShipObject.currentMass
		TypeInfo<float >::parseFromBinaryStream(&currentMass, stream);
		return true;

	case 0x7d4f2cad: //ShipObject.maxYawAcceleration
		TypeInfo<DeltaFloatVariable<'SHIP', 6, 6 > >::parseFromBinaryStream(&maxYawAcceleration, stream);
		return true;

	case 0xe42a3c32: //ShipObject.maxPitchAcceleration
		TypeInfo<DeltaFloatVariable<'SHIP', 6, 7 > >::parseFromBinaryStream(&maxPitchAcceleration, stream);
		return true;

	case 0x6fb8bb20: //ShipObject.maxRollAcceleration
		TypeInfo<DeltaFloatVariable<'SHIP', 6, 8 > >::parseFromBinaryStream(&maxRollAcceleration, stream);
		return true;

	case 0xb433abef: //ShipObject.currentYawAcceleration
		TypeInfo<DeltaFloatVariable<'SHIP', 6, 9 > >::parseFromBinaryStream(&currentYawAcceleration, stream);
		return true;

	case 0x2d4b8ceb: //ShipObject.currentPitchAcceleration
		TypeInfo<DeltaFloatVariable<'SHIP', 6, 10 > >::parseFromBinaryStream(&currentPitchAcceleration, stream);
		return true;

	case 0x6c7c99b6: //ShipObject.currentRollAcceleration
		TypeInfo<DeltaFloatVariable<'SHIP', 6, 11 > >::parseFromBinaryStream(&currentRollAcceleration, stream);
		return true;

	case 0x7beb957b: //ShipObject.maxSpeed
		TypeInfo<float >::parseFromBinaryStream(&maxSpeed, stream);
		return true;

	case 0x8d78ea3: //ShipObject.shipComponents
		TypeInfo<DeltaVectorMap<unsigned int, unsigned int> >::parseFromBinaryStream(&shipComponents, stream);
		return true;

	}

	return false;
}

void ShipObjectImplementation::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = ShipObjectImplementation::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int ShipObjectImplementation::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = TangibleObjectImplementation::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	_nameHashCode = 0x6222f244; //ShipObject.totalMass
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&totalMass, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x434bee0; //ShipObject.currentMass
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&currentMass, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x7d4f2cad; //ShipObject.maxYawAcceleration
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<DeltaFloatVariable<'SHIP', 6, 6 > >::toBinaryStream(&maxYawAcceleration, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xe42a3c32; //ShipObject.maxPitchAcceleration
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<DeltaFloatVariable<'SHIP', 6, 7 > >::toBinaryStream(&maxPitchAcceleration, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x6fb8bb20; //ShipObject.maxRollAcceleration
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<DeltaFloatVariable<'SHIP', 6, 8 > >::toBinaryStream(&maxRollAcceleration, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xb433abef; //ShipObject.currentYawAcceleration
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<DeltaFloatVariable<'SHIP', 6, 9 > >::toBinaryStream(&currentYawAcceleration, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x2d4b8ceb; //ShipObject.currentPitchAcceleration
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<DeltaFloatVariable<'SHIP', 6, 10 > >::toBinaryStream(&currentPitchAcceleration, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x6c7c99b6; //ShipObject.currentRollAcceleration
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<DeltaFloatVariable<'SHIP', 6, 11 > >::toBinaryStream(&currentRollAcceleration, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x7beb957b; //ShipObject.maxSpeed
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&maxSpeed, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x8d78ea3; //ShipObject.shipComponents
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<DeltaVectorMap<unsigned int, unsigned int> >::toBinaryStream(&shipComponents, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;


	return _count;
}

ShipObjectImplementation::ShipObjectImplementation() {
	_initializeImplementation();
	Reference<CloseObjectsVector*> _ref0;
	// server/zone/objects/ship/ShipObject.idl():  		Logger.setLoggingName("ShipObject");
	Logger::setLoggingName("ShipObject");
	// server/zone/objects/ship/ShipObject.idl():  		super.objectVisible = 1;
	TangibleObjectImplementation::objectVisible = 1;
	// server/zone/objects/ship/ShipObject.idl():  		totalMass = 500.0;
	totalMass = 500.0;
	// server/zone/objects/ship/ShipObject.idl():  		super.closeobjects = new CloseObjectsVector();
	TangibleObjectImplementation::closeobjects = _ref0 = new CloseObjectsVector();
	// server/zone/objects/ship/ShipObject.idl():  		super.closeobjects.setNoDuplicateInsertPlan();
	TangibleObjectImplementation::closeobjects->setNoDuplicateInsertPlan();
}

void ShipObjectImplementation::setMaxYawAcceleration(float radians, bool notifyClient) {
	// server/zone/objects/ship/ShipObject.idl():  		maxYawAcceleration.update(radians, notifyClient, this);
	(&maxYawAcceleration)->update(radians, notifyClient, _this.getReferenceUnsafeStaticCast());
}

void ShipObjectImplementation::setCurrentYawAcceleration(float scale, bool notifyClient) {
	// server/zone/objects/ship/ShipObject.idl():  		currentYawAcceleration.update(scale, notifyClient, this);
	(&currentYawAcceleration)->update(scale, notifyClient, _this.getReferenceUnsafeStaticCast());
}

void ShipObjectImplementation::setMaxPitchAcceleration(float radians, bool notifyClient) {
	// server/zone/objects/ship/ShipObject.idl():  		maxPitchAcceleration.update(radians, notifyClient, this);
	(&maxPitchAcceleration)->update(radians, notifyClient, _this.getReferenceUnsafeStaticCast());
}

void ShipObjectImplementation::setCurrentPitchAcceleration(float scale, bool notifyClient) {
	// server/zone/objects/ship/ShipObject.idl():  		currentPitchAcceleration.update(scale, notifyClient, this);
	(&currentPitchAcceleration)->update(scale, notifyClient, _this.getReferenceUnsafeStaticCast());
}

void ShipObjectImplementation::setMaxRollAcceleration(float radians, bool notifyClient) {
	// server/zone/objects/ship/ShipObject.idl():  		maxRollAcceleration.update(radians, notifyClient, this);
	(&maxRollAcceleration)->update(radians, notifyClient, _this.getReferenceUnsafeStaticCast());
}

void ShipObjectImplementation::setCurrentRollAcceleration(float scale, bool notifyClient) {
	// server/zone/objects/ship/ShipObject.idl():  		currentRollAcceleration.update(scale, notifyClient, this);
	(&currentRollAcceleration)->update(scale, notifyClient, _this.getReferenceUnsafeStaticCast());
}

float ShipObjectImplementation::getMaxYawAcceleration() const{
	// server/zone/objects/ship/ShipObject.idl():  		return maxYawAcceleration.get();
	return (&maxYawAcceleration)->get();
}

float ShipObjectImplementation::getMaxRollAcceleration() const{
	// server/zone/objects/ship/ShipObject.idl():  		return maxRollAcceleration.get();
	return (&maxRollAcceleration)->get();
}

float ShipObjectImplementation::getMaxPitchAcceleration() const{
	// server/zone/objects/ship/ShipObject.idl():  		return maxPitchAcceleration.get();
	return (&maxPitchAcceleration)->get();
}

float ShipObjectImplementation::getTotalMass() const{
	// server/zone/objects/ship/ShipObject.idl():  		return totalMass;
	return totalMass;
}

float ShipObjectImplementation::getMaxSpeed() const{
	// server/zone/objects/ship/ShipObject.idl():  		return maxSpeed;
	return maxSpeed;
}

bool ShipObjectImplementation::isShipObject() {
	// server/zone/objects/ship/ShipObject.idl():  		return true;
	return true;
}

/*
 *	ShipObjectAdapter
 */


#include "engine/orb/messages/InvokeMethodMessage.h"


ShipObjectAdapter::ShipObjectAdapter(ShipObject* obj) : TangibleObjectAdapter(obj) {
}

void ShipObjectAdapter::invokeMethod(uint32 methid, DistributedMethod* inv) {
	DOBMessage* resp = inv->getInvocationMessage();

	switch (methid) {
	case RPC_GETUNIQUEID__:
		{
			
			unsigned short _m_res = getUniqueID();
			resp->insertShort(_m_res);
		}
		break;
	case RPC_INITIALIZETRANSIENTMEMBERS__:
		{
			
			initializeTransientMembers();
			
		}
		break;
	case RPC_SENDTO__SCENEOBJECT_BOOL_BOOL_:
		{
			SceneObject* player = static_cast<SceneObject*>(inv->getObjectParameter());
			bool doClose = inv->getBooleanParameter();
			bool forceLoadContainer = inv->getBooleanParameter();
			
			sendTo(player, doClose, forceLoadContainer);
			
		}
		break;
	case RPC_SENDBASELINESTO__SCENEOBJECT_:
		{
			SceneObject* player = static_cast<SceneObject*>(inv->getObjectParameter());
			
			sendBaselinesTo(player);
			
		}
		break;
	case RPC_SETMAXYAWACCELERATION__FLOAT_BOOL_:
		{
			float radians = inv->getFloatParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setMaxYawAcceleration(radians, notifyClient);
			
		}
		break;
	case RPC_SETCURRENTYAWACCELERATION__FLOAT_BOOL_:
		{
			float scale = inv->getFloatParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setCurrentYawAcceleration(scale, notifyClient);
			
		}
		break;
	case RPC_SETMAXPITCHACCELERATION__FLOAT_BOOL_:
		{
			float radians = inv->getFloatParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setMaxPitchAcceleration(radians, notifyClient);
			
		}
		break;
	case RPC_SETCURRENTPITCHACCELERATION__FLOAT_BOOL_:
		{
			float scale = inv->getFloatParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setCurrentPitchAcceleration(scale, notifyClient);
			
		}
		break;
	case RPC_SETMAXROLLACCELERATION__FLOAT_BOOL_:
		{
			float radians = inv->getFloatParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setMaxRollAcceleration(radians, notifyClient);
			
		}
		break;
	case RPC_SETCURRENTROLLACCELERATION__FLOAT_BOOL_:
		{
			float scale = inv->getFloatParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setCurrentRollAcceleration(scale, notifyClient);
			
		}
		break;
	case RPC_GETMAXYAWACCELERATION__:
		{
			
			float _m_res = getMaxYawAcceleration();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETMAXROLLACCELERATION__:
		{
			
			float _m_res = getMaxRollAcceleration();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETMAXPITCHACCELERATION__:
		{
			
			float _m_res = getMaxPitchAcceleration();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETTOTALMASS__:
		{
			
			float _m_res = getTotalMass();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETMAXSPEED__:
		{
			
			float _m_res = getMaxSpeed();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_ISSHIPOBJECT__:
		{
			
			bool _m_res = isShipObject();
			resp->insertBoolean(_m_res);
		}
		break;
	default:
		TangibleObjectAdapter::invokeMethod(methid, inv);
	}
}

unsigned short ShipObjectAdapter::getUniqueID() {
	return (static_cast<ShipObject*>(stub))->getUniqueID();
}

void ShipObjectAdapter::initializeTransientMembers() {
	(static_cast<ShipObject*>(stub))->initializeTransientMembers();
}

void ShipObjectAdapter::sendTo(SceneObject* player, bool doClose, bool forceLoadContainer) {
	(static_cast<ShipObject*>(stub))->sendTo(player, doClose, forceLoadContainer);
}

void ShipObjectAdapter::sendBaselinesTo(SceneObject* player) {
	(static_cast<ShipObject*>(stub))->sendBaselinesTo(player);
}

void ShipObjectAdapter::setMaxYawAcceleration(float radians, bool notifyClient) {
	(static_cast<ShipObject*>(stub))->setMaxYawAcceleration(radians, notifyClient);
}

void ShipObjectAdapter::setCurrentYawAcceleration(float scale, bool notifyClient) {
	(static_cast<ShipObject*>(stub))->setCurrentYawAcceleration(scale, notifyClient);
}

void ShipObjectAdapter::setMaxPitchAcceleration(float radians, bool notifyClient) {
	(static_cast<ShipObject*>(stub))->setMaxPitchAcceleration(radians, notifyClient);
}

void ShipObjectAdapter::setCurrentPitchAcceleration(float scale, bool notifyClient) {
	(static_cast<ShipObject*>(stub))->setCurrentPitchAcceleration(scale, notifyClient);
}

void ShipObjectAdapter::setMaxRollAcceleration(float radians, bool notifyClient) {
	(static_cast<ShipObject*>(stub))->setMaxRollAcceleration(radians, notifyClient);
}

void ShipObjectAdapter::setCurrentRollAcceleration(float scale, bool notifyClient) {
	(static_cast<ShipObject*>(stub))->setCurrentRollAcceleration(scale, notifyClient);
}

float ShipObjectAdapter::getMaxYawAcceleration() const {
	return (static_cast<ShipObject*>(stub))->getMaxYawAcceleration();
}

float ShipObjectAdapter::getMaxRollAcceleration() const {
	return (static_cast<ShipObject*>(stub))->getMaxRollAcceleration();
}

float ShipObjectAdapter::getMaxPitchAcceleration() const {
	return (static_cast<ShipObject*>(stub))->getMaxPitchAcceleration();
}

float ShipObjectAdapter::getTotalMass() const {
	return (static_cast<ShipObject*>(stub))->getTotalMass();
}

float ShipObjectAdapter::getMaxSpeed() const {
	return (static_cast<ShipObject*>(stub))->getMaxSpeed();
}

bool ShipObjectAdapter::isShipObject() {
	return (static_cast<ShipObject*>(stub))->isShipObject();
}

/*
 *	ShipObjectHelper
 */

ShipObjectHelper* ShipObjectHelper::staticInitializer = ShipObjectHelper::instance();

ShipObjectHelper::ShipObjectHelper() {
	className = "ShipObject";

	Core::getObjectBroker()->registerClass(className, this);
}

void ShipObjectHelper::finalizeHelper() {
	ShipObjectHelper::finalize();
}

DistributedObject* ShipObjectHelper::instantiateObject() {
	return new ShipObject(DummyConstructorParameter::instance());
}

DistributedObjectServant* ShipObjectHelper::instantiateServant() {
	return new ShipObjectImplementation();
}

DistributedObjectPOD* ShipObjectHelper::instantiatePOD() {
	return new ShipObjectPOD();
}

DistributedObjectAdapter* ShipObjectHelper::createAdapter(DistributedObjectStub* obj) {
	DistributedObjectAdapter* adapter = new ShipObjectAdapter(static_cast<ShipObject*>(obj));

	obj->_setClassName(className);
	obj->_setClassHelper(this);

	adapter->setStub(obj);

	return adapter;
}

/*
 *	ShipObjectPOD
 */

ShipObjectPOD::~ShipObjectPOD() {
	finalize();
}

ShipObjectPOD::ShipObjectPOD(void) {
	_className = "ShipObject";
}


void ShipObjectPOD::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = ShipObjectPOD::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int ShipObjectPOD::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = TangibleObjectPOD::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	if (totalMass) {
	_nameHashCode = 0x6222f244; //ShipObject.totalMass
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&totalMass.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (currentMass) {
	_nameHashCode = 0x434bee0; //ShipObject.currentMass
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&currentMass.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (maxYawAcceleration) {
	_nameHashCode = 0x7d4f2cad; //ShipObject.maxYawAcceleration
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<DeltaFloatVariable<'SHIP', 6, 6 > >::toBinaryStream(&maxYawAcceleration.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (maxPitchAcceleration) {
	_nameHashCode = 0xe42a3c32; //ShipObject.maxPitchAcceleration
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<DeltaFloatVariable<'SHIP', 6, 7 > >::toBinaryStream(&maxPitchAcceleration.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (maxRollAcceleration) {
	_nameHashCode = 0x6fb8bb20; //ShipObject.maxRollAcceleration
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<DeltaFloatVariable<'SHIP', 6, 8 > >::toBinaryStream(&maxRollAcceleration.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (currentYawAcceleration) {
	_nameHashCode = 0xb433abef; //ShipObject.currentYawAcceleration
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<DeltaFloatVariable<'SHIP', 6, 9 > >::toBinaryStream(&currentYawAcceleration.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (currentPitchAcceleration) {
	_nameHashCode = 0x2d4b8ceb; //ShipObject.currentPitchAcceleration
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<DeltaFloatVariable<'SHIP', 6, 10 > >::toBinaryStream(&currentPitchAcceleration.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (currentRollAcceleration) {
	_nameHashCode = 0x6c7c99b6; //ShipObject.currentRollAcceleration
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<DeltaFloatVariable<'SHIP', 6, 11 > >::toBinaryStream(&currentRollAcceleration.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (maxSpeed) {
	_nameHashCode = 0x7beb957b; //ShipObject.maxSpeed
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&maxSpeed.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (shipComponents) {
	_nameHashCode = 0x8d78ea3; //ShipObject.shipComponents
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<DeltaVectorMap<unsigned int, unsigned int> >::toBinaryStream(&shipComponents.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}


	return _count;
}

bool ShipObjectPOD::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (TangibleObjectPOD::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0x6222f244: //ShipObject.totalMass
		{
			float _mntotalMass;
			TypeInfo<float >::parseFromBinaryStream(&_mntotalMass, stream);
			totalMass = std::move(_mntotalMass);
		}
		return true;

	case 0x434bee0: //ShipObject.currentMass
		{
			float _mncurrentMass;
			TypeInfo<float >::parseFromBinaryStream(&_mncurrentMass, stream);
			currentMass = std::move(_mncurrentMass);
		}
		return true;

	case 0x7d4f2cad: //ShipObject.maxYawAcceleration
		{
			DeltaFloatVariable<'SHIP', 6, 6 > _mnmaxYawAcceleration;
			TypeInfo<DeltaFloatVariable<'SHIP', 6, 6 > >::parseFromBinaryStream(&_mnmaxYawAcceleration, stream);
			maxYawAcceleration = std::move(_mnmaxYawAcceleration);
		}
		return true;

	case 0xe42a3c32: //ShipObject.maxPitchAcceleration
		{
			DeltaFloatVariable<'SHIP', 6, 7 > _mnmaxPitchAcceleration;
			TypeInfo<DeltaFloatVariable<'SHIP', 6, 7 > >::parseFromBinaryStream(&_mnmaxPitchAcceleration, stream);
			maxPitchAcceleration = std::move(_mnmaxPitchAcceleration);
		}
		return true;

	case 0x6fb8bb20: //ShipObject.maxRollAcceleration
		{
			DeltaFloatVariable<'SHIP', 6, 8 > _mnmaxRollAcceleration;
			TypeInfo<DeltaFloatVariable<'SHIP', 6, 8 > >::parseFromBinaryStream(&_mnmaxRollAcceleration, stream);
			maxRollAcceleration = std::move(_mnmaxRollAcceleration);
		}
		return true;

	case 0xb433abef: //ShipObject.currentYawAcceleration
		{
			DeltaFloatVariable<'SHIP', 6, 9 > _mncurrentYawAcceleration;
			TypeInfo<DeltaFloatVariable<'SHIP', 6, 9 > >::parseFromBinaryStream(&_mncurrentYawAcceleration, stream);
			currentYawAcceleration = std::move(_mncurrentYawAcceleration);
		}
		return true;

	case 0x2d4b8ceb: //ShipObject.currentPitchAcceleration
		{
			DeltaFloatVariable<'SHIP', 6, 10 > _mncurrentPitchAcceleration;
			TypeInfo<DeltaFloatVariable<'SHIP', 6, 10 > >::parseFromBinaryStream(&_mncurrentPitchAcceleration, stream);
			currentPitchAcceleration = std::move(_mncurrentPitchAcceleration);
		}
		return true;

	case 0x6c7c99b6: //ShipObject.currentRollAcceleration
		{
			DeltaFloatVariable<'SHIP', 6, 11 > _mncurrentRollAcceleration;
			TypeInfo<DeltaFloatVariable<'SHIP', 6, 11 > >::parseFromBinaryStream(&_mncurrentRollAcceleration, stream);
			currentRollAcceleration = std::move(_mncurrentRollAcceleration);
		}
		return true;

	case 0x7beb957b: //ShipObject.maxSpeed
		{
			float _mnmaxSpeed;
			TypeInfo<float >::parseFromBinaryStream(&_mnmaxSpeed, stream);
			maxSpeed = std::move(_mnmaxSpeed);
		}
		return true;

	case 0x8d78ea3: //ShipObject.shipComponents
		{
			DeltaVectorMap<unsigned int, unsigned int> _mnshipComponents;
			TypeInfo<DeltaVectorMap<unsigned int, unsigned int> >::parseFromBinaryStream(&_mnshipComponents, stream);
			shipComponents = std::move(_mnshipComponents);
		}
		return true;

	}

	return false;
}

void ShipObjectPOD::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(ShipObjectPOD::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

}

void ShipObjectPOD::writeObjectCompact(ObjectOutputStream* stream) {
	TangibleObjectPOD::writeObjectCompact(stream);

	TypeInfo<float >::toBinaryStream(&totalMass.value(), stream);

	TypeInfo<float >::toBinaryStream(&currentMass.value(), stream);

	TypeInfo<DeltaFloatVariable<'SHIP', 6, 6 > >::toBinaryStream(&maxYawAcceleration.value(), stream);

	TypeInfo<DeltaFloatVariable<'SHIP', 6, 7 > >::toBinaryStream(&maxPitchAcceleration.value(), stream);

	TypeInfo<DeltaFloatVariable<'SHIP', 6, 8 > >::toBinaryStream(&maxRollAcceleration.value(), stream);

	TypeInfo<DeltaFloatVariable<'SHIP', 6, 9 > >::toBinaryStream(&currentYawAcceleration.value(), stream);

	TypeInfo<DeltaFloatVariable<'SHIP', 6, 10 > >::toBinaryStream(&currentPitchAcceleration.value(), stream);

	TypeInfo<DeltaFloatVariable<'SHIP', 6, 11 > >::toBinaryStream(&currentRollAcceleration.value(), stream);

	TypeInfo<float >::toBinaryStream(&maxSpeed.value(), stream);

	TypeInfo<DeltaVectorMap<unsigned int, unsigned int> >::toBinaryStream(&shipComponents.value(), stream);


}

