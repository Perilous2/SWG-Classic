/*
 *	autogen/server/zone/objects/creature/ai/AiAgent.h generated by engine3 IDL compiler 0.70
 */

#ifndef AIAGENT_H_
#define AIAGENT_H_

#include "engine/core/Core.h"

#include "engine/core/ManagedReference.h"

#include "engine/core/ManagedWeakReference.h"

#include "system/util/Optional.h"

#ifndef likely
#ifdef __GNUC__
#define likely(x)       __builtin_expect(!!(x), 1)
#define unlikely(x)     __builtin_expect(!!(x), 0)
#else
#define likely(x)       (x)
#define unlikely(x)     (x)
#endif
#endif
#include "engine/util/json_utils.h"

namespace server {
namespace zone {

class Zone;

class ZonePOD;

} // namespace zone
} // namespace server

using namespace server::zone;

namespace server {
namespace zone {
namespace objects {
namespace creature {
namespace commands {

class QueueCommand;

} // namespace commands
} // namespace creature
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::creature::commands;

namespace server {
namespace zone {
namespace objects {
namespace creature {
namespace ai {
namespace events {

class AiRecoveryEvent;

} // namespace events
} // namespace ai
} // namespace creature
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::creature::ai::events;

namespace server {
namespace zone {
namespace objects {
namespace creature {
namespace ai {
namespace events {

class AiBehaviorEvent;

} // namespace events
} // namespace ai
} // namespace creature
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::creature::ai::events;

namespace server {
namespace zone {
namespace packets {
namespace scene {

class AttributeListMessage;

} // namespace scene
} // namespace packets
} // namespace zone
} // namespace server

using namespace server::zone::packets::scene;

namespace server {
namespace zone {
namespace objects {
namespace tangible {
namespace weapon {

class WeaponObject;

class WeaponObjectPOD;

} // namespace weapon
} // namespace tangible
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::tangible::weapon;

namespace server {
namespace zone {

class QuadTreeEntry;

class QuadTreeEntryPOD;

} // namespace zone
} // namespace server

using namespace server::zone;

namespace server {
namespace zone {
namespace objects {
namespace tangible {

class TangibleObject;

class TangibleObjectPOD;

} // namespace tangible
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::tangible;

namespace server {
namespace zone {
namespace objects {
namespace creature {
namespace ai {

class CreatureTemplate;

} // namespace ai
} // namespace creature
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::creature::ai;

namespace server {
namespace zone {
namespace objects {
namespace creature {
namespace events {

class DespawnCreatureOnPlayerDissappear;

} // namespace events
} // namespace creature
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::creature::events;

namespace server {
namespace zone {
namespace objects {
namespace intangible {

class ControlDevice;

class ControlDevicePOD;

} // namespace intangible
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::intangible;

namespace server {
namespace zone {
namespace objects {
namespace scene {

class SceneObject;

class SceneObjectPOD;

} // namespace scene
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::scene;

namespace server {
namespace zone {
namespace objects {
namespace creature {
namespace ai {
namespace bt {

class BlackboardData;

} // namespace bt
} // namespace ai
} // namespace creature
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::creature::ai::bt;

#include "gmock/gmock.h"

#include "server/zone/objects/creature/ai/PatrolPointsVector.h"

#include "server/zone/objects/creature/ai/PatrolPoint.h"

#include "templates/SharedObjectTemplate.h"

#include "server/zone/objects/creature/ai/variables/CreatureAttackMap.h"

#include "system/thread/Mutex.h"

#include "server/zone/managers/loot/lootgroup/LootGroupCollection.h"

#include "server/zone/objects/creature/ai/variables/CreatureTemplateReference.h"

#include "system/thread/ReadWriteLock.h"

#include "server/zone/objects/creature/ai/variables/CurrentFoundPath.h"

#include "server/zone/objects/creature/ai/bt/Behavior.h"

#include "server/zone/objects/creature/ai/bt/BehaviorTreeSlot.h"

#include "server/zone/objects/tangible/deed/pet/PetDeed.h"

#include "server/zone/objects/cell/CellObject.h"

#include "system/util/VectorMap.h"

#include "engine/util/u3d/Vector3.h"

#include "server/zone/objects/creature/ai/bt/BlackboardDataMap.h"

#include "server/zone/objects/area/ActiveArea.h"

#include "system/util/Vector.h"

#include "system/lang/Time.h"

#include "system/lang/String.h"

#include "system/lang/Exception.h"

#include "server/zone/objects/creature/CreatureObject.h"

#include "system/lang/ref/Reference.h"

#include "engine/core/ManagedObject.h"

#include "engine/util/Observable.h"

#include "system/thread/atomic/AtomicInteger.h"

#include "system/util/SortedVector.h"

namespace server {
namespace zone {
namespace objects {
namespace creature {
namespace ai {

class AiAgent : public CreatureObject {
public:
	static const int BEHAVIORINTERVAL = 400;

	static const int DEFAULTAGGRORADIUS = 24;

	static const int OBLIVIOUS = 0;

	static const int WATCHING = 1;

	static const int STALKING = 2;

	static const int FOLLOWING = 3;

	static const int PATROLLING = 4;

	static const int FLEEING = 5;

	static const int LEASHING = 6;

	static const int EVADING = 7;

	static const int PATHING_HOME = 8;

	static const int FOLLOW_FORMATION = 9;

	static const int MOVING_TO_HEAL = 10;

	static const int NOTIFY_ALLY = 11;

	static const int CRACKDOWN_SCANNING = 12;

	static const int HARVESTING = 13;

	static const int RESTING = 14;

	static const int CONVERSING = 15;

	static const int MOB_HERBIVORE = 1;

	static const int MOB_CARNIVORE = 2;

	static const int MOB_NPC = 3;

	static const int MOB_DROID = 4;

	static const int MOB_ANDROID = 5;

	static const int MOB_VEHICLE = 6;

	static const int MAX_OOS_COUNT = 30;

	static const int MAX_OOS_PERCENT = 40;

	static const float MAX_OOS_RANGE;

	AiAgent();

	/**
	 * Initializes the transient members of SceneObject, must call the inherited object method first.
	 * @pre {transient members are not initialized }
	 * @post { transient members are initialized }
	 */
	void initializeTransientMembers();

	/**
	 * Gets called when this objects is loaded from database
	 * @pre { this locked }
	 * @post { this locked }
	 */
	void notifyLoadFromDatabase();

	String getLogFileName() const;

	int getLogLevel() const;

	/**
	 * Schedules the next recovery event
	 * @pre { at least this is locked }
	 * @post { at least this is locked }
	 */
	void activateRecovery();

	/**
	 * Schedules the next movement event
	 * @pre { this is locked }
	 * @post { this is locked }
	 */
	void activateAiBehavior(bool reschedule = false);

	/**
	 * Stops the movement event task
	 * @pre { this is locked }
	 * @post { this is locked }
	 */
	void cancelBehaviorEvent();

	/**
	 * Stops the think event task
	 * @pre { this is locked }
	 * @post { this is locked }
	 */
	void cancelRecoveryEvent();

	/**
	 * Does a recovery tick
	 * @pre { this is locked }
	 * @post { this is locked }
	 * @param latency The amount of time since the last recovery event
	 */
	void doRecovery(int latency);

	/**
	 * Does the main AI update tick
	 * @pre { this object is locked }
	 * @post { this object is locked, this AI will have performed one update tick }
	 */
	void runBehaviorTree();

	void handleException(const Exception& e, const String& context);

	bool isRunningBehavior(unsigned int id);

	void addRunningID(unsigned int id);

	void popRunningChain();

	unsigned int peekRunningChain();

	void clearRunningChain();

	void setAITemplate();

	Behavior* getBehaviorTree(const BehaviorTreeSlot& slot);

	void setTree(Behavior* subRoot, const BehaviorTreeSlot& slot);

	void removeTree(const BehaviorTreeSlot& slot);

	void loadCreatureBitmask();

	void unloadCreatureBitmask();

	void setAIDebug(bool flag);

	bool getAIDebug();

	void setLevel(int lvl, bool randomHam = true);

	/**
	 * Sends the CREO baseline messages of this object to the specified player
	 * @pre { this object is locked }
	 * @post { this object is locked, player received the baseline messages }
	 * @param player SceneObject that will receive the baselines
	 */
	void sendBaselinesTo(SceneObject* player);

	int calculateAttackMinDamage(int level);

	int calculateAttackMaxDamage(int level);

	float calculateAttackSpeed(int level);

	SceneObject* getTargetFromMap();

	SceneObject* getTargetFromDefenders();

	SceneObject* getTargetFromTargetsMap(TangibleObject* target);

	SceneObject* getTargetFromTargetsDefenders();

	bool validateTarget();

	bool validateTarget(SceneObject* target);

	virtual bool isCamouflaged(CreatureObject* target);

	virtual bool findNextPosition(float maxDistance, bool walk);

	virtual bool checkLineOfSight(SceneObject* obj);

	float getWorldZ(const Vector3& position);

	/**
	 * Handles the radial selection sent by the client, must be overriden by inherited objects
	 * @pre { this object is locked, player is locked }
	 * @post { this object is locked, player is locked }
	 * @param player CreatureObject that selected the option
	 * @param selectedID selected menu id
	 * @returns 0 if successfull
	 */
	int handleObjectMenuSelect(CreatureObject* player, byte selectedID);

	void updateHomeDirection();

	void checkNewAngle();

	void fillAttributeList(AttributeListMessage* msg, CreatureObject* object);

	void setNextPosition(float x, float z, float y, CellObject* cell = NULL);

	void setNextStepPosition(float x, float z, float y, CellObject* cell = NULL);

	void notifyPositionUpdate(QuadTreeEntry* entry);

	void updateCurrentPosition(PatrolPoint* point);

	void updatePetSwimmingState();

	void broadcastNextPositionUpdate(PatrolPoint* point);

	void clearPatrolPoints();

	void clearCurrentPath();

	void clearSavedPatrolPoints();

	void setPatrolPoints(PatrolPointsVector& pVector);

	PatrolPoint getNextPosition();

	virtual int getPatrolPointSize();

	void notifyInsert(QuadTreeEntry* entry);

	void notifyDissapear(QuadTreeEntry* entry);

	/**
	 * Reads and sets the template data from a SharedTangibleObjectTemplate LuaObject
	 * @pre { templateData is a valid pointer }
	 * @post { TangibleObject members are initialized }
	 * @param templateData templateData points to the SharedTangibleObjectTemplate LuaObject that is used to initialize the TangibleObject members
	 */
	void loadTemplateData(SharedObjectTemplate* templateData);

	void loadTemplateData(CreatureTemplate* templateData);

	void loadWeaponTemplateData();

	void setupAttackMaps();

	WeaponObject* createWeapon(unsigned int weaponCRC, bool primaryWeapon);

	void unequipWeapons();

	void equipPrimaryWeapon();

	void equipSecondaryWeapon();

	/**
	 * Inflicts damage into the object
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @return unused for now
	 */
	int inflictDamage(TangibleObject* attacker, int damageType, float damage, bool destroy, bool notifyClient = true, bool isCombatAction = false);

	int inflictDamage(TangibleObject* attacker, int damageType, float damage, bool destroy, const String& xp, bool notifyClient = true, bool isCombatAction = false);

	void notifyPackMobs(SceneObject* attacker);

	int addDotState(CreatureObject* attacker, unsigned long long dotType, unsigned long long objectID, unsigned int strength, byte type, unsigned int duration, float potency, unsigned int defense, int secondaryStrength = 0);

	/**
	 * sends the conversation notification
	 * @pre {this locked, player locked }
	 * @post { this locked, player locked }
	 * @return whether the conversation was started or not
	 */
	bool sendConversationStartTo(SceneObject* player);

	/**
	 * sends the conversation notification
	 * @pre {this locked}
	 * @post {this locked}
	 */
	bool stopConversation();

	/**
	 * sends the default conversation list
	 * @pre {this locked, player locked }
	 * @post {this locked, player locked }
	 */
	void sendDefaultConversationTo(SceneObject* player);

	/**
	 * sends the conversation list
	 * @pre {this locked, player locked }
	 * @post { this locked, player locked }
	 */
	void selectConversationOption(int option, SceneObject* obj);

	/**
	 * Is called when this object is destroyed
	 * @pre { this, attacker locked }
	 * @post { this, attacker locked }
	 */
	int notifyObjectDestructionObservers(TangibleObject* attacker, int condition, bool isCombatAction);

	/**
	 * Is called when an object is talked to
	 * @pre { this, converser locked }
	 * @post {this, converser locked }
	 */
	int notifyConverseObservers(CreatureObject* converser);

	int notifyAttack(Observable* observable);

	void destroyObjectFromWorld(bool sendSelfDestroy);

	void destroyObjectFromDatabase(bool destroyContainedObjects = false);

	void activatePostureRecovery();

	void activateHAMRegeneration(int latency);

	void queueDizzyFallEvent();

	/**
	 * Cleares the combat state
	 * @pre { this object is locked }
	 * @post { this object is locked, this object is not in a combat state }
	 * @param clearDefenders if true the defender vector willl be emptied
	 */
	virtual void clearCombatState(bool clearDefenders);

	/**
	 * Sets the active defender
	 * @pre { this object is locked }
	 * @post { this object is locked, defender is active }
	 * @param defender SceneObject to set as the active defender
	 */
	void setDefender(SceneObject* defender);

	/**
	 * Adds a SceneObject to the defender vector
	 * @pre { this object is locked }
	 * @post { this object is locked, defender is in the defender vector }
	 * @param defender SceneObject to add to the defender vector
	 */
	virtual void addDefender(SceneObject* defender);

	/**
	 * Removes the specified defender from the defender vector
	 * @pre { this object is locked }
	 * @post { this object is locked, defender is not in the defender vector }
	 * @param defender SceneObject to remove from the defender vector
	 */
	virtual void removeDefender(SceneObject* defender);

	bool killPlayer(SceneObject* player);

	bool stalkProspect(SceneObject* prospect);

	void healTarget(CreatureObject* target);

	void setDespawnOnNoPlayerInRange(bool val);

	/**
	 * Gets called when the creature was despawned
	 */
	void notifyDespawn(Zone* zone);

	void scheduleDespawn();

	/**
	 * Schedules despawn of the AiAgent.
	 * @param timeToDespawn the time to despawn the AiAgent in seconds.
	 */
	void scheduleDespawn(int timeToDespawn);

	/**
	 * Respawns creature to specified zone with home location position
	 */
	void respawn(Zone* zone, int level);

	void addPatrolPoint(PatrolPoint& point);

	void setHomeLocation(float x, float z, float y, CellObject* cell = NULL, float direction = 0);

	void setRespawnTimer(float resp);

	void setRandomRespawn(bool resp);

	void resetRespawnCounter();

	/**
	 * Evaluates if this can be attacked by object
	 * @pre { }
	 * @post { }
	 * @return returns true if object can attack this
	 */
	bool isAttackableBy(CreatureObject* object);

	bool isAttackableBy(TangibleObject* object);

	/**
	 * Evaluates if this creature is aggresive to the object
	 * @pre { }
	 * @post { }
	 * @return returns true if its aggressive
	 */
	virtual bool isAggressiveTo(CreatureObject* object);

	virtual bool isAggressive(CreatureObject* object);

	void setOblivious();

	void setWatchObject(SceneObject* obj);

	void setStalkObject(SceneObject* obj);

	void setFollowObject(SceneObject* obj);

	void setTargetObject(SceneObject* obj);

	void runAway(CreatureObject* target, float range, bool random);

	void leash(bool forcePeace = true);

	virtual bool generatePatrol(int num, float dist);

	ManagedWeakReference<SceneObject* > getFollowObject();

	void storeFollowObject();

	void restoreFollowObject();

	unsigned int getMovementState() const;

	void setMovementState(int state);

	virtual float getMaxDistance();

	virtual int setDestination();

	/**
	 * Set the wait time in milliseconds
	 * will overwrite the current wait timer
	 **/
	void setWait(int wait);

	/**
	 * Sets the wait timer to current time and removes
	 * the possible blackboard value
	 **/
	void stopWaiting();

	/**
	 * Sees if our wait time is up (won't work for indefinite waits?)
	 **/
	bool isWaiting() const;

	virtual bool validateStateAttack(CreatureObject* target, unsigned int actionCRC);

	virtual bool selectSpecialAttack();

	virtual bool selectSpecialAttack(int attackNum);

	virtual bool selectDefaultAttack();

	virtual const QueueCommand* getNextAction();

	virtual bool validateStateAttack();

	int enqueueAttack(int priority = -1);

	virtual bool isRetreating();

	bool isFleeing();

	bool isResting();

	void clearDespawnEvent();

	float getKinetic();

	float getEnergy();

	float getElectricity();

	float getStun();

	float getBlast();

	float getHeat();

	float getCold();

	float getAcid();

	float getLightSaber();

	bool isSpecialProtection(int resistType);

	bool isStalker();

	bool isKiller();

	bool isHealer();

	unsigned int getFerocity();

	int getAggroRadius();

	unsigned int getArmor();

	bool getDespawnOnNoPlayerInRange() const;

	virtual int getNumberOfPlayersInRange();

	String getFactionString();

	String getSocialGroup();

	String getHealerType();

	float getChanceHit();

	int getDamageMin();

	int getDamageMax();

	float getSpecialDamageMult();

	int getBaseXp();

	unsigned int getDiet();

	unsigned int getTemplateLevel() const;

	float getTame() const;

	const CreatureAttackMap* getAttackMap();

	const CreatureAttackMap* getPrimaryAttackMap();

	const LootGroupCollection* getLootGroups() const;

	String getReactionStf() const;

	float getRespawnTimer() const;

	bool getRandomRespawn() const;

	int getRespawnCounter() const;

	virtual PatrolPoint* getHomeLocation();

	bool isAiAgent();

	AiAgent* asAiAgent();

	const CreatureTemplate* getCreatureTemplate() const;

	bool hasLoot();

	void setShowNextPosition(bool val);

	bool isEventMob() const;

	bool isPet() const;

	void setHomeObject(SceneObject* home);

	ManagedWeakReference<SceneObject* > getHomeObject() const;

	void setEventArea(ActiveArea* area);

	ManagedWeakReference<ActiveArea* > getEventArea() const;

	/**
	 * Sets the combat state
	 * @pre { this object is locked }
	 * @post { this object is locked, this object is in a combat state }
	 */
	void setCombatState();

	unsigned int getCreatureBitmask() const;

	void setCreatureBitmask(unsigned int mask);

	void setCreatureBit(unsigned int option);

	void clearCreatureBit(unsigned int option);

	void addCreatureFlag(unsigned int flag);

	void removeCreatureFlag(unsigned int flag);

	Time* getAlertedTime();

	Time* getAggroDelay();

	Time* getPostureSet();

	Time* getHealDelay();

	Time* getRestDelay();

	Time* getFleeDelay();

	Time* getLastPackNotify();

	Time* getLastCallForHelp();

	bool hasRangedWeapon();

	bool hasMeleeWeapon();

	bool getUseRanged();

	bool hasSpecialAttack(int num);

	void setPetDeed(PetDeed* deed);

	bool hasPetDeed() const;

	PetDeed* getPetDeed() const;

	void sendReactionChat(SceneObject* object, int type, int state = 0, bool force = false);

	bool hasReactionChatMessages();

	float getEffectiveResist();

	String getPersonalityStf();

	int getReactionRank() const;

	void setReactionRank(int rank);

	int getHamMaximum() const;

	int getHamBase() const;

	void setMaxHAM(int type, int value, bool notifyClient = true);

	/**
	 * Reset the aiagent back to it's initial creation state.
	 * this resets the HAM, Damage, Size and Weapons of the AiAgent. Used for Pet adjustments.
	 */
	void reloadTemplate();

	unsigned int getConvoTemplateCRC() const;

	void setConvoTemplate(const String& templateString);

	void setLairTemplateCRC(unsigned int crc);

	unsigned int getLairTemplateCRC() const;

	void writeBlackboard(const String& key, const BlackboardData& data);

	bool peekBlackboard(const String& key);

	BlackboardData readBlackboard(const String& key);

	void eraseBlackboard(const String& key);

	void wipeBlackboard();

	void setCustomAiMap(unsigned long long customMap);

	void setCurrentWeapon(WeaponObject* weap);

	void setDefaultWeapon(WeaponObject* weap);

	WeaponObject* getPrimaryWeapon();

	WeaponObject* getSecondaryWeapon();

	WeaponObject* getDefaultWeapon();

	WeaponObject* getThrownWeapon();

	void clearThrownWeapon();

	WeaponObject* getCurrentWeapon();

	void nullifyWeapons();

	int getMobType() const;

	bool isHerbivore() const;

	bool isCarnivore() const;

	bool isMonster() const;

	bool isDroid() const;

	bool isAndroid() const;

	bool isNpc() const;

	bool isHumanoid() const;

	bool isVehicleType() const;

	VectorMap<unsigned long long, int>* getTargetMissCount();

	void addTargetMissCount(unsigned long long target, int misses);

	void setTargetMissCount(unsigned long long target, int misses);

	void removeTargetMissCount(unsigned long long target);

	String getErrorContext();

	bool isTauntable() const;

	void setMindTricked(bool val);

	bool isMindTricked() const;

	bool isHamRegenDisabled() const;

	void setHamRegenDisabled(bool val);

	DistributedObjectServant* _getImplementation();
	DistributedObjectServant* _getImplementationForRead() const;

	void _setImplementation(DistributedObjectServant* servant);

protected:
	AiAgent(DummyConstructorParameter* param);

	virtual ~AiAgent();

	AiAgent* __asAiAgent();

	friend class AiAgentHelper;
};

} // namespace ai
} // namespace creature
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::creature::ai;

namespace server {
namespace zone {
namespace objects {
namespace creature {
namespace ai {

class AiAgentImplementation : public CreatureObjectImplementation {
protected:
	Reference<AiRecoveryEvent* > recoveryEvent;

	Reference<AiBehaviorEvent* > behaviorEvent;

	ReadWriteLock despawnMutex;

	Vector<String> skillCommands;

	PatrolPointsVector patrolPoints;

	PatrolPointsVector savedPatrolPoints;

	PatrolPoint homeLocation;

	PatrolPoint nextStepPosition;

	PatrolPoint endMovementPosition;

	Reference<CurrentFoundPath* > currentFoundPath;

	ManagedReference<CellObject* > targetCellObject;

	ManagedReference<WeaponObject* > defaultWeapon;

	ManagedReference<WeaponObject* > primaryWeapon;

	ManagedReference<WeaponObject* > secondaryWeapon;

	ManagedReference<WeaponObject* > thrownWeapon;

	ManagedReference<WeaponObject* > currentWeapon;

	Reference<CreatureAttackMap* > primaryAttackMap;

	Reference<CreatureAttackMap* > secondaryAttackMap;

	Reference<CreatureAttackMap* > defaultAttackMap;

	SortedVector<unsigned long long> camouflagedObjects;

	CreatureTemplateReference npcTemplate;

	unsigned int convoTemplateCRC;

	ManagedWeakReference<SceneObject* > homeObject;

	ManagedWeakReference<ActiveArea* > eventArea;

	bool showNextMovementPosition;

	Vector<ManagedReference<SceneObject* > > movementMarkers;

	bool despawnOnNoPlayerInRange;

private:
	ManagedWeakReference<SceneObject* > followObject;

	ManagedWeakReference<SceneObject* > followStore;

	unsigned int movementState;

	Mutex targetMutex;

	Mutex behaviorEventMutex;

	int nextBehaviorInterval;

	Mutex recoveryEventMutex;

protected:
	Time lastDamageReceived;

	Time lastPackNotify;

	Time lastCallForHelp;

	Time fleeDelay;

	Time postureSet;

	Time healDelay;

	Time restDelay;

	int reactionRank;

	float respawnTimer;

	int respawnCounter;

	bool randomRespawn;

	bool hamRegenDisabled;

	float coordinateMin;

	float coordinateMax;

	AtomicInteger numberOfPlayersInRange;

	bool loadedOutfit;

	Reference<DespawnCreatureOnPlayerDissappear* > despawnEvent;

	ManagedReference<PetDeed* > petDeed;

	VectorMap<unsigned long long, int> targetMissCount;

private:
	VectorMap<BehaviorTreeSlot, Reference<Behavior*> > btreeMap;

	Vector<unsigned int> runningChain;

	String aiTemplate;

	BlackboardDataMap blackboard;

protected:
	String templateName;

	unsigned int lairTemplateCRC;

	unsigned int creatureBitmask;

	float fleeRange;

	bool tauntable;

	Time alertedTime;

	Time aggroDelay;

	unsigned int nextActionCRC;

	String nextActionArgs;

	bool mindTricked;

public:
	static const int BEHAVIORINTERVAL = 400;

	static const int DEFAULTAGGRORADIUS = 24;

	static const int OBLIVIOUS = 0;

	static const int WATCHING = 1;

	static const int STALKING = 2;

	static const int FOLLOWING = 3;

	static const int PATROLLING = 4;

	static const int FLEEING = 5;

	static const int LEASHING = 6;

	static const int EVADING = 7;

	static const int PATHING_HOME = 8;

	static const int FOLLOW_FORMATION = 9;

	static const int MOVING_TO_HEAL = 10;

	static const int NOTIFY_ALLY = 11;

	static const int CRACKDOWN_SCANNING = 12;

	static const int HARVESTING = 13;

	static const int RESTING = 14;

	static const int CONVERSING = 15;

	static const int MOB_HERBIVORE = 1;

	static const int MOB_CARNIVORE = 2;

	static const int MOB_NPC = 3;

	static const int MOB_DROID = 4;

	static const int MOB_ANDROID = 5;

	static const int MOB_VEHICLE = 6;

	static const int MAX_OOS_COUNT = 30;

	static const int MAX_OOS_PERCENT = 40;

	static const float MAX_OOS_RANGE;

protected:
	unsigned long long customAiMap;

	int outOfSightCounter;

public:
	AiAgentImplementation();

	AiAgentImplementation(DummyConstructorParameter* param);

	/**
	 * Initializes the transient members of SceneObject, must call the inherited object method first.
	 * @pre {transient members are not initialized }
	 * @post { transient members are initialized }
	 */
	void initializeTransientMembers();

	/**
	 * Gets called when this objects is loaded from database
	 * @pre { this locked }
	 * @post { this locked }
	 */
	void notifyLoadFromDatabase();

	void finalize();

	String getLogFileName() const;

	int getLogLevel() const;

	/**
	 * Schedules the next recovery event
	 * @pre { at least this is locked }
	 * @post { at least this is locked }
	 */
	virtual void activateRecovery();

	/**
	 * Schedules the next movement event
	 * @pre { this is locked }
	 * @post { this is locked }
	 */
	virtual void activateAiBehavior(bool reschedule = false);

	/**
	 * Stops the movement event task
	 * @pre { this is locked }
	 * @post { this is locked }
	 */
	virtual void cancelBehaviorEvent();

	/**
	 * Stops the think event task
	 * @pre { this is locked }
	 * @post { this is locked }
	 */
	virtual void cancelRecoveryEvent();

	/**
	 * Does a recovery tick
	 * @pre { this is locked }
	 * @post { this is locked }
	 * @param latency The amount of time since the last recovery event
	 */
	void doRecovery(int latency);

	/**
	 * Does the main AI update tick
	 * @pre { this object is locked }
	 * @post { this object is locked, this AI will have performed one update tick }
	 */
	void runBehaviorTree();

	void handleException(const Exception& e, const String& context);

	bool isRunningBehavior(unsigned int id);

	void addRunningID(unsigned int id);

	void popRunningChain();

	unsigned int peekRunningChain();

	void clearRunningChain();

	void setAITemplate();

	Behavior* getBehaviorTree(const BehaviorTreeSlot& slot);

	void setTree(Behavior* subRoot, const BehaviorTreeSlot& slot);

	void removeTree(const BehaviorTreeSlot& slot);

	void loadCreatureBitmask();

	void unloadCreatureBitmask();

	void setAIDebug(bool flag);

	bool getAIDebug();

	void setLevel(int lvl, bool randomHam = true);

	/**
	 * Sends the CREO baseline messages of this object to the specified player
	 * @pre { this object is locked }
	 * @post { this object is locked, player received the baseline messages }
	 * @param player SceneObject that will receive the baselines
	 */
	void sendBaselinesTo(SceneObject* player);

	int calculateAttackMinDamage(int level);

	int calculateAttackMaxDamage(int level);

	float calculateAttackSpeed(int level);

	SceneObject* getTargetFromMap();

	SceneObject* getTargetFromDefenders();

	SceneObject* getTargetFromTargetsMap(TangibleObject* target);

	SceneObject* getTargetFromTargetsDefenders();

	bool validateTarget();

	bool validateTarget(SceneObject* target);

	virtual bool isCamouflaged(CreatureObject* target);

	virtual bool findNextPosition(float maxDistance, bool walk);

	virtual bool checkLineOfSight(SceneObject* obj);

	float getWorldZ(const Vector3& position);

	/**
	 * Handles the radial selection sent by the client, must be overriden by inherited objects
	 * @pre { this object is locked, player is locked }
	 * @post { this object is locked, player is locked }
	 * @param player CreatureObject that selected the option
	 * @param selectedID selected menu id
	 * @returns 0 if successfull
	 */
	int handleObjectMenuSelect(CreatureObject* player, byte selectedID);

	void updateHomeDirection();

	void checkNewAngle();

	void fillAttributeList(AttributeListMessage* msg, CreatureObject* object);

	void setNextPosition(float x, float z, float y, CellObject* cell = NULL);

	void setNextStepPosition(float x, float z, float y, CellObject* cell = NULL);

	void notifyPositionUpdate(QuadTreeEntry* entry);

	void updateCurrentPosition(PatrolPoint* point);

	void updatePetSwimmingState();

	void broadcastNextPositionUpdate(PatrolPoint* point);

	void clearPatrolPoints();

	void clearCurrentPath();

	void clearSavedPatrolPoints();

	void setPatrolPoints(PatrolPointsVector& pVector);

	PatrolPoint getNextPosition();

	virtual int getPatrolPointSize();

	void notifyInsert(QuadTreeEntry* entry);

	void notifyDissapear(QuadTreeEntry* entry);

	/**
	 * Reads and sets the template data from a SharedTangibleObjectTemplate LuaObject
	 * @pre { templateData is a valid pointer }
	 * @post { TangibleObject members are initialized }
	 * @param templateData templateData points to the SharedTangibleObjectTemplate LuaObject that is used to initialize the TangibleObject members
	 */
	void loadTemplateData(SharedObjectTemplate* templateData);

	void loadTemplateData(CreatureTemplate* templateData);

	void loadWeaponTemplateData();

	void setupAttackMaps();

	WeaponObject* createWeapon(unsigned int weaponCRC, bool primaryWeapon);

	void unequipWeapons();

	void equipPrimaryWeapon();

	void equipSecondaryWeapon();

	/**
	 * Inflicts damage into the object
	 * @pre { this object is locked }
	 * @post { this object is locked }
	 * @return unused for now
	 */
	int inflictDamage(TangibleObject* attacker, int damageType, float damage, bool destroy, bool notifyClient = true, bool isCombatAction = false);

	int inflictDamage(TangibleObject* attacker, int damageType, float damage, bool destroy, const String& xp, bool notifyClient = true, bool isCombatAction = false);

	void notifyPackMobs(SceneObject* attacker);

	int addDotState(CreatureObject* attacker, unsigned long long dotType, unsigned long long objectID, unsigned int strength, byte type, unsigned int duration, float potency, unsigned int defense, int secondaryStrength = 0);

	/**
	 * sends the conversation notification
	 * @pre {this locked, player locked }
	 * @post { this locked, player locked }
	 * @return whether the conversation was started or not
	 */
	bool sendConversationStartTo(SceneObject* player);

	/**
	 * sends the conversation notification
	 * @pre {this locked}
	 * @post {this locked}
	 */
	bool stopConversation();

	/**
	 * sends the default conversation list
	 * @pre {this locked, player locked }
	 * @post {this locked, player locked }
	 */
	void sendDefaultConversationTo(SceneObject* player);

	/**
	 * sends the conversation list
	 * @pre {this locked, player locked }
	 * @post { this locked, player locked }
	 */
	void selectConversationOption(int option, SceneObject* obj);

	/**
	 * Is called when this object is destroyed
	 * @pre { this, attacker locked }
	 * @post { this, attacker locked }
	 */
	int notifyObjectDestructionObservers(TangibleObject* attacker, int condition, bool isCombatAction);

	/**
	 * Is called when an object is talked to
	 * @pre { this, converser locked }
	 * @post {this, converser locked }
	 */
	int notifyConverseObservers(CreatureObject* converser);

	int notifyAttack(Observable* observable);

	void destroyObjectFromWorld(bool sendSelfDestroy);

	void destroyObjectFromDatabase(bool destroyContainedObjects = false);

	void activatePostureRecovery();

	virtual void activateHAMRegeneration(int latency);

	void queueDizzyFallEvent();

	/**
	 * Cleares the combat state
	 * @pre { this object is locked }
	 * @post { this object is locked, this object is not in a combat state }
	 * @param clearDefenders if true the defender vector willl be emptied
	 */
	virtual void clearCombatState(bool clearDefenders);

	/**
	 * Sets the active defender
	 * @pre { this object is locked }
	 * @post { this object is locked, defender is active }
	 * @param defender SceneObject to set as the active defender
	 */
	void setDefender(SceneObject* defender);

	/**
	 * Adds a SceneObject to the defender vector
	 * @pre { this object is locked }
	 * @post { this object is locked, defender is in the defender vector }
	 * @param defender SceneObject to add to the defender vector
	 */
	virtual void addDefender(SceneObject* defender);

	/**
	 * Removes the specified defender from the defender vector
	 * @pre { this object is locked }
	 * @post { this object is locked, defender is not in the defender vector }
	 * @param defender SceneObject to remove from the defender vector
	 */
	virtual void removeDefender(SceneObject* defender);

	bool killPlayer(SceneObject* player);

	bool stalkProspect(SceneObject* prospect);

	void healTarget(CreatureObject* target);

	void setDespawnOnNoPlayerInRange(bool val);

	/**
	 * Gets called when the creature was despawned
	 */
	virtual void notifyDespawn(Zone* zone);

	virtual void scheduleDespawn();

	/**
	 * Schedules despawn of the AiAgent.
	 * @param timeToDespawn the time to despawn the AiAgent in seconds.
	 */
	virtual void scheduleDespawn(int timeToDespawn);

	/**
	 * Respawns creature to specified zone with home location position
	 */
	void respawn(Zone* zone, int level);

	void addPatrolPoint(PatrolPoint& point);

	void setHomeLocation(float x, float z, float y, CellObject* cell = NULL, float direction = 0);

	void setRespawnTimer(float resp);

	void setRandomRespawn(bool resp);

	void resetRespawnCounter();

	/**
	 * Evaluates if this can be attacked by object
	 * @pre { }
	 * @post { }
	 * @return returns true if object can attack this
	 */
	bool isAttackableBy(CreatureObject* object);

	bool isAttackableBy(TangibleObject* object);

	/**
	 * Evaluates if this creature is aggresive to the object
	 * @pre { }
	 * @post { }
	 * @return returns true if its aggressive
	 */
	virtual bool isAggressiveTo(CreatureObject* object);

	virtual bool isAggressive(CreatureObject* object);

	void setOblivious();

	void setWatchObject(SceneObject* obj);

	void setStalkObject(SceneObject* obj);

	void setFollowObject(SceneObject* obj);

	void setTargetObject(SceneObject* obj);

	void runAway(CreatureObject* target, float range, bool random);

	virtual void leash(bool forcePeace = true);

	virtual bool generatePatrol(int num, float dist);

	ManagedWeakReference<SceneObject* > getFollowObject();

	void storeFollowObject();

	void restoreFollowObject();

	unsigned int getMovementState() const;

	void setMovementState(int state);

	virtual float getMaxDistance();

	virtual int setDestination();

	/**
	 * Set the wait time in milliseconds
	 * will overwrite the current wait timer
	 **/
	void setWait(int wait);

	/**
	 * Sets the wait timer to current time and removes
	 * the possible blackboard value
	 **/
	void stopWaiting();

	/**
	 * Sees if our wait time is up (won't work for indefinite waits?)
	 **/
	bool isWaiting() const;

	virtual bool validateStateAttack(CreatureObject* target, unsigned int actionCRC);

	virtual bool selectSpecialAttack();

	virtual bool selectSpecialAttack(int attackNum);

	virtual bool selectDefaultAttack();

	virtual const QueueCommand* getNextAction();

	virtual bool validateStateAttack();

	int enqueueAttack(int priority = -1);

	virtual bool isRetreating();

	bool isFleeing();

	bool isResting();

	void clearDespawnEvent();

	virtual float getKinetic();

	virtual float getEnergy();

	virtual float getElectricity();

	virtual float getStun();

	virtual float getBlast();

	virtual float getHeat();

	virtual float getCold();

	virtual float getAcid();

	virtual float getLightSaber();

protected:
	float getReducedResist(float value);

public:
	virtual bool isSpecialProtection(int resistType);

	bool isStalker();

	bool isKiller();

	bool isHealer();

	unsigned int getFerocity();

	int getAggroRadius();

	virtual unsigned int getArmor();

	bool getDespawnOnNoPlayerInRange() const;

	virtual int getNumberOfPlayersInRange();

	String getFactionString();

	String getSocialGroup();

	String getHealerType();

	float getChanceHit();

	int getDamageMin();

	int getDamageMax();

	float getSpecialDamageMult();

	virtual int getBaseXp();

	unsigned int getDiet();

	unsigned int getTemplateLevel() const;

	float getTame() const;

	const CreatureAttackMap* getAttackMap();

	const CreatureAttackMap* getPrimaryAttackMap();

	const LootGroupCollection* getLootGroups() const;

	virtual String getReactionStf() const;

	float getRespawnTimer() const;

	bool getRandomRespawn() const;

	int getRespawnCounter() const;

	virtual PatrolPoint* getHomeLocation();

	bool isAiAgent();

	AiAgent* asAiAgent();

	const CreatureTemplate* getCreatureTemplate() const;

	bool hasLoot();

	void setShowNextPosition(bool val);

	bool isEventMob() const;

	bool isPet() const;

	void setHomeObject(SceneObject* home);

	ManagedWeakReference<SceneObject* > getHomeObject() const;

	void setEventArea(ActiveArea* area);

	ManagedWeakReference<ActiveArea* > getEventArea() const;

	/**
	 * Sets the combat state
	 * @pre { this object is locked }
	 * @post { this object is locked, this object is in a combat state }
	 */
	void setCombatState();

	unsigned int getCreatureBitmask() const;

	void setCreatureBitmask(unsigned int mask);

	void setCreatureBit(unsigned int option);

	void clearCreatureBit(unsigned int option);

	void addCreatureFlag(unsigned int flag);

	void removeCreatureFlag(unsigned int flag);

	Time* getAlertedTime();

	Time* getAggroDelay();

	Time* getPostureSet();

	Time* getHealDelay();

	Time* getRestDelay();

	Time* getFleeDelay();

	Time* getLastPackNotify();

	Time* getLastCallForHelp();

	bool hasRangedWeapon();

	bool hasMeleeWeapon();

	bool getUseRanged();

	bool hasSpecialAttack(int num);

	void setPetDeed(PetDeed* deed);

	bool hasPetDeed() const;

	PetDeed* getPetDeed() const;

	void sendReactionChat(SceneObject* object, int type, int state = 0, bool force = false);

	virtual bool hasReactionChatMessages();

	float getEffectiveResist();

	virtual String getPersonalityStf();

	int getReactionRank() const;

	void setReactionRank(int rank);

	int getHamMaximum() const;

	int getHamBase() const;

	void setMaxHAM(int type, int value, bool notifyClient = true);

	/**
	 * Reset the aiagent back to it's initial creation state.
	 * this resets the HAM, Damage, Size and Weapons of the AiAgent. Used for Pet adjustments.
	 */
	void reloadTemplate();

	unsigned int getConvoTemplateCRC() const;

	void setConvoTemplate(const String& templateString);

	void setLairTemplateCRC(unsigned int crc);

	unsigned int getLairTemplateCRC() const;

	void writeBlackboard(const String& key, const BlackboardData& data);

	bool peekBlackboard(const String& key);

	BlackboardData readBlackboard(const String& key);

	void eraseBlackboard(const String& key);

	void wipeBlackboard();

	void setCustomAiMap(unsigned long long customMap);

	void setCurrentWeapon(WeaponObject* weap);

	void setDefaultWeapon(WeaponObject* weap);

	virtual WeaponObject* getPrimaryWeapon();

	virtual WeaponObject* getSecondaryWeapon();

	virtual WeaponObject* getDefaultWeapon();

	virtual WeaponObject* getThrownWeapon();

	void clearThrownWeapon();

	virtual WeaponObject* getCurrentWeapon();

	void nullifyWeapons();

	int getMobType() const;

	bool isHerbivore() const;

	bool isCarnivore() const;

	bool isMonster() const;

	bool isDroid() const;

	bool isAndroid() const;

	bool isNpc() const;

	bool isHumanoid() const;

	bool isVehicleType() const;

	VectorMap<unsigned long long, int>* getTargetMissCount();

	void addTargetMissCount(unsigned long long target, int misses);

	void setTargetMissCount(unsigned long long target, int misses);

	void removeTargetMissCount(unsigned long long target);

	String getErrorContext();

	bool isTauntable() const;

	void setMindTricked(bool val);

	bool isMindTricked() const;

	bool isHamRegenDisabled() const;

	void setHamRegenDisabled(bool val);

	WeakReference<AiAgent*> _this;

	operator const AiAgent*();

	DistributedObjectStub* _getStub();
	virtual void readObject(ObjectInputStream* stream);
	virtual void writeObject(ObjectOutputStream* stream);
	virtual void writeJSON(nlohmann::json& j);
protected:
	virtual ~AiAgentImplementation();

	void _initializeImplementation();

	void _setStub(DistributedObjectStub* stub);

	void lock(bool doLock = true);

	void lock(ManagedObject* obj);

	void rlock(bool doLock = true);

	void wlock(bool doLock = true);

	void wlock(ManagedObject* obj);

	void unlock(bool doLock = true);

	void runlock(bool doLock = true);

	void _serializationHelperMethod();
	bool readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode);
	int writeObjectMembers(ObjectOutputStream* stream);

	friend class AiAgent;
};

class AiAgentAdapter : public CreatureObjectAdapter {
public:
	AiAgentAdapter(AiAgent* impl);

	void invokeMethod(sys::uint32 methid, DistributedMethod* method);

	void initializeTransientMembers();

	void notifyLoadFromDatabase();

	void finalize();

	String getLogFileName() const;

	int getLogLevel() const;

	void activateRecovery();

	void activateAiBehavior(bool reschedule);

	void cancelBehaviorEvent();

	void cancelRecoveryEvent();

	void doRecovery(int latency);

	void runBehaviorTree();

	bool isRunningBehavior(unsigned int id);

	void addRunningID(unsigned int id);

	void popRunningChain();

	unsigned int peekRunningChain();

	void clearRunningChain();

	void setAITemplate();

	void loadCreatureBitmask();

	void unloadCreatureBitmask();

	void setAIDebug(bool flag);

	bool getAIDebug();

	void setLevel(int lvl, bool randomHam);

	void sendBaselinesTo(SceneObject* player);

	int calculateAttackMinDamage(int level);

	int calculateAttackMaxDamage(int level);

	float calculateAttackSpeed(int level);

	SceneObject* getTargetFromMap();

	SceneObject* getTargetFromDefenders();

	SceneObject* getTargetFromTargetsMap(TangibleObject* target);

	SceneObject* getTargetFromTargetsDefenders();

	bool validateTarget();

	bool validateTarget(SceneObject* target);

	bool isCamouflaged(CreatureObject* target);

	bool findNextPosition(float maxDistance, bool walk);

	bool checkLineOfSight(SceneObject* obj);

	int handleObjectMenuSelect(CreatureObject* player, byte selectedID);

	void updateHomeDirection();

	void checkNewAngle();

	void setNextPosition(float x, float z, float y, CellObject* cell);

	void setNextStepPosition(float x, float z, float y, CellObject* cell);

	void notifyPositionUpdate(QuadTreeEntry* entry);

	void clearPatrolPoints();

	void clearCurrentPath();

	void clearSavedPatrolPoints();

	int inflictDamage(TangibleObject* attacker, int damageType, float damage, bool destroy, bool notifyClient, bool isCombatAction);

	int inflictDamage(TangibleObject* attacker, int damageType, float damage, bool destroy, const String& xp, bool notifyClient, bool isCombatAction);

	void notifyPackMobs(SceneObject* attacker);

	int addDotState(CreatureObject* attacker, unsigned long long dotType, unsigned long long objectID, unsigned int strength, byte type, unsigned int duration, float potency, unsigned int defense, int secondaryStrength);

	bool sendConversationStartTo(SceneObject* player);

	bool stopConversation();

	void sendDefaultConversationTo(SceneObject* player);

	void selectConversationOption(int option, SceneObject* obj);

	int notifyObjectDestructionObservers(TangibleObject* attacker, int condition, bool isCombatAction);

	int notifyConverseObservers(CreatureObject* converser);

	int notifyAttack(Observable* observable);

	void destroyObjectFromWorld(bool sendSelfDestroy);

	void destroyObjectFromDatabase(bool destroyContainedObjects);

	void activatePostureRecovery();

	void activateHAMRegeneration(int latency);

	void queueDizzyFallEvent();

	void clearCombatState(bool clearDefenders);

	void setDefender(SceneObject* defender);

	void addDefender(SceneObject* defender);

	void removeDefender(SceneObject* defender);

	bool killPlayer(SceneObject* player);

	bool stalkProspect(SceneObject* prospect);

	void healTarget(CreatureObject* target);

	void setDespawnOnNoPlayerInRange(bool val);

	void notifyDespawn(Zone* zone);

	void scheduleDespawn();

	void scheduleDespawn(int timeToDespawn);

	void respawn(Zone* zone, int level);

	void setHomeLocation(float x, float z, float y, CellObject* cell, float direction);

	void setRespawnTimer(float resp);

	void setRandomRespawn(bool resp);

	void resetRespawnCounter();

	bool isAttackableBy(CreatureObject* object);

	bool isAttackableBy(TangibleObject* object);

	bool isAggressiveTo(CreatureObject* object);

	bool isAggressive(CreatureObject* object);

	void setOblivious();

	void setWatchObject(SceneObject* obj);

	void setStalkObject(SceneObject* obj);

	void setFollowObject(SceneObject* obj);

	void setTargetObject(SceneObject* obj);

	void runAway(CreatureObject* target, float range, bool random);

	void leash(bool forcePeace);

	bool generatePatrol(int num, float dist);

	ManagedWeakReference<SceneObject* > getFollowObject();

	void storeFollowObject();

	void restoreFollowObject();

	unsigned int getMovementState() const;

	void setMovementState(int state);

	float getMaxDistance();

	int setDestination();

	void setWait(int wait);

	void stopWaiting();

	bool isWaiting() const;

	bool validateStateAttack(CreatureObject* target, unsigned int actionCRC);

	bool selectSpecialAttack();

	bool selectSpecialAttack(int attackNum);

	bool selectDefaultAttack();

	bool validateStateAttack();

	int enqueueAttack(int priority);

	bool isRetreating();

	bool isFleeing();

	bool isResting();

	void clearDespawnEvent();

	float getKinetic();

	float getEnergy();

	float getElectricity();

	float getStun();

	float getBlast();

	float getHeat();

	float getCold();

	float getAcid();

	float getLightSaber();

	bool isSpecialProtection(int resistType);

	bool isStalker();

	bool isKiller();

	bool isHealer();

	unsigned int getFerocity();

	int getAggroRadius();

	unsigned int getArmor();

	bool getDespawnOnNoPlayerInRange() const;

	int getNumberOfPlayersInRange();

	String getFactionString();

	String getSocialGroup();

	String getHealerType();

	float getChanceHit();

	int getDamageMin();

	int getDamageMax();

	float getSpecialDamageMult();

	int getBaseXp();

	unsigned int getDiet();

	unsigned int getTemplateLevel() const;

	float getTame() const;

	String getReactionStf() const;

	float getRespawnTimer() const;

	bool getRandomRespawn() const;

	int getRespawnCounter() const;

	bool isAiAgent();

	bool hasLoot();

	void setShowNextPosition(bool val);

	bool isEventMob() const;

	bool isPet() const;

	void setHomeObject(SceneObject* home);

	void setEventArea(ActiveArea* area);

	void setCombatState();

	unsigned int getCreatureBitmask() const;

	void setCreatureBitmask(unsigned int mask);

	void setCreatureBit(unsigned int option);

	void clearCreatureBit(unsigned int option);

	void addCreatureFlag(unsigned int flag);

	void removeCreatureFlag(unsigned int flag);

	bool hasRangedWeapon();

	bool hasMeleeWeapon();

	bool getUseRanged();

	bool hasSpecialAttack(int num);

	void setPetDeed(PetDeed* deed);

	bool hasPetDeed() const;

	PetDeed* getPetDeed() const;

	void sendReactionChat(SceneObject* object, int type, int state, bool force);

	bool hasReactionChatMessages();

	String getPersonalityStf();

	int getReactionRank() const;

	void setReactionRank(int rank);

	int getHamMaximum() const;

	int getHamBase() const;

	void setMaxHAM(int type, int value, bool notifyClient);

	void reloadTemplate();

	unsigned int getConvoTemplateCRC() const;

	void setConvoTemplate(const String& templateString);

	void setLairTemplateCRC(unsigned int crc);

	unsigned int getLairTemplateCRC() const;

	void setCustomAiMap(unsigned long long customMap);

	void setCurrentWeapon(WeaponObject* weap);

	void setDefaultWeapon(WeaponObject* weap);

	WeaponObject* getPrimaryWeapon();

	WeaponObject* getSecondaryWeapon();

	WeaponObject* getDefaultWeapon();

	WeaponObject* getThrownWeapon();

	void clearThrownWeapon();

	WeaponObject* getCurrentWeapon();

	void nullifyWeapons();

	int getMobType() const;

	bool isHerbivore() const;

	bool isCarnivore() const;

	bool isMonster() const;

	bool isDroid() const;

	bool isAndroid() const;

	bool isNpc() const;

	bool isHumanoid() const;

	bool isVehicleType() const;

	void addTargetMissCount(unsigned long long target, int misses);

	void setTargetMissCount(unsigned long long target, int misses);

	void removeTargetMissCount(unsigned long long target);

	String getErrorContext();

	bool isTauntable() const;

	void setMindTricked(bool val);

	bool isMindTricked() const;

	bool isHamRegenDisabled() const;

	void setHamRegenDisabled(bool val);

};

class AiAgentHelper : public DistributedObjectClassHelper, public Singleton<AiAgentHelper> {
	static AiAgentHelper* staticInitializer;

public:
	AiAgentHelper();

	void finalizeHelper();

	DistributedObject* instantiateObject();

	DistributedObjectPOD* instantiatePOD();

	DistributedObjectServant* instantiateServant();

	DistributedObjectAdapter* createAdapter(DistributedObjectStub* obj);

	friend class Singleton<AiAgentHelper>;
};

class MockAiAgent : public AiAgent {
public:

	MOCK_METHOD1(isCamouflaged,bool(CreatureObject* target));
	MOCK_METHOD2(findNextPosition,bool(float maxDistance, bool walk));
	MOCK_METHOD1(checkLineOfSight,bool(SceneObject* obj));
	MOCK_METHOD0(getPatrolPointSize,int());
	MOCK_METHOD1(clearCombatState,void(bool clearDefenders));
	MOCK_METHOD1(addDefender,void(SceneObject* defender));
	MOCK_METHOD1(removeDefender,void(SceneObject* defender));
	MOCK_METHOD1(isAggressiveTo,bool(CreatureObject* object));
	MOCK_METHOD1(isAggressive,bool(CreatureObject* object));
	MOCK_METHOD2(generatePatrol,bool(int num, float dist));
	MOCK_METHOD0(getMaxDistance,float());
	MOCK_METHOD0(setDestination,int());
	MOCK_METHOD2(validateStateAttack,bool(CreatureObject* target, unsigned int actionCRC));
	MOCK_METHOD0(selectSpecialAttack,bool());
	MOCK_METHOD1(selectSpecialAttack,bool(int attackNum));
	MOCK_METHOD0(selectDefaultAttack,bool());
	MOCK_METHOD0(getNextAction,const QueueCommand*());
	MOCK_METHOD0(validateStateAttack,bool());
	MOCK_METHOD0(isRetreating,bool());
	MOCK_METHOD0(getNumberOfPlayersInRange,int());
	MOCK_METHOD0(getHomeLocation,PatrolPoint*());
	MOCK_METHOD0(getPosture,byte());
	MOCK_METHOD0(getLocomotion,byte());
	MOCK_METHOD1(hasState,bool(unsigned long long state));
	MOCK_METHOD0(getCurrentSpeed,float());
	MOCK_METHOD0(getDefaultWeapon,WeaponObject*());
	MOCK_METHOD0(isIncapacitated,bool());
	MOCK_METHOD0(isDead,bool());
	MOCK_METHOD0(isInCombat,bool());
	MOCK_METHOD1(isAttackableBy,bool(CreatureObject* object));
	MOCK_METHOD0(getLevel,int());
	MOCK_METHOD0(isDestroyed,bool());
	MOCK_METHOD0(getThreatMap,ThreatMap*());
	MOCK_METHOD2(isInRange,bool(SceneObject* obj, float range));
	MOCK_METHOD1(getSlottedObjects,void(VectorMap<String, ManagedReference<SceneObject* > >& objects));
	MOCK_METHOD1(getDistanceTo,float(SceneObject* object));
	MOCK_METHOD1(getDistanceTo,float(Coordinate* coordinate));
	MOCK_METHOD0(getZone,Zone*());
	MOCK_METHOD0(getZoneUnsafe,Zone*());
	MOCK_METHOD0(getWorldPositionX,float());
	MOCK_METHOD0(getWorldPositionY,float());
	MOCK_METHOD0(getWorldPositionZ,float());
	MOCK_METHOD0(getWorldPosition,Vector3());
	MOCK_METHOD1(getSlottedObject,Reference<SceneObject* >(const String& slot));
	MOCK_METHOD1(isFacingObject,bool(SceneObject* obj));
	MOCK_METHOD0(getParent,ManagedWeakReference<SceneObject* >());
	MOCK_METHOD0(asCreatureObject,CreatureObject*());
	MOCK_METHOD0(asAiAgent,AiAgent*());
	MOCK_METHOD0(asTangibleObject,TangibleObject*());
	MOCK_METHOD0(getTemplateRadius,float());

};

} // namespace ai
} // namespace creature
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::creature::ai;

namespace server {
namespace zone {
namespace objects {
namespace creature {
namespace ai {

class AiAgentPOD : public CreatureObjectPOD {
public:
	Optional<Vector<String>> skillCommands;

	Optional<ManagedReference<WeaponObjectPOD* >> defaultWeapon;

	Optional<ManagedReference<WeaponObjectPOD* >> primaryWeapon;

	Optional<ManagedReference<WeaponObjectPOD* >> secondaryWeapon;

	Optional<ManagedReference<WeaponObjectPOD* >> thrownWeapon;

	Optional<ManagedReference<WeaponObjectPOD* >> currentWeapon;

	Optional<CreatureTemplateReference> npcTemplate;

	Optional<unsigned int> convoTemplateCRC;

	Optional<ManagedWeakReference<SceneObjectPOD* >> homeObject;

	Optional<ManagedWeakReference<ActiveAreaPOD* >> eventArea;

	Optional<bool> showNextMovementPosition;

	Optional<Vector<ManagedReference<SceneObjectPOD* > >> movementMarkers;

	Optional<bool> despawnOnNoPlayerInRange;

	Optional<ManagedWeakReference<SceneObjectPOD* >> followObject;

	Optional<ManagedWeakReference<SceneObjectPOD* >> followStore;

	Optional<unsigned int> movementState;

	Optional<int> nextBehaviorInterval;

	Optional<int> reactionRank;

	Optional<float> respawnTimer;

	Optional<int> respawnCounter;

	Optional<bool> randomRespawn;

	Optional<float> coordinateMin;

	Optional<float> coordinateMax;

	Optional<bool> loadedOutfit;

	Optional<ManagedReference<PetDeedPOD* >> petDeed;

	Optional<String> aiTemplate;

	Optional<unsigned int> lairTemplateCRC;

	Optional<unsigned int> creatureBitmask;

	Optional<float> fleeRange;

	Optional<bool> tauntable;

	Optional<unsigned int> nextActionCRC;

	Optional<String> nextActionArgs;

	String _className;
	AiAgentPOD();
	virtual void writeJSON(nlohmann::json& j);
	virtual void readObject(ObjectInputStream* stream);
	virtual void writeObject(ObjectOutputStream* stream);
	bool readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode);
	int writeObjectMembers(ObjectOutputStream* stream);
	void writeObjectCompact(ObjectOutputStream* stream);



	virtual ~AiAgentPOD();

};

} // namespace ai
} // namespace creature
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::creature::ai;

#endif /*AIAGENTPOD_H_*/
