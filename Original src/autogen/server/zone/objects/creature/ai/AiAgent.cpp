/*
 *	autogen/server/zone/objects/creature/ai/AiAgent.cpp generated by engine3 IDL compiler 0.70
 */

#include "AiAgent.h"

#include "server/zone/Zone.h"

#include "server/zone/objects/creature/commands/QueueCommand.h"

#include "server/zone/objects/creature/ai/events/AiRecoveryEvent.h"

#include "server/zone/objects/creature/ai/events/AiBehaviorEvent.h"

#include "server/zone/packets/scene/AttributeListMessage.h"

#include "server/zone/objects/tangible/weapon/WeaponObject.h"

#include "server/zone/QuadTreeEntry.h"

#include "server/zone/objects/tangible/TangibleObject.h"

#include "server/zone/objects/creature/ai/CreatureTemplate.h"

#include "server/zone/objects/creature/events/DespawnCreatureOnPlayerDissappear.h"

#include "server/zone/objects/intangible/ControlDevice.h"

#include "server/zone/objects/scene/SceneObject.h"

#include "server/zone/objects/creature/ai/bt/BlackboardData.h"

/*
 *	AiAgentStub
 */

const float AiAgent::MAX_OOS_RANGE = 20.0f;

enum {RPC_INITIALIZETRANSIENTMEMBERS__ = 24868240,RPC_NOTIFYLOADFROMDATABASE__,RPC_FINALIZE__,RPC_GETLOGFILENAME__,RPC_GETLOGLEVEL__,RPC_ACTIVATERECOVERY__,RPC_ACTIVATEAIBEHAVIOR__BOOL_,RPC_CANCELBEHAVIOREVENT__,RPC_CANCELRECOVERYEVENT__,RPC_DORECOVERY__INT_,RPC_RUNBEHAVIORTREE__,RPC_ISRUNNINGBEHAVIOR__INT_,RPC_ADDRUNNINGID__INT_,RPC_POPRUNNINGCHAIN__,RPC_PEEKRUNNINGCHAIN__,RPC_CLEARRUNNINGCHAIN__,RPC_SETAITEMPLATE__,RPC_LOADCREATUREBITMASK__,RPC_UNLOADCREATUREBITMASK__,RPC_SETAIDEBUG__BOOL_,RPC_GETAIDEBUG__,RPC_SETLEVEL__INT_BOOL_,RPC_SENDBASELINESTO__SCENEOBJECT_,RPC_CALCULATEATTACKMINDAMAGE__INT_,RPC_CALCULATEATTACKMAXDAMAGE__INT_,RPC_CALCULATEATTACKSPEED__INT_,RPC_GETTARGETFROMMAP__,RPC_GETTARGETFROMDEFENDERS__,RPC_GETTARGETFROMTARGETSMAP__TANGIBLEOBJECT_,RPC_GETTARGETFROMTARGETSDEFENDERS__,RPC_VALIDATETARGET__,RPC_VALIDATETARGET__SCENEOBJECT_,RPC_ISCAMOUFLAGED__CREATUREOBJECT_,RPC_FINDNEXTPOSITION__FLOAT_BOOL_,RPC_CHECKLINEOFSIGHT__SCENEOBJECT_,RPC_HANDLEOBJECTMENUSELECT__CREATUREOBJECT_BYTE_,RPC_UPDATEHOMEDIRECTION__,RPC_CHECKNEWANGLE__,RPC_SETNEXTPOSITION__FLOAT_FLOAT_FLOAT_CELLOBJECT_,RPC_SETNEXTSTEPPOSITION__FLOAT_FLOAT_FLOAT_CELLOBJECT_,RPC_NOTIFYPOSITIONUPDATE__QUADTREEENTRY_,RPC_CLEARPATROLPOINTS__,RPC_CLEARCURRENTPATH__,RPC_CLEARSAVEDPATROLPOINTS__,RPC_INFLICTDAMAGE__TANGIBLEOBJECT_INT_FLOAT_BOOL_BOOL_BOOL_,RPC_INFLICTDAMAGE__TANGIBLEOBJECT_INT_FLOAT_BOOL_STRING_BOOL_BOOL_,RPC_NOTIFYPACKMOBS__SCENEOBJECT_,RPC_ADDDOTSTATE__CREATUREOBJECT_LONG_LONG_INT_BYTE_INT_FLOAT_INT_INT_,RPC_SENDCONVERSATIONSTARTTO__SCENEOBJECT_,RPC_STOPCONVERSATION__,RPC_SENDDEFAULTCONVERSATIONTO__SCENEOBJECT_,RPC_SELECTCONVERSATIONOPTION__INT_SCENEOBJECT_,RPC_NOTIFYOBJECTDESTRUCTIONOBSERVERS__TANGIBLEOBJECT_INT_BOOL_,RPC_NOTIFYCONVERSEOBSERVERS__CREATUREOBJECT_,RPC_NOTIFYATTACK__OBSERVABLE_,RPC_DESTROYOBJECTFROMWORLD__BOOL_,RPC_DESTROYOBJECTFROMDATABASE__BOOL_,RPC_ACTIVATEPOSTURERECOVERY__,RPC_ACTIVATEHAMREGENERATION__INT_,RPC_QUEUEDIZZYFALLEVENT__,RPC_CLEARCOMBATSTATE__BOOL_,RPC_SETDEFENDER__SCENEOBJECT_,RPC_ADDDEFENDER__SCENEOBJECT_,RPC_REMOVEDEFENDER__SCENEOBJECT_,RPC_KILLPLAYER__SCENEOBJECT_,RPC_STALKPROSPECT__SCENEOBJECT_,RPC_HEALTARGET__CREATUREOBJECT_,RPC_SETDESPAWNONNOPLAYERINRANGE__BOOL_,RPC_NOTIFYDESPAWN__ZONE_,RPC_SCHEDULEDESPAWN__,RPC_SCHEDULEDESPAWN__INT_,RPC_RESPAWN__ZONE_INT_,RPC_SETHOMELOCATION__FLOAT_FLOAT_FLOAT_CELLOBJECT_FLOAT_,RPC_SETRESPAWNTIMER__FLOAT_,RPC_SETRANDOMRESPAWN__BOOL_,RPC_RESETRESPAWNCOUNTER__,RPC_ISATTACKABLEBY__CREATUREOBJECT_,RPC_ISATTACKABLEBY__TANGIBLEOBJECT_,RPC_ISAGGRESSIVETO__CREATUREOBJECT_,RPC_ISAGGRESSIVE__CREATUREOBJECT_,RPC_SETOBLIVIOUS__,RPC_SETWATCHOBJECT__SCENEOBJECT_,RPC_SETSTALKOBJECT__SCENEOBJECT_,RPC_SETFOLLOWOBJECT__SCENEOBJECT_,RPC_SETTARGETOBJECT__SCENEOBJECT_,RPC_RUNAWAY__CREATUREOBJECT_FLOAT_BOOL_,RPC_LEASH__BOOL_,RPC_GENERATEPATROL__INT_FLOAT_,RPC_GETFOLLOWOBJECT__,RPC_STOREFOLLOWOBJECT__,RPC_RESTOREFOLLOWOBJECT__,RPC_GETMOVEMENTSTATE__,RPC_SETMOVEMENTSTATE__INT_,RPC_GETMAXDISTANCE__,RPC_SETDESTINATION__,RPC_SETWAIT__INT_,RPC_STOPWAITING__,RPC_ISWAITING__,RPC_VALIDATESTATEATTACK__CREATUREOBJECT_INT_,RPC_SELECTSPECIALATTACK__,RPC_SELECTSPECIALATTACK__INT_,RPC_SELECTDEFAULTATTACK__,RPC_VALIDATESTATEATTACK__,RPC_ENQUEUEATTACK__INT_,RPC_ISRETREATING__,RPC_ISFLEEING__,RPC_ISRESTING__,RPC_CLEARDESPAWNEVENT__,RPC_GETKINETIC__,RPC_GETENERGY__,RPC_GETELECTRICITY__,RPC_GETSTUN__,RPC_GETBLAST__,RPC_GETHEAT__,RPC_GETCOLD__,RPC_GETACID__,RPC_GETLIGHTSABER__,RPC_ISSPECIALPROTECTION__INT_,RPC_ISSTALKER__,RPC_ISKILLER__,RPC_ISHEALER__,RPC_GETFEROCITY__,RPC_GETAGGRORADIUS__,RPC_GETARMOR__,RPC_GETDESPAWNONNOPLAYERINRANGE__,RPC_GETNUMBEROFPLAYERSINRANGE__,RPC_GETFACTIONSTRING__,RPC_GETSOCIALGROUP__,RPC_GETHEALERTYPE__,RPC_GETCHANCEHIT__,RPC_GETDAMAGEMIN__,RPC_GETDAMAGEMAX__,RPC_GETSPECIALDAMAGEMULT__,RPC_GETBASEXP__,RPC_GETDIET__,RPC_GETTEMPLATELEVEL__,RPC_GETTAME__,RPC_GETREACTIONSTF__,RPC_GETRESPAWNTIMER__,RPC_GETRANDOMRESPAWN__,RPC_GETRESPAWNCOUNTER__,RPC_ISAIAGENT__,RPC_HASLOOT__,RPC_SETSHOWNEXTPOSITION__BOOL_,RPC_ISEVENTMOB__,RPC_ISPET__,RPC_SETHOMEOBJECT__SCENEOBJECT_,RPC_SETEVENTAREA__ACTIVEAREA_,RPC_SETCOMBATSTATE__,RPC_GETCREATUREBITMASK__,RPC_SETCREATUREBITMASK__INT_,RPC_SETCREATUREBIT__INT_,RPC_CLEARCREATUREBIT__INT_,RPC_ADDCREATUREFLAG__INT_,RPC_REMOVECREATUREFLAG__INT_,RPC_HASRANGEDWEAPON__,RPC_HASMELEEWEAPON__,RPC_GETUSERANGED__,RPC_HASSPECIALATTACK__INT_,RPC_SETPETDEED__PETDEED_,RPC_HASPETDEED__,RPC_GETPETDEED__,RPC_SENDREACTIONCHAT__SCENEOBJECT_INT_INT_BOOL_,RPC_HASREACTIONCHATMESSAGES__,RPC_GETPERSONALITYSTF__,RPC_GETREACTIONRANK__,RPC_SETREACTIONRANK__INT_,RPC_GETHAMMAXIMUM__,RPC_GETHAMBASE__,RPC_SETMAXHAM__INT_INT_BOOL_,RPC_RELOADTEMPLATE__,RPC_GETCONVOTEMPLATECRC__,RPC_SETCONVOTEMPLATE__STRING_,RPC_SETLAIRTEMPLATECRC__INT_,RPC_GETLAIRTEMPLATECRC__,RPC_SETCUSTOMAIMAP__LONG_,RPC_SETCURRENTWEAPON__WEAPONOBJECT_,RPC_SETDEFAULTWEAPON__WEAPONOBJECT_,RPC_GETPRIMARYWEAPON__,RPC_GETSECONDARYWEAPON__,RPC_GETDEFAULTWEAPON__,RPC_GETTHROWNWEAPON__,RPC_CLEARTHROWNWEAPON__,RPC_GETCURRENTWEAPON__,RPC_NULLIFYWEAPONS__,RPC_GETMOBTYPE__,RPC_ISHERBIVORE__,RPC_ISCARNIVORE__,RPC_ISMONSTER__,RPC_ISDROID__,RPC_ISANDROID__,RPC_ISNPC__,RPC_ISHUMANOID__,RPC_ISVEHICLETYPE__,RPC_ADDTARGETMISSCOUNT__LONG_INT_,RPC_SETTARGETMISSCOUNT__LONG_INT_,RPC_REMOVETARGETMISSCOUNT__LONG_,RPC_GETERRORCONTEXT__,RPC_ISTAUNTABLE__,RPC_SETMINDTRICKED__BOOL_,RPC_ISMINDTRICKED__,RPC_ISHAMREGENDISABLED__,RPC_SETHAMREGENDISABLED__BOOL_};

AiAgent::AiAgent() : CreatureObject(DummyConstructorParameter::instance()) {
	AiAgentImplementation* _implementation = new AiAgentImplementation();
	_impl = _implementation;
	_impl->_setStub(this);
	_setClassName("AiAgent");
}

AiAgent::AiAgent(DummyConstructorParameter* param) : CreatureObject(param) {
	_setClassName("AiAgent");
}

AiAgent::~AiAgent() {
}



void AiAgent::initializeTransientMembers() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INITIALIZETRANSIENTMEMBERS__);

		method.executeWithVoidReturn();
	} else {
		_implementation->initializeTransientMembers();
	}
}

void AiAgent::notifyLoadFromDatabase() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYLOADFROMDATABASE__);

		method.executeWithVoidReturn();
	} else {
		_implementation->notifyLoadFromDatabase();
	}
}

String AiAgent::getLogFileName() const {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETLOGFILENAME__);

		String _return_getLogFileName;
		method.executeWithAsciiReturn(_return_getLogFileName);
		return _return_getLogFileName;
	} else {
		return _implementation->getLogFileName();
	}
}

int AiAgent::getLogLevel() const {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETLOGLEVEL__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getLogLevel();
	}
}

void AiAgent::activateRecovery() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ACTIVATERECOVERY__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->activateRecovery();
	}
}

void AiAgent::activateAiBehavior(bool reschedule) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ACTIVATEAIBEHAVIOR__BOOL_);
		method.addBooleanParameter(reschedule);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->activateAiBehavior(reschedule);
	}
}

void AiAgent::cancelBehaviorEvent() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CANCELBEHAVIOREVENT__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->cancelBehaviorEvent();
	}
}

void AiAgent::cancelRecoveryEvent() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CANCELRECOVERYEVENT__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->cancelRecoveryEvent();
	}
}

void AiAgent::doRecovery(int latency) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DORECOVERY__INT_);
		method.addSignedIntParameter(latency);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->doRecovery(latency);
	}
}

void AiAgent::runBehaviorTree() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_RUNBEHAVIORTREE__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->runBehaviorTree();
	}
}

void AiAgent::handleException(const Exception& e, const String& context) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->handleException(e, context);
	}
}

bool AiAgent::isRunningBehavior(unsigned int id) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISRUNNINGBEHAVIOR__INT_);
		method.addUnsignedIntParameter(id);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isRunningBehavior(id);
	}
}

void AiAgent::addRunningID(unsigned int id) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDRUNNINGID__INT_);
		method.addUnsignedIntParameter(id);

		method.executeWithVoidReturn();
	} else {
		_implementation->addRunningID(id);
	}
}

void AiAgent::popRunningChain() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_POPRUNNINGCHAIN__);

		method.executeWithVoidReturn();
	} else {
		_implementation->popRunningChain();
	}
}

unsigned int AiAgent::peekRunningChain() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_PEEKRUNNINGCHAIN__);

		return method.executeWithUnsignedIntReturn();
	} else {
		return _implementation->peekRunningChain();
	}
}

void AiAgent::clearRunningChain() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARRUNNINGCHAIN__);

		method.executeWithVoidReturn();
	} else {
		_implementation->clearRunningChain();
	}
}

void AiAgent::setAITemplate() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETAITEMPLATE__);

		method.executeWithVoidReturn();
	} else {
		_implementation->setAITemplate();
	}
}

Behavior* AiAgent::getBehaviorTree(const BehaviorTreeSlot& slot) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		assert(this->isLockedByCurrentThread());
		return _implementation->getBehaviorTree(slot);
	}
}

void AiAgent::setTree(Behavior* subRoot, const BehaviorTreeSlot& slot) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setTree(subRoot, slot);
	}
}

void AiAgent::removeTree(const BehaviorTreeSlot& slot) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->removeTree(slot);
	}
}

void AiAgent::loadCreatureBitmask() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_LOADCREATUREBITMASK__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->loadCreatureBitmask();
	}
}

void AiAgent::unloadCreatureBitmask() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UNLOADCREATUREBITMASK__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->unloadCreatureBitmask();
	}
}

void AiAgent::setAIDebug(bool flag) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETAIDEBUG__BOOL_);
		method.addBooleanParameter(flag);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setAIDebug(flag);
	}
}

bool AiAgent::getAIDebug() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETAIDEBUG__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->getAIDebug();
	}
}

void AiAgent::setLevel(int lvl, bool randomHam) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETLEVEL__INT_BOOL_);
		method.addSignedIntParameter(lvl);
		method.addBooleanParameter(randomHam);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setLevel(lvl, randomHam);
	}
}

void AiAgent::sendBaselinesTo(SceneObject* player) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDBASELINESTO__SCENEOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendBaselinesTo(player);
	}
}

int AiAgent::calculateAttackMinDamage(int level) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CALCULATEATTACKMINDAMAGE__INT_);
		method.addSignedIntParameter(level);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->calculateAttackMinDamage(level);
	}
}

int AiAgent::calculateAttackMaxDamage(int level) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CALCULATEATTACKMAXDAMAGE__INT_);
		method.addSignedIntParameter(level);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->calculateAttackMaxDamage(level);
	}
}

float AiAgent::calculateAttackSpeed(int level) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CALCULATEATTACKSPEED__INT_);
		method.addSignedIntParameter(level);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->calculateAttackSpeed(level);
	}
}

SceneObject* AiAgent::getTargetFromMap() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETTARGETFROMMAP__);

		return static_cast<SceneObject*>(method.executeWithObjectReturn());
	} else {
		assert(this->isLockedByCurrentThread());
		return _implementation->getTargetFromMap();
	}
}

SceneObject* AiAgent::getTargetFromDefenders() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETTARGETFROMDEFENDERS__);

		return static_cast<SceneObject*>(method.executeWithObjectReturn());
	} else {
		assert(this->isLockedByCurrentThread());
		return _implementation->getTargetFromDefenders();
	}
}

SceneObject* AiAgent::getTargetFromTargetsMap(TangibleObject* target) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETTARGETFROMTARGETSMAP__TANGIBLEOBJECT_);
		method.addObjectParameter(target);

		return static_cast<SceneObject*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getTargetFromTargetsMap(target);
	}
}

SceneObject* AiAgent::getTargetFromTargetsDefenders() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETTARGETFROMTARGETSDEFENDERS__);

		return static_cast<SceneObject*>(method.executeWithObjectReturn());
	} else {
		assert(this->isLockedByCurrentThread());
		return _implementation->getTargetFromTargetsDefenders();
	}
}

bool AiAgent::validateTarget() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_VALIDATETARGET__);

		return method.executeWithBooleanReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		return _implementation->validateTarget();
	}
}

bool AiAgent::validateTarget(SceneObject* target) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_VALIDATETARGET__SCENEOBJECT_);
		method.addObjectParameter(target);

		return method.executeWithBooleanReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		return _implementation->validateTarget(target);
	}
}

bool AiAgent::isCamouflaged(CreatureObject* target) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISCAMOUFLAGED__CREATUREOBJECT_);
		method.addObjectParameter(target);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isCamouflaged(target);
	}
}

bool AiAgent::findNextPosition(float maxDistance, bool walk) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_FINDNEXTPOSITION__FLOAT_BOOL_);
		method.addFloatParameter(maxDistance);
		method.addBooleanParameter(walk);

		return method.executeWithBooleanReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		return _implementation->findNextPosition(maxDistance, walk);
	}
}

bool AiAgent::checkLineOfSight(SceneObject* obj) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CHECKLINEOFSIGHT__SCENEOBJECT_);
		method.addObjectParameter(obj);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->checkLineOfSight(obj);
	}
}

float AiAgent::getWorldZ(const Vector3& position) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getWorldZ(position);
	}
}

int AiAgent::handleObjectMenuSelect(CreatureObject* player, byte selectedID) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HANDLEOBJECTMENUSELECT__CREATUREOBJECT_BYTE_);
		method.addObjectParameter(player);
		method.addByteParameter(selectedID);

		return method.executeWithSignedIntReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		assert((player == NULL) || player->isLockedByCurrentThread());
		return _implementation->handleObjectMenuSelect(player, selectedID);
	}
}

void AiAgent::updateHomeDirection() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATEHOMEDIRECTION__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->updateHomeDirection();
	}
}

void AiAgent::checkNewAngle() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CHECKNEWANGLE__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->checkNewAngle();
	}
}

void AiAgent::fillAttributeList(AttributeListMessage* msg, CreatureObject* object) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->fillAttributeList(msg, object);
	}
}

void AiAgent::setNextPosition(float x, float z, float y, CellObject* cell) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETNEXTPOSITION__FLOAT_FLOAT_FLOAT_CELLOBJECT_);
		method.addFloatParameter(x);
		method.addFloatParameter(z);
		method.addFloatParameter(y);
		method.addObjectParameter(cell);

		method.executeWithVoidReturn();
	} else {
		_implementation->setNextPosition(x, z, y, cell);
	}
}

void AiAgent::setNextStepPosition(float x, float z, float y, CellObject* cell) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETNEXTSTEPPOSITION__FLOAT_FLOAT_FLOAT_CELLOBJECT_);
		method.addFloatParameter(x);
		method.addFloatParameter(z);
		method.addFloatParameter(y);
		method.addObjectParameter(cell);

		method.executeWithVoidReturn();
	} else {
		_implementation->setNextStepPosition(x, z, y, cell);
	}
}

void AiAgent::notifyPositionUpdate(QuadTreeEntry* entry) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYPOSITIONUPDATE__QUADTREEENTRY_);
		method.addObjectParameter(entry);

		method.executeWithVoidReturn();
	} else {
		_implementation->notifyPositionUpdate(entry);
	}
}

void AiAgent::updateCurrentPosition(PatrolPoint* point) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->updateCurrentPosition(point);
	}
}

void AiAgent::updatePetSwimmingState() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->updatePetSwimmingState();
	}
}

void AiAgent::broadcastNextPositionUpdate(PatrolPoint* point) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->broadcastNextPositionUpdate(point);
	}
}

void AiAgent::clearPatrolPoints() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARPATROLPOINTS__);

		method.executeWithVoidReturn();
	} else {
		_implementation->clearPatrolPoints();
	}
}

void AiAgent::clearCurrentPath() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARCURRENTPATH__);

		method.executeWithVoidReturn();
	} else {
		_implementation->clearCurrentPath();
	}
}

void AiAgent::clearSavedPatrolPoints() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARSAVEDPATROLPOINTS__);

		method.executeWithVoidReturn();
	} else {
		_implementation->clearSavedPatrolPoints();
	}
}

void AiAgent::setPatrolPoints(PatrolPointsVector& pVector) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->setPatrolPoints(pVector);
	}
}

PatrolPoint AiAgent::getNextPosition() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getNextPosition();
	}
}

int AiAgent::getPatrolPointSize() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getPatrolPointSize();
	}
}

void AiAgent::notifyInsert(QuadTreeEntry* entry) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->notifyInsert(entry);
	}
}

void AiAgent::notifyDissapear(QuadTreeEntry* entry) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->notifyDissapear(entry);
	}
}

void AiAgent::loadTemplateData(SharedObjectTemplate* templateData) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->loadTemplateData(templateData);
	}
}

void AiAgent::loadTemplateData(CreatureTemplate* templateData) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->loadTemplateData(templateData);
	}
}

void AiAgent::loadWeaponTemplateData() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->loadWeaponTemplateData();
	}
}

void AiAgent::setupAttackMaps() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->setupAttackMaps();
	}
}

WeaponObject* AiAgent::createWeapon(unsigned int weaponCRC, bool primaryWeapon) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->createWeapon(weaponCRC, primaryWeapon);
	}
}

void AiAgent::unequipWeapons() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->unequipWeapons();
	}
}

void AiAgent::equipPrimaryWeapon() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->equipPrimaryWeapon();
	}
}

void AiAgent::equipSecondaryWeapon() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->equipSecondaryWeapon();
	}
}

int AiAgent::inflictDamage(TangibleObject* attacker, int damageType, float damage, bool destroy, bool notifyClient, bool isCombatAction) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INFLICTDAMAGE__TANGIBLEOBJECT_INT_FLOAT_BOOL_BOOL_BOOL_);
		method.addObjectParameter(attacker);
		method.addSignedIntParameter(damageType);
		method.addFloatParameter(damage);
		method.addBooleanParameter(destroy);
		method.addBooleanParameter(notifyClient);
		method.addBooleanParameter(isCombatAction);

		return method.executeWithSignedIntReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		assert((attacker == NULL) || attacker->isLockedByCurrentThread());
		return _implementation->inflictDamage(attacker, damageType, damage, destroy, notifyClient, isCombatAction);
	}
}

int AiAgent::inflictDamage(TangibleObject* attacker, int damageType, float damage, bool destroy, const String& xp, bool notifyClient, bool isCombatAction) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INFLICTDAMAGE__TANGIBLEOBJECT_INT_FLOAT_BOOL_STRING_BOOL_BOOL_);
		method.addObjectParameter(attacker);
		method.addSignedIntParameter(damageType);
		method.addFloatParameter(damage);
		method.addBooleanParameter(destroy);
		method.addAsciiParameter(xp);
		method.addBooleanParameter(notifyClient);
		method.addBooleanParameter(isCombatAction);

		return method.executeWithSignedIntReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		assert((attacker == NULL) || attacker->isLockedByCurrentThread());
		return _implementation->inflictDamage(attacker, damageType, damage, destroy, xp, notifyClient, isCombatAction);
	}
}

void AiAgent::notifyPackMobs(SceneObject* attacker) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYPACKMOBS__SCENEOBJECT_);
		method.addObjectParameter(attacker);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		assert((attacker == NULL) || attacker->isLockedByCurrentThread());
		_implementation->notifyPackMobs(attacker);
	}
}

int AiAgent::addDotState(CreatureObject* attacker, unsigned long long dotType, unsigned long long objectID, unsigned int strength, byte type, unsigned int duration, float potency, unsigned int defense, int secondaryStrength) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDDOTSTATE__CREATUREOBJECT_LONG_LONG_INT_BYTE_INT_FLOAT_INT_INT_);
		method.addObjectParameter(attacker);
		method.addUnsignedLongParameter(dotType);
		method.addUnsignedLongParameter(objectID);
		method.addUnsignedIntParameter(strength);
		method.addByteParameter(type);
		method.addUnsignedIntParameter(duration);
		method.addFloatParameter(potency);
		method.addUnsignedIntParameter(defense);
		method.addSignedIntParameter(secondaryStrength);

		return method.executeWithSignedIntReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		return _implementation->addDotState(attacker, dotType, objectID, strength, type, duration, potency, defense, secondaryStrength);
	}
}

bool AiAgent::sendConversationStartTo(SceneObject* player) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDCONVERSATIONSTARTTO__SCENEOBJECT_);
		method.addObjectParameter(player);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->sendConversationStartTo(player);
	}
}

bool AiAgent::stopConversation() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_STOPCONVERSATION__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->stopConversation();
	}
}

void AiAgent::sendDefaultConversationTo(SceneObject* player) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDDEFAULTCONVERSATIONTO__SCENEOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendDefaultConversationTo(player);
	}
}

void AiAgent::selectConversationOption(int option, SceneObject* obj) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SELECTCONVERSATIONOPTION__INT_SCENEOBJECT_);
		method.addSignedIntParameter(option);
		method.addObjectParameter(obj);

		method.executeWithVoidReturn();
	} else {
		_implementation->selectConversationOption(option, obj);
	}
}

int AiAgent::notifyObjectDestructionObservers(TangibleObject* attacker, int condition, bool isCombatAction) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYOBJECTDESTRUCTIONOBSERVERS__TANGIBLEOBJECT_INT_BOOL_);
		method.addObjectParameter(attacker);
		method.addSignedIntParameter(condition);
		method.addBooleanParameter(isCombatAction);

		return method.executeWithSignedIntReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		assert((attacker == NULL) || attacker->isLockedByCurrentThread());
		return _implementation->notifyObjectDestructionObservers(attacker, condition, isCombatAction);
	}
}

int AiAgent::notifyConverseObservers(CreatureObject* converser) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYCONVERSEOBSERVERS__CREATUREOBJECT_);
		method.addObjectParameter(converser);

		return method.executeWithSignedIntReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		assert((converser == NULL) || converser->isLockedByCurrentThread());
		return _implementation->notifyConverseObservers(converser);
	}
}

int AiAgent::notifyAttack(Observable* observable) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYATTACK__OBSERVABLE_);
		method.addObjectParameter(observable);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->notifyAttack(observable);
	}
}

void AiAgent::destroyObjectFromWorld(bool sendSelfDestroy) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DESTROYOBJECTFROMWORLD__BOOL_);
		method.addBooleanParameter(sendSelfDestroy);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->destroyObjectFromWorld(sendSelfDestroy);
	}
}

void AiAgent::destroyObjectFromDatabase(bool destroyContainedObjects) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DESTROYOBJECTFROMDATABASE__BOOL_);
		method.addBooleanParameter(destroyContainedObjects);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->destroyObjectFromDatabase(destroyContainedObjects);
	}
}

void AiAgent::activatePostureRecovery() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ACTIVATEPOSTURERECOVERY__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->activatePostureRecovery();
	}
}

void AiAgent::activateHAMRegeneration(int latency) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ACTIVATEHAMREGENERATION__INT_);
		method.addSignedIntParameter(latency);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->activateHAMRegeneration(latency);
	}
}

void AiAgent::queueDizzyFallEvent() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_QUEUEDIZZYFALLEVENT__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->queueDizzyFallEvent();
	}
}

void AiAgent::clearCombatState(bool clearDefenders) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARCOMBATSTATE__BOOL_);
		method.addBooleanParameter(clearDefenders);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->clearCombatState(clearDefenders);
	}
}

void AiAgent::setDefender(SceneObject* defender) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETDEFENDER__SCENEOBJECT_);
		method.addObjectParameter(defender);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setDefender(defender);
	}
}

void AiAgent::addDefender(SceneObject* defender) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDDEFENDER__SCENEOBJECT_);
		method.addObjectParameter(defender);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->addDefender(defender);
	}
}

void AiAgent::removeDefender(SceneObject* defender) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEDEFENDER__SCENEOBJECT_);
		method.addObjectParameter(defender);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->removeDefender(defender);
	}
}

bool AiAgent::killPlayer(SceneObject* player) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_KILLPLAYER__SCENEOBJECT_);
		method.addObjectParameter(player);

		return method.executeWithBooleanReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		return _implementation->killPlayer(player);
	}
}

bool AiAgent::stalkProspect(SceneObject* prospect) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_STALKPROSPECT__SCENEOBJECT_);
		method.addObjectParameter(prospect);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->stalkProspect(prospect);
	}
}

void AiAgent::healTarget(CreatureObject* target) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HEALTARGET__CREATUREOBJECT_);
		method.addObjectParameter(target);

		method.executeWithVoidReturn();
	} else {
		_implementation->healTarget(target);
	}
}

void AiAgent::setDespawnOnNoPlayerInRange(bool val) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETDESPAWNONNOPLAYERINRANGE__BOOL_);
		method.addBooleanParameter(val);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setDespawnOnNoPlayerInRange(val);
	}
}

void AiAgent::notifyDespawn(Zone* zone) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYDESPAWN__ZONE_);
		method.addObjectParameter(zone);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->notifyDespawn(zone);
	}
}

void AiAgent::scheduleDespawn() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SCHEDULEDESPAWN__);

		method.executeWithVoidReturn();
	} else {
		_implementation->scheduleDespawn();
	}
}

void AiAgent::scheduleDespawn(int timeToDespawn) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SCHEDULEDESPAWN__INT_);
		method.addSignedIntParameter(timeToDespawn);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->scheduleDespawn(timeToDespawn);
	}
}

void AiAgent::respawn(Zone* zone, int level) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_RESPAWN__ZONE_INT_);
		method.addObjectParameter(zone);
		method.addSignedIntParameter(level);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->respawn(zone, level);
	}
}

void AiAgent::addPatrolPoint(PatrolPoint& point) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->addPatrolPoint(point);
	}
}

void AiAgent::setHomeLocation(float x, float z, float y, CellObject* cell, float direction) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETHOMELOCATION__FLOAT_FLOAT_FLOAT_CELLOBJECT_FLOAT_);
		method.addFloatParameter(x);
		method.addFloatParameter(z);
		method.addFloatParameter(y);
		method.addObjectParameter(cell);
		method.addFloatParameter(direction);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setHomeLocation(x, z, y, cell, direction);
	}
}

void AiAgent::setRespawnTimer(float resp) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETRESPAWNTIMER__FLOAT_);
		method.addFloatParameter(resp);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setRespawnTimer(resp);
	}
}

void AiAgent::setRandomRespawn(bool resp) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETRANDOMRESPAWN__BOOL_);
		method.addBooleanParameter(resp);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setRandomRespawn(resp);
	}
}

void AiAgent::resetRespawnCounter() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_RESETRESPAWNCOUNTER__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->resetRespawnCounter();
	}
}

bool AiAgent::isAttackableBy(CreatureObject* object) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISATTACKABLEBY__CREATUREOBJECT_);
		method.addObjectParameter(object);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isAttackableBy(object);
	}
}

bool AiAgent::isAttackableBy(TangibleObject* object) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISATTACKABLEBY__TANGIBLEOBJECT_);
		method.addObjectParameter(object);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isAttackableBy(object);
	}
}

bool AiAgent::isAggressiveTo(CreatureObject* object) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISAGGRESSIVETO__CREATUREOBJECT_);
		method.addObjectParameter(object);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isAggressiveTo(object);
	}
}

bool AiAgent::isAggressive(CreatureObject* object) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISAGGRESSIVE__CREATUREOBJECT_);
		method.addObjectParameter(object);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isAggressive(object);
	}
}

void AiAgent::setOblivious() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETOBLIVIOUS__);

		method.executeWithVoidReturn();
	} else {
		_implementation->setOblivious();
	}
}

void AiAgent::setWatchObject(SceneObject* obj) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETWATCHOBJECT__SCENEOBJECT_);
		method.addObjectParameter(obj);

		method.executeWithVoidReturn();
	} else {
		_implementation->setWatchObject(obj);
	}
}

void AiAgent::setStalkObject(SceneObject* obj) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSTALKOBJECT__SCENEOBJECT_);
		method.addObjectParameter(obj);

		method.executeWithVoidReturn();
	} else {
		_implementation->setStalkObject(obj);
	}
}

void AiAgent::setFollowObject(SceneObject* obj) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETFOLLOWOBJECT__SCENEOBJECT_);
		method.addObjectParameter(obj);

		method.executeWithVoidReturn();
	} else {
		_implementation->setFollowObject(obj);
	}
}

void AiAgent::setTargetObject(SceneObject* obj) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETTARGETOBJECT__SCENEOBJECT_);
		method.addObjectParameter(obj);

		method.executeWithVoidReturn();
	} else {
		_implementation->setTargetObject(obj);
	}
}

void AiAgent::runAway(CreatureObject* target, float range, bool random) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_RUNAWAY__CREATUREOBJECT_FLOAT_BOOL_);
		method.addObjectParameter(target);
		method.addFloatParameter(range);
		method.addBooleanParameter(random);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->runAway(target, range, random);
	}
}

void AiAgent::leash(bool forcePeace) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_LEASH__BOOL_);
		method.addBooleanParameter(forcePeace);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->leash(forcePeace);
	}
}

bool AiAgent::generatePatrol(int num, float dist) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GENERATEPATROL__INT_FLOAT_);
		method.addSignedIntParameter(num);
		method.addFloatParameter(dist);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->generatePatrol(num, dist);
	}
}

ManagedWeakReference<SceneObject* > AiAgent::getFollowObject() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETFOLLOWOBJECT__);

		return static_cast<SceneObject*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getFollowObject();
	}
}

void AiAgent::storeFollowObject() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_STOREFOLLOWOBJECT__);

		method.executeWithVoidReturn();
	} else {
		_implementation->storeFollowObject();
	}
}

void AiAgent::restoreFollowObject() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_RESTOREFOLLOWOBJECT__);

		method.executeWithVoidReturn();
	} else {
		_implementation->restoreFollowObject();
	}
}

unsigned int AiAgent::getMovementState() const {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMOVEMENTSTATE__);

		return method.executeWithUnsignedIntReturn();
	} else {
		return _implementation->getMovementState();
	}
}

void AiAgent::setMovementState(int state) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETMOVEMENTSTATE__INT_);
		method.addSignedIntParameter(state);

		method.executeWithVoidReturn();
	} else {
		_implementation->setMovementState(state);
	}
}

float AiAgent::getMaxDistance() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMAXDISTANCE__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getMaxDistance();
	}
}

int AiAgent::setDestination() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETDESTINATION__);

		return method.executeWithSignedIntReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		return _implementation->setDestination();
	}
}

void AiAgent::setWait(int wait) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETWAIT__INT_);
		method.addSignedIntParameter(wait);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setWait(wait);
	}
}

void AiAgent::stopWaiting() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_STOPWAITING__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->stopWaiting();
	}
}

bool AiAgent::isWaiting() const {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISWAITING__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isWaiting();
	}
}

bool AiAgent::validateStateAttack(CreatureObject* target, unsigned int actionCRC) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_VALIDATESTATEATTACK__CREATUREOBJECT_INT_);
		method.addObjectParameter(target);
		method.addUnsignedIntParameter(actionCRC);

		return method.executeWithBooleanReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		return _implementation->validateStateAttack(target, actionCRC);
	}
}

bool AiAgent::selectSpecialAttack() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SELECTSPECIALATTACK__);

		return method.executeWithBooleanReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		return _implementation->selectSpecialAttack();
	}
}

bool AiAgent::selectSpecialAttack(int attackNum) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SELECTSPECIALATTACK__INT_);
		method.addSignedIntParameter(attackNum);

		return method.executeWithBooleanReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		return _implementation->selectSpecialAttack(attackNum);
	}
}

bool AiAgent::selectDefaultAttack() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SELECTDEFAULTATTACK__);

		return method.executeWithBooleanReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		return _implementation->selectDefaultAttack();
	}
}

const QueueCommand* AiAgent::getNextAction() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		assert(this->isLockedByCurrentThread());
		return _implementation->getNextAction();
	}
}

bool AiAgent::validateStateAttack() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_VALIDATESTATEATTACK__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->validateStateAttack();
	}
}

int AiAgent::enqueueAttack(int priority) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ENQUEUEATTACK__INT_);
		method.addSignedIntParameter(priority);

		return method.executeWithSignedIntReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		return _implementation->enqueueAttack(priority);
	}
}

bool AiAgent::isRetreating() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISRETREATING__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isRetreating();
	}
}

bool AiAgent::isFleeing() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISFLEEING__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isFleeing();
	}
}

bool AiAgent::isResting() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISRESTING__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isResting();
	}
}

void AiAgent::clearDespawnEvent() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARDESPAWNEVENT__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->clearDespawnEvent();
	}
}

float AiAgent::getKinetic() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETKINETIC__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getKinetic();
	}
}

float AiAgent::getEnergy() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETENERGY__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getEnergy();
	}
}

float AiAgent::getElectricity() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETELECTRICITY__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getElectricity();
	}
}

float AiAgent::getStun() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSTUN__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getStun();
	}
}

float AiAgent::getBlast() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETBLAST__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getBlast();
	}
}

float AiAgent::getHeat() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETHEAT__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getHeat();
	}
}

float AiAgent::getCold() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCOLD__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getCold();
	}
}

float AiAgent::getAcid() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETACID__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getAcid();
	}
}

float AiAgent::getLightSaber() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETLIGHTSABER__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getLightSaber();
	}
}

bool AiAgent::isSpecialProtection(int resistType) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISSPECIALPROTECTION__INT_);
		method.addSignedIntParameter(resistType);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isSpecialProtection(resistType);
	}
}

bool AiAgent::isStalker() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISSTALKER__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isStalker();
	}
}

bool AiAgent::isKiller() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISKILLER__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isKiller();
	}
}

bool AiAgent::isHealer() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISHEALER__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isHealer();
	}
}

unsigned int AiAgent::getFerocity() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETFEROCITY__);

		return method.executeWithUnsignedIntReturn();
	} else {
		return _implementation->getFerocity();
	}
}

int AiAgent::getAggroRadius() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETAGGRORADIUS__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getAggroRadius();
	}
}

unsigned int AiAgent::getArmor() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETARMOR__);

		return method.executeWithUnsignedIntReturn();
	} else {
		return _implementation->getArmor();
	}
}

bool AiAgent::getDespawnOnNoPlayerInRange() const {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETDESPAWNONNOPLAYERINRANGE__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->getDespawnOnNoPlayerInRange();
	}
}

int AiAgent::getNumberOfPlayersInRange() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETNUMBEROFPLAYERSINRANGE__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getNumberOfPlayersInRange();
	}
}

String AiAgent::getFactionString() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETFACTIONSTRING__);

		String _return_getFactionString;
		method.executeWithAsciiReturn(_return_getFactionString);
		return _return_getFactionString;
	} else {
		return _implementation->getFactionString();
	}
}

String AiAgent::getSocialGroup() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSOCIALGROUP__);

		String _return_getSocialGroup;
		method.executeWithAsciiReturn(_return_getSocialGroup);
		return _return_getSocialGroup;
	} else {
		return _implementation->getSocialGroup();
	}
}

String AiAgent::getHealerType() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETHEALERTYPE__);

		String _return_getHealerType;
		method.executeWithAsciiReturn(_return_getHealerType);
		return _return_getHealerType;
	} else {
		return _implementation->getHealerType();
	}
}

float AiAgent::getChanceHit() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCHANCEHIT__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getChanceHit();
	}
}

int AiAgent::getDamageMin() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETDAMAGEMIN__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getDamageMin();
	}
}

int AiAgent::getDamageMax() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETDAMAGEMAX__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getDamageMax();
	}
}

float AiAgent::getSpecialDamageMult() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSPECIALDAMAGEMULT__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getSpecialDamageMult();
	}
}

int AiAgent::getBaseXp() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETBASEXP__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getBaseXp();
	}
}

unsigned int AiAgent::getDiet() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETDIET__);

		return method.executeWithUnsignedIntReturn();
	} else {
		return _implementation->getDiet();
	}
}

unsigned int AiAgent::getTemplateLevel() const {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETTEMPLATELEVEL__);

		return method.executeWithUnsignedIntReturn();
	} else {
		return _implementation->getTemplateLevel();
	}
}

float AiAgent::getTame() const {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETTAME__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getTame();
	}
}

const CreatureAttackMap* AiAgent::getAttackMap() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getAttackMap();
	}
}

const CreatureAttackMap* AiAgent::getPrimaryAttackMap() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getPrimaryAttackMap();
	}
}

const LootGroupCollection* AiAgent::getLootGroups() const {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getLootGroups();
	}
}

String AiAgent::getReactionStf() const {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETREACTIONSTF__);

		String _return_getReactionStf;
		method.executeWithAsciiReturn(_return_getReactionStf);
		return _return_getReactionStf;
	} else {
		return _implementation->getReactionStf();
	}
}

float AiAgent::getRespawnTimer() const {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETRESPAWNTIMER__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getRespawnTimer();
	}
}

bool AiAgent::getRandomRespawn() const {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETRANDOMRESPAWN__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->getRandomRespawn();
	}
}

int AiAgent::getRespawnCounter() const {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETRESPAWNCOUNTER__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getRespawnCounter();
	}
}

PatrolPoint* AiAgent::getHomeLocation() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getHomeLocation();
	}
}

bool AiAgent::isAiAgent() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISAIAGENT__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isAiAgent();
	}
}

AiAgent* AiAgent::__asAiAgent() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->asAiAgent();
	}
}

const CreatureTemplate* AiAgent::getCreatureTemplate() const {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getCreatureTemplate();
	}
}

bool AiAgent::hasLoot() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASLOOT__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasLoot();
	}
}

void AiAgent::setShowNextPosition(bool val) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSHOWNEXTPOSITION__BOOL_);
		method.addBooleanParameter(val);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setShowNextPosition(val);
	}
}

bool AiAgent::isEventMob() const {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISEVENTMOB__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isEventMob();
	}
}

bool AiAgent::isPet() const {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISPET__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isPet();
	}
}

void AiAgent::setHomeObject(SceneObject* home) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETHOMEOBJECT__SCENEOBJECT_);
		method.addObjectParameter(home);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setHomeObject(home);
	}
}

ManagedWeakReference<SceneObject* > AiAgent::getHomeObject() const {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getHomeObject();
	}
}

void AiAgent::setEventArea(ActiveArea* area) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETEVENTAREA__ACTIVEAREA_);
		method.addObjectParameter(area);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setEventArea(area);
	}
}

ManagedWeakReference<ActiveArea* > AiAgent::getEventArea() const {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getEventArea();
	}
}

void AiAgent::setCombatState() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCOMBATSTATE__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setCombatState();
	}
}

unsigned int AiAgent::getCreatureBitmask() const {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCREATUREBITMASK__);

		return method.executeWithUnsignedIntReturn();
	} else {
		return _implementation->getCreatureBitmask();
	}
}

void AiAgent::setCreatureBitmask(unsigned int mask) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCREATUREBITMASK__INT_);
		method.addUnsignedIntParameter(mask);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setCreatureBitmask(mask);
	}
}

void AiAgent::setCreatureBit(unsigned int option) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCREATUREBIT__INT_);
		method.addUnsignedIntParameter(option);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setCreatureBit(option);
	}
}

void AiAgent::clearCreatureBit(unsigned int option) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARCREATUREBIT__INT_);
		method.addUnsignedIntParameter(option);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->clearCreatureBit(option);
	}
}

void AiAgent::addCreatureFlag(unsigned int flag) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDCREATUREFLAG__INT_);
		method.addUnsignedIntParameter(flag);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->addCreatureFlag(flag);
	}
}

void AiAgent::removeCreatureFlag(unsigned int flag) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVECREATUREFLAG__INT_);
		method.addUnsignedIntParameter(flag);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->removeCreatureFlag(flag);
	}
}

Time* AiAgent::getAlertedTime() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getAlertedTime();
	}
}

Time* AiAgent::getAggroDelay() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getAggroDelay();
	}
}

Time* AiAgent::getPostureSet() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getPostureSet();
	}
}

Time* AiAgent::getHealDelay() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getHealDelay();
	}
}

Time* AiAgent::getRestDelay() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getRestDelay();
	}
}

Time* AiAgent::getFleeDelay() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getFleeDelay();
	}
}

Time* AiAgent::getLastPackNotify() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getLastPackNotify();
	}
}

Time* AiAgent::getLastCallForHelp() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getLastCallForHelp();
	}
}

bool AiAgent::hasRangedWeapon() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASRANGEDWEAPON__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasRangedWeapon();
	}
}

bool AiAgent::hasMeleeWeapon() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASMELEEWEAPON__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasMeleeWeapon();
	}
}

bool AiAgent::getUseRanged() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETUSERANGED__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->getUseRanged();
	}
}

bool AiAgent::hasSpecialAttack(int num) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASSPECIALATTACK__INT_);
		method.addSignedIntParameter(num);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasSpecialAttack(num);
	}
}

void AiAgent::setPetDeed(PetDeed* deed) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETPETDEED__PETDEED_);
		method.addObjectParameter(deed);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setPetDeed(deed);
	}
}

bool AiAgent::hasPetDeed() const {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASPETDEED__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasPetDeed();
	}
}

PetDeed* AiAgent::getPetDeed() const {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETPETDEED__);

		return static_cast<PetDeed*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getPetDeed();
	}
}

void AiAgent::sendReactionChat(SceneObject* object, int type, int state, bool force) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDREACTIONCHAT__SCENEOBJECT_INT_INT_BOOL_);
		method.addObjectParameter(object);
		method.addSignedIntParameter(type);
		method.addSignedIntParameter(state);
		method.addBooleanParameter(force);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->sendReactionChat(object, type, state, force);
	}
}

bool AiAgent::hasReactionChatMessages() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASREACTIONCHATMESSAGES__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasReactionChatMessages();
	}
}

float AiAgent::getEffectiveResist() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getEffectiveResist();
	}
}

String AiAgent::getPersonalityStf() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETPERSONALITYSTF__);

		String _return_getPersonalityStf;
		method.executeWithAsciiReturn(_return_getPersonalityStf);
		return _return_getPersonalityStf;
	} else {
		return _implementation->getPersonalityStf();
	}
}

int AiAgent::getReactionRank() const {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETREACTIONRANK__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getReactionRank();
	}
}

void AiAgent::setReactionRank(int rank) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETREACTIONRANK__INT_);
		method.addSignedIntParameter(rank);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setReactionRank(rank);
	}
}

int AiAgent::getHamMaximum() const {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETHAMMAXIMUM__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getHamMaximum();
	}
}

int AiAgent::getHamBase() const {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETHAMBASE__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getHamBase();
	}
}

void AiAgent::setMaxHAM(int type, int value, bool notifyClient) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETMAXHAM__INT_INT_BOOL_);
		method.addSignedIntParameter(type);
		method.addSignedIntParameter(value);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setMaxHAM(type, value, notifyClient);
	}
}

void AiAgent::reloadTemplate() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_RELOADTEMPLATE__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->reloadTemplate();
	}
}

unsigned int AiAgent::getConvoTemplateCRC() const {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCONVOTEMPLATECRC__);

		return method.executeWithUnsignedIntReturn();
	} else {
		return _implementation->getConvoTemplateCRC();
	}
}

void AiAgent::setConvoTemplate(const String& templateString) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCONVOTEMPLATE__STRING_);
		method.addAsciiParameter(templateString);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setConvoTemplate(templateString);
	}
}

void AiAgent::setLairTemplateCRC(unsigned int crc) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETLAIRTEMPLATECRC__INT_);
		method.addUnsignedIntParameter(crc);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setLairTemplateCRC(crc);
	}
}

unsigned int AiAgent::getLairTemplateCRC() const {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETLAIRTEMPLATECRC__);

		return method.executeWithUnsignedIntReturn();
	} else {
		return _implementation->getLairTemplateCRC();
	}
}

void AiAgent::writeBlackboard(const String& key, const BlackboardData& data) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->writeBlackboard(key, data);
	}
}

bool AiAgent::peekBlackboard(const String& key) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		assert(this->isLockedByCurrentThread());
		return _implementation->peekBlackboard(key);
	}
}

BlackboardData AiAgent::readBlackboard(const String& key) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		assert(this->isLockedByCurrentThread());
		return _implementation->readBlackboard(key);
	}
}

void AiAgent::eraseBlackboard(const String& key) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->eraseBlackboard(key);
	}
}

void AiAgent::wipeBlackboard() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->wipeBlackboard();
	}
}

void AiAgent::setCustomAiMap(unsigned long long customMap) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCUSTOMAIMAP__LONG_);
		method.addUnsignedLongParameter(customMap);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setCustomAiMap(customMap);
	}
}

void AiAgent::setCurrentWeapon(WeaponObject* weap) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCURRENTWEAPON__WEAPONOBJECT_);
		method.addObjectParameter(weap);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setCurrentWeapon(weap);
	}
}

void AiAgent::setDefaultWeapon(WeaponObject* weap) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETDEFAULTWEAPON__WEAPONOBJECT_);
		method.addObjectParameter(weap);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setDefaultWeapon(weap);
	}
}

WeaponObject* AiAgent::getPrimaryWeapon() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETPRIMARYWEAPON__);

		return static_cast<WeaponObject*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getPrimaryWeapon();
	}
}

WeaponObject* AiAgent::getSecondaryWeapon() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSECONDARYWEAPON__);

		return static_cast<WeaponObject*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getSecondaryWeapon();
	}
}

WeaponObject* AiAgent::getDefaultWeapon() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETDEFAULTWEAPON__);

		return static_cast<WeaponObject*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getDefaultWeapon();
	}
}

WeaponObject* AiAgent::getThrownWeapon() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETTHROWNWEAPON__);

		return static_cast<WeaponObject*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getThrownWeapon();
	}
}

void AiAgent::clearThrownWeapon() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARTHROWNWEAPON__);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->clearThrownWeapon();
	}
}

WeaponObject* AiAgent::getCurrentWeapon() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCURRENTWEAPON__);

		return static_cast<WeaponObject*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getCurrentWeapon();
	}
}

void AiAgent::nullifyWeapons() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NULLIFYWEAPONS__);

		method.executeWithVoidReturn();
	} else {
		_implementation->nullifyWeapons();
	}
}

int AiAgent::getMobType() const {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMOBTYPE__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getMobType();
	}
}

bool AiAgent::isHerbivore() const {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISHERBIVORE__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isHerbivore();
	}
}

bool AiAgent::isCarnivore() const {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISCARNIVORE__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isCarnivore();
	}
}

bool AiAgent::isMonster() const {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISMONSTER__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isMonster();
	}
}

bool AiAgent::isDroid() const {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISDROID__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isDroid();
	}
}

bool AiAgent::isAndroid() const {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISANDROID__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isAndroid();
	}
}

bool AiAgent::isNpc() const {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISNPC__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isNpc();
	}
}

bool AiAgent::isHumanoid() const {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISHUMANOID__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isHumanoid();
	}
}

bool AiAgent::isVehicleType() const {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISVEHICLETYPE__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isVehicleType();
	}
}

VectorMap<unsigned long long, int>* AiAgent::getTargetMissCount() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getTargetMissCount();
	}
}

void AiAgent::addTargetMissCount(unsigned long long target, int misses) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDTARGETMISSCOUNT__LONG_INT_);
		method.addUnsignedLongParameter(target);
		method.addSignedIntParameter(misses);

		method.executeWithVoidReturn();
	} else {
		_implementation->addTargetMissCount(target, misses);
	}
}

void AiAgent::setTargetMissCount(unsigned long long target, int misses) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETTARGETMISSCOUNT__LONG_INT_);
		method.addUnsignedLongParameter(target);
		method.addSignedIntParameter(misses);

		method.executeWithVoidReturn();
	} else {
		_implementation->setTargetMissCount(target, misses);
	}
}

void AiAgent::removeTargetMissCount(unsigned long long target) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVETARGETMISSCOUNT__LONG_);
		method.addUnsignedLongParameter(target);

		method.executeWithVoidReturn();
	} else {
		_implementation->removeTargetMissCount(target);
	}
}

String AiAgent::getErrorContext() {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETERRORCONTEXT__);

		String _return_getErrorContext;
		method.executeWithAsciiReturn(_return_getErrorContext);
		return _return_getErrorContext;
	} else {
		return _implementation->getErrorContext();
	}
}

bool AiAgent::isTauntable() const {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISTAUNTABLE__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isTauntable();
	}
}

void AiAgent::setMindTricked(bool val) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETMINDTRICKED__BOOL_);
		method.addBooleanParameter(val);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setMindTricked(val);
	}
}

bool AiAgent::isMindTricked() const {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISMINDTRICKED__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isMindTricked();
	}
}

bool AiAgent::isHamRegenDisabled() const {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISHAMREGENDISABLED__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isHamRegenDisabled();
	}
}

void AiAgent::setHamRegenDisabled(bool val) {
	AiAgentImplementation* _implementation = static_cast<AiAgentImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETHAMREGENDISABLED__BOOL_);
		method.addBooleanParameter(val);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setHamRegenDisabled(val);
	}
}

DistributedObjectServant* AiAgent::_getImplementation() {

	 if (!_updated) _updated = true;
	return _impl;
}

DistributedObjectServant* AiAgent::_getImplementationForRead() const {
	return _impl;
}

void AiAgent::_setImplementation(DistributedObjectServant* servant) {
	_impl = servant;
}

/*
 *	AiAgentImplementation
 */

const float AiAgentImplementation::MAX_OOS_RANGE = 20.0f;

AiAgentImplementation::AiAgentImplementation(DummyConstructorParameter* param) : CreatureObjectImplementation(param) {
	_initializeImplementation();
}


AiAgentImplementation::~AiAgentImplementation() {
	AiAgentImplementation::finalize();
}


void AiAgentImplementation::_initializeImplementation() {
	_setClassHelper(AiAgentHelper::instance());

	_this = NULL;

	_serializationHelperMethod();
}

void AiAgentImplementation::_setStub(DistributedObjectStub* stub) {
	_this = static_cast<AiAgent*>(stub);
	CreatureObjectImplementation::_setStub(stub);
}

DistributedObjectStub* AiAgentImplementation::_getStub() {
	return _this.get();
}

AiAgentImplementation::operator const AiAgent*() {
	return _this.get();
}

void AiAgentImplementation::lock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->lock(doLock);
}

void AiAgentImplementation::lock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->lock(obj);
}

void AiAgentImplementation::rlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->rlock(doLock);
}

void AiAgentImplementation::wlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->wlock(doLock);
}

void AiAgentImplementation::wlock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->wlock(obj);
}

void AiAgentImplementation::unlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->unlock(doLock);
}

void AiAgentImplementation::runlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->runlock(doLock);
}

void AiAgentImplementation::_serializationHelperMethod() {
	CreatureObjectImplementation::_serializationHelperMethod();

	_setClassName("AiAgent");

}

void AiAgentImplementation::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(AiAgentImplementation::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

	initializeTransientMembers();
}

bool AiAgentImplementation::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (CreatureObjectImplementation::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0xbf666870: //AiAgent.skillCommands
		TypeInfo<Vector<String> >::parseFromBinaryStream(&skillCommands, stream);
		return true;

	case 0xd110fe72: //AiAgent.defaultWeapon
		TypeInfo<ManagedReference<WeaponObject* > >::parseFromBinaryStream(&defaultWeapon, stream);
		return true;

	case 0xf6a74276: //AiAgent.primaryWeapon
		TypeInfo<ManagedReference<WeaponObject* > >::parseFromBinaryStream(&primaryWeapon, stream);
		return true;

	case 0x569d4777: //AiAgent.secondaryWeapon
		TypeInfo<ManagedReference<WeaponObject* > >::parseFromBinaryStream(&secondaryWeapon, stream);
		return true;

	case 0xcb2e56a1: //AiAgent.thrownWeapon
		TypeInfo<ManagedReference<WeaponObject* > >::parseFromBinaryStream(&thrownWeapon, stream);
		return true;

	case 0x708319c4: //AiAgent.currentWeapon
		TypeInfo<ManagedReference<WeaponObject* > >::parseFromBinaryStream(&currentWeapon, stream);
		return true;

	case 0x3ce94741: //AiAgent.npcTemplate
		TypeInfo<CreatureTemplateReference >::parseFromBinaryStream(&npcTemplate, stream);
		return true;

	case 0x170c1aa2: //AiAgent.convoTemplateCRC
		TypeInfo<unsigned int >::parseFromBinaryStream(&convoTemplateCRC, stream);
		return true;

	case 0x6ccc7b64: //AiAgent.homeObject
		TypeInfo<ManagedWeakReference<SceneObject* > >::parseFromBinaryStream(&homeObject, stream);
		return true;

	case 0x8abad218: //AiAgent.eventArea
		TypeInfo<ManagedWeakReference<ActiveArea* > >::parseFromBinaryStream(&eventArea, stream);
		return true;

	case 0x903a02dc: //AiAgent.showNextMovementPosition
		TypeInfo<bool >::parseFromBinaryStream(&showNextMovementPosition, stream);
		return true;

	case 0x35937577: //AiAgent.movementMarkers
		TypeInfo<Vector<ManagedReference<SceneObject* > > >::parseFromBinaryStream(&movementMarkers, stream);
		return true;

	case 0x9ad20484: //AiAgent.despawnOnNoPlayerInRange
		TypeInfo<bool >::parseFromBinaryStream(&despawnOnNoPlayerInRange, stream);
		return true;

	case 0x63fb116c: //AiAgent.followObject
		TypeInfo<ManagedWeakReference<SceneObject* > >::parseFromBinaryStream(&followObject, stream);
		return true;

	case 0xab948a97: //AiAgent.followStore
		TypeInfo<ManagedWeakReference<SceneObject* > >::parseFromBinaryStream(&followStore, stream);
		return true;

	case 0x1607a4a3: //AiAgent.movementState
		TypeInfo<unsigned int >::parseFromBinaryStream(&movementState, stream);
		return true;

	case 0xfb7d99f9: //AiAgent.nextBehaviorInterval
		TypeInfo<int >::parseFromBinaryStream(&nextBehaviorInterval, stream);
		return true;

	case 0xc629a7b0: //AiAgent.reactionRank
		TypeInfo<int >::parseFromBinaryStream(&reactionRank, stream);
		return true;

	case 0x1bd8778f: //AiAgent.respawnTimer
		TypeInfo<float >::parseFromBinaryStream(&respawnTimer, stream);
		return true;

	case 0x43da33b7: //AiAgent.respawnCounter
		TypeInfo<int >::parseFromBinaryStream(&respawnCounter, stream);
		return true;

	case 0x6c050a2e: //AiAgent.randomRespawn
		TypeInfo<bool >::parseFromBinaryStream(&randomRespawn, stream);
		return true;

	case 0xdae0cc7f: //AiAgent.coordinateMin
		TypeInfo<float >::parseFromBinaryStream(&coordinateMin, stream);
		return true;

	case 0x63f19ef: //AiAgent.coordinateMax
		TypeInfo<float >::parseFromBinaryStream(&coordinateMax, stream);
		return true;

	case 0x8b8554f8: //AiAgent.loadedOutfit
		TypeInfo<bool >::parseFromBinaryStream(&loadedOutfit, stream);
		return true;

	case 0x8f637eb: //AiAgent.petDeed
		TypeInfo<ManagedReference<PetDeed* > >::parseFromBinaryStream(&petDeed, stream);
		return true;

	case 0x44c03b92: //AiAgent.aiTemplate
		TypeInfo<String >::parseFromBinaryStream(&aiTemplate, stream);
		return true;

	case 0x2b21755e: //AiAgent.lairTemplateCRC
		TypeInfo<unsigned int >::parseFromBinaryStream(&lairTemplateCRC, stream);
		return true;

	case 0x1f128f38: //AiAgent.creatureBitmask
		TypeInfo<unsigned int >::parseFromBinaryStream(&creatureBitmask, stream);
		return true;

	case 0x5eec736c: //AiAgent.fleeRange
		TypeInfo<float >::parseFromBinaryStream(&fleeRange, stream);
		return true;

	case 0x11c742b6: //AiAgent.tauntable
		TypeInfo<bool >::parseFromBinaryStream(&tauntable, stream);
		return true;

	case 0xe272963f: //AiAgent.nextActionCRC
		TypeInfo<unsigned int >::parseFromBinaryStream(&nextActionCRC, stream);
		return true;

	case 0x35f6d4: //AiAgent.nextActionArgs
		TypeInfo<String >::parseFromBinaryStream(&nextActionArgs, stream);
		return true;

	}

	return false;
}

void AiAgentImplementation::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = AiAgentImplementation::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int AiAgentImplementation::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = CreatureObjectImplementation::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	_nameHashCode = 0xbf666870; //AiAgent.skillCommands
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector<String> >::toBinaryStream(&skillCommands, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xd110fe72; //AiAgent.defaultWeapon
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedReference<WeaponObject* > >::toBinaryStream(&defaultWeapon, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xf6a74276; //AiAgent.primaryWeapon
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedReference<WeaponObject* > >::toBinaryStream(&primaryWeapon, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x569d4777; //AiAgent.secondaryWeapon
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedReference<WeaponObject* > >::toBinaryStream(&secondaryWeapon, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xcb2e56a1; //AiAgent.thrownWeapon
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedReference<WeaponObject* > >::toBinaryStream(&thrownWeapon, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x708319c4; //AiAgent.currentWeapon
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedReference<WeaponObject* > >::toBinaryStream(&currentWeapon, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x3ce94741; //AiAgent.npcTemplate
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<CreatureTemplateReference >::toBinaryStream(&npcTemplate, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x170c1aa2; //AiAgent.convoTemplateCRC
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned int >::toBinaryStream(&convoTemplateCRC, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x6ccc7b64; //AiAgent.homeObject
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedWeakReference<SceneObject* > >::toBinaryStream(&homeObject, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x8abad218; //AiAgent.eventArea
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedWeakReference<ActiveArea* > >::toBinaryStream(&eventArea, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x903a02dc; //AiAgent.showNextMovementPosition
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&showNextMovementPosition, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x35937577; //AiAgent.movementMarkers
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector<ManagedReference<SceneObject* > > >::toBinaryStream(&movementMarkers, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x9ad20484; //AiAgent.despawnOnNoPlayerInRange
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&despawnOnNoPlayerInRange, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x63fb116c; //AiAgent.followObject
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedWeakReference<SceneObject* > >::toBinaryStream(&followObject, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xab948a97; //AiAgent.followStore
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedWeakReference<SceneObject* > >::toBinaryStream(&followStore, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x1607a4a3; //AiAgent.movementState
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned int >::toBinaryStream(&movementState, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xfb7d99f9; //AiAgent.nextBehaviorInterval
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&nextBehaviorInterval, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xc629a7b0; //AiAgent.reactionRank
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&reactionRank, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x1bd8778f; //AiAgent.respawnTimer
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&respawnTimer, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x43da33b7; //AiAgent.respawnCounter
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&respawnCounter, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x6c050a2e; //AiAgent.randomRespawn
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&randomRespawn, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xdae0cc7f; //AiAgent.coordinateMin
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&coordinateMin, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x63f19ef; //AiAgent.coordinateMax
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&coordinateMax, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x8b8554f8; //AiAgent.loadedOutfit
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&loadedOutfit, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x8f637eb; //AiAgent.petDeed
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedReference<PetDeed* > >::toBinaryStream(&petDeed, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x44c03b92; //AiAgent.aiTemplate
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&aiTemplate, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x2b21755e; //AiAgent.lairTemplateCRC
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned int >::toBinaryStream(&lairTemplateCRC, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x1f128f38; //AiAgent.creatureBitmask
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned int >::toBinaryStream(&creatureBitmask, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x5eec736c; //AiAgent.fleeRange
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&fleeRange, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x11c742b6; //AiAgent.tauntable
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&tauntable, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xe272963f; //AiAgent.nextActionCRC
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned int >::toBinaryStream(&nextActionCRC, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x35f6d4; //AiAgent.nextActionArgs
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&nextActionArgs, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;


	return _count;
}

void AiAgentImplementation::writeJSON(nlohmann::json& j) {
	CreatureObjectImplementation::writeJSON(j);

	nlohmann::json thisObject = nlohmann::json::object();
	thisObject["skillCommands"] = skillCommands;

	thisObject["defaultWeapon"] = defaultWeapon;

	thisObject["primaryWeapon"] = primaryWeapon;

	thisObject["secondaryWeapon"] = secondaryWeapon;

	thisObject["thrownWeapon"] = thrownWeapon;

	thisObject["currentWeapon"] = currentWeapon;

	thisObject["npcTemplate"] = npcTemplate;

	thisObject["convoTemplateCRC"] = convoTemplateCRC;

	thisObject["homeObject"] = homeObject;

	thisObject["eventArea"] = eventArea;

	thisObject["showNextMovementPosition"] = showNextMovementPosition;

	thisObject["movementMarkers"] = movementMarkers;

	thisObject["despawnOnNoPlayerInRange"] = despawnOnNoPlayerInRange;

	thisObject["followObject"] = followObject;

	thisObject["followStore"] = followStore;

	thisObject["movementState"] = movementState;

	thisObject["nextBehaviorInterval"] = nextBehaviorInterval;

	thisObject["reactionRank"] = reactionRank;

	thisObject["respawnTimer"] = respawnTimer;

	thisObject["respawnCounter"] = respawnCounter;

	thisObject["randomRespawn"] = randomRespawn;

	thisObject["coordinateMin"] = coordinateMin;

	thisObject["coordinateMax"] = coordinateMax;

	thisObject["loadedOutfit"] = loadedOutfit;

	thisObject["petDeed"] = petDeed;

	thisObject["aiTemplate"] = aiTemplate;

	thisObject["lairTemplateCRC"] = lairTemplateCRC;

	thisObject["creatureBitmask"] = creatureBitmask;

	thisObject["fleeRange"] = fleeRange;

	thisObject["tauntable"] = tauntable;

	thisObject["nextActionCRC"] = nextActionCRC;

	thisObject["nextActionArgs"] = nextActionArgs;

	j["AiAgent"] = thisObject;
}

AiAgentImplementation::AiAgentImplementation() {
	_initializeImplementation();
	// server/zone/objects/creature/ai/AiAgent.idl():  		movementState = OBLIVIOUS;
	movementState = OBLIVIOUS;
	// server/zone/objects/creature/ai/AiAgent.idl():  		respawnTimer = 0;
	respawnTimer = 0;
	// server/zone/objects/creature/ai/AiAgent.idl():  		respawnCounter = 0;
	respawnCounter = 0;
	// server/zone/objects/creature/ai/AiAgent.idl():  		randomRespawn = false;
	randomRespawn = false;
	// server/zone/objects/creature/ai/AiAgent.idl():  		nextBehaviorInterval = BEHAVIORINTERVAL;
	nextBehaviorInterval = BEHAVIORINTERVAL;
	// server/zone/objects/creature/ai/AiAgent.idl():  		reactionRank = 0;
	reactionRank = 0;
	// server/zone/objects/creature/ai/AiAgent.idl():  		customAiMap = 0;
	customAiMap = 0;
	// server/zone/objects/creature/ai/AiAgent.idl():  		convoTemplateCRC = 0;
	convoTemplateCRC = 0;
	// server/zone/objects/creature/ai/AiAgent.idl():  		showNextMovementPosition = true;
	showNextMovementPosition = true;
	// server/zone/objects/creature/ai/AiAgent.idl():  		despawnOnNoPlayerInRange = false;
	despawnOnNoPlayerInRange = false;
	// server/zone/objects/creature/ai/AiAgent.idl():  		tauntable = true;
	tauntable = true;
	// server/zone/objects/creature/ai/AiAgent.idl():  		hamRegenDisabled = false;
	hamRegenDisabled = false;
	// server/zone/objects/creature/ai/AiAgent.idl():  		loadedOutfit = false;
	loadedOutfit = false;
	// server/zone/objects/creature/ai/AiAgent.idl():  		mindTricked = false;
	mindTricked = false;
	// server/zone/objects/creature/ai/AiAgent.idl():  		fleeRange = 192;
	fleeRange = 192;
	// server/zone/objects/creature/ai/AiAgent.idl():  		lairTemplateCRC = 0;
	lairTemplateCRC = 0;
	// server/zone/objects/creature/ai/AiAgent.idl():  		aiTemplate = "";
	aiTemplate = "";
	// server/zone/objects/creature/ai/AiAgent.idl():  		customAiMap = 0;
	customAiMap = 0;
	// server/zone/objects/creature/ai/AiAgent.idl():  		coordinateMin = -8192;
	coordinateMin = -8192;
	// server/zone/objects/creature/ai/AiAgent.idl():  		coordinateMax = 8192;
	coordinateMax = 8192;
	// server/zone/objects/creature/ai/AiAgent.idl():  		outOfSightCounter = 0;
	outOfSightCounter = 0;
}

void AiAgentImplementation::finalize() {
}

String AiAgentImplementation::getLogFileName() const{
	// server/zone/objects/creature/ai/AiAgent.idl():  	 return Logger.getLogFileName();
	return Logger::getLogFileName();
}

int AiAgentImplementation::getLogLevel() const{
	// server/zone/objects/creature/ai/AiAgent.idl():  	 return Logger.getLogLevel();
	return Logger::getLogLevel();
}

void AiAgentImplementation::clearPatrolPoints() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		}
{
	Locker _locker((&targetMutex));
	// server/zone/objects/creature/ai/AiAgent.idl():  			int patrolPointsSize = patrolPoints.size();
	int patrolPointsSize = (&patrolPoints)->size();
	// server/zone/objects/creature/ai/AiAgent.idl():  			patrolPoints.
	if (patrolPointsSize > 0 && (movementState == PATROLLING || movementState == WATCHING)){
	// server/zone/objects/creature/ai/AiAgent.idl():  				for 
	if ((&savedPatrolPoints)->size() > 5)	// server/zone/objects/creature/ai/AiAgent.idl():  					savedPatrolPoints.removeAll();
	(&savedPatrolPoints)->removeAll();
	// server/zone/objects/creature/ai/AiAgent.idl():  				}
	for (	// server/zone/objects/creature/ai/AiAgent.idl():  				for (int i = 0;
	int i = 0;
	i < patrolPointsSize;
i ++) {
	// server/zone/objects/creature/ai/AiAgent.idl():  					savedPatrolPoints.add(patrolPoints.get(i));
	(&savedPatrolPoints)->add((&patrolPoints)->get(i));
}
}
	// server/zone/objects/creature/ai/AiAgent.idl():  			patrolPoints.removeAll();
	(&patrolPoints)->removeAll();
}
}

void AiAgentImplementation::clearCurrentPath() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		}
{
	Locker _locker((&targetMutex));
	// server/zone/objects/creature/ai/AiAgent.idl():  			currentFoundPath = null;
	currentFoundPath = NULL;
}
}

void AiAgentImplementation::clearSavedPatrolPoints() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		}
{
	Locker _locker((&targetMutex));
	// server/zone/objects/creature/ai/AiAgent.idl():  			savedPatrolPoints.removeAll();
	(&savedPatrolPoints)->removeAll();
}
}

PatrolPoint AiAgentImplementation::getNextPosition() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		}
{
	Locker _locker((&targetMutex));
	// server/zone/objects/creature/ai/AiAgent.idl():  			return patrolPoints.get(0);
	return (&patrolPoints)->get(0);
}
}

int AiAgentImplementation::getPatrolPointSize() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		}
{
	Locker _locker((&targetMutex));
	// server/zone/objects/creature/ai/AiAgent.idl():  			return patrolPoints.size();
	return (&patrolPoints)->size();
}
}

int AiAgentImplementation::addDotState(CreatureObject* attacker, unsigned long long dotType, unsigned long long objectID, unsigned int strength, byte type, unsigned int duration, float potency, unsigned int defense, int secondaryStrength) {
	// server/zone/objects/creature/ai/AiAgent.idl():  		activateRecovery();
	activateRecovery();
	// server/zone/objects/creature/ai/AiAgent.idl():  		return super.addDotState(attacker, dotType, objectID, strength, type, duration, potency, defense, secondaryStrength);
	return CreatureObjectImplementation::addDotState(attacker, dotType, objectID, strength, type, duration, potency, defense, secondaryStrength);
}

void AiAgentImplementation::destroyObjectFromWorld(bool sendSelfDestroy) {
	// server/zone/objects/creature/ai/AiAgent.idl():  		super.destroyObjectFromWorld(sendSelfDestroy);
	CreatureObjectImplementation::destroyObjectFromWorld(sendSelfDestroy);
	// server/zone/objects/creature/ai/AiAgent.idl():  		numberOfPlayersInRange.set(0);
	(&numberOfPlayersInRange)->set(0);
	// server/zone/objects/creature/ai/AiAgent.idl():  	}
	if (behaviorEvent){
	// server/zone/objects/creature/ai/AiAgent.idl():  			cancelBehaviorEvent();
	cancelBehaviorEvent();
}
}

void AiAgentImplementation::destroyObjectFromDatabase(bool destroyContainedObjects) {
	// server/zone/objects/creature/ai/AiAgent.idl():  		super.
	if (petDeed){
	// server/zone/objects/creature/ai/AiAgent.idl():  			petDeed.destroyObjectFromDatabase(true);
	petDeed->destroyObjectFromDatabase(true);
}
	// server/zone/objects/creature/ai/AiAgent.idl():  		super.destroyObjectFromDatabase(destroyContainedObjects);
	CreatureObjectImplementation::destroyObjectFromDatabase(destroyContainedObjects);
}

void AiAgentImplementation::scheduleDespawn() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		scheduleDespawn(300);
	scheduleDespawn(300);
}

void AiAgentImplementation::addPatrolPoint(PatrolPoint& point) {
	// server/zone/objects/creature/ai/AiAgent.idl():  		}
{
	Locker _locker((&targetMutex));
	// server/zone/objects/creature/ai/AiAgent.idl():  			patrolPoints.add(point);
	(&patrolPoints)->add(point);
}
}

void AiAgentImplementation::setHomeLocation(float x, float z, float y, CellObject* cell, float direction) {
	// server/zone/objects/creature/ai/AiAgent.idl():  		homeLocation.setPosition(x, z, y);
	(&homeLocation)->setPosition(x, z, y);
	// server/zone/objects/creature/ai/AiAgent.idl():  		homeLocation.setCell(cell);
	(&homeLocation)->setCell(cell);
	// server/zone/objects/creature/ai/AiAgent.idl():  		homeLocation.setReached(true);
	(&homeLocation)->setReached(true);
	// server/zone/objects/creature/ai/AiAgent.idl():  		homeLocation.setDirection(direction);
	(&homeLocation)->setDirection(direction);
}

void AiAgentImplementation::setRespawnTimer(float resp) {
	// server/zone/objects/creature/ai/AiAgent.idl():  		respawnTimer = resp;
	respawnTimer = resp;
}

void AiAgentImplementation::setRandomRespawn(bool resp) {
	// server/zone/objects/creature/ai/AiAgent.idl():  		randomRespawn = resp;
	randomRespawn = resp;
}

void AiAgentImplementation::resetRespawnCounter() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		respawnCounter = 0;
	respawnCounter = 0;
}

void AiAgentImplementation::setOblivious() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		}
{
	Locker _locker((&targetMutex));
	// server/zone/objects/creature/ai/AiAgent.idl():  			setMovementState(OBLIVIOUS);
	setMovementState(OBLIVIOUS);
	// server/zone/objects/creature/ai/AiAgent.idl():  			setTargetObject(null);
	setTargetObject(NULL);
	// server/zone/objects/creature/ai/AiAgent.idl():  			clearState(CreatureState.PEACE);
	clearState(CreatureState::PEACE);
}
}

void AiAgentImplementation::setWatchObject(SceneObject* obj) {
	// server/zone/objects/creature/ai/AiAgent.idl():  		}
{
	Locker _locker((&targetMutex));
	// server/zone/objects/creature/ai/AiAgent.idl():  			setMovementState(
	if (_this.getReferenceUnsafeStaticCast()->isRetreating())	// server/zone/objects/creature/ai/AiAgent.idl():  				return;
	return;
	// server/zone/objects/creature/ai/AiAgent.idl():  			setMovementState(WATCHING);
	setMovementState(WATCHING);
	// server/zone/objects/creature/ai/AiAgent.idl():  			setTargetObject(obj);
	setTargetObject(obj);
}
}

void AiAgentImplementation::setStalkObject(SceneObject* obj) {
	// server/zone/objects/creature/ai/AiAgent.idl():  		}
{
	Locker _locker((&targetMutex));
	// server/zone/objects/creature/ai/AiAgent.idl():  			setMovementState(
	if (_this.getReferenceUnsafeStaticCast()->isRetreating())	// server/zone/objects/creature/ai/AiAgent.idl():  				return;
	return;
	// server/zone/objects/creature/ai/AiAgent.idl():  			setMovementState(STALKING);
	setMovementState(STALKING);
	// server/zone/objects/creature/ai/AiAgent.idl():  			setTargetObject(obj);
	setTargetObject(obj);
}
}

void AiAgentImplementation::setFollowObject(SceneObject* obj) {
	// server/zone/objects/creature/ai/AiAgent.idl():  		}
{
	Locker _locker((&targetMutex));
	// server/zone/objects/creature/ai/AiAgent.idl():  			if 
	if (_this.getReferenceUnsafeStaticCast()->isRetreating())	// server/zone/objects/creature/ai/AiAgent.idl():  				return;
	return;
	// server/zone/objects/creature/ai/AiAgent.idl():  		}
	if (obj != NULL && followObject != obj){
	// server/zone/objects/creature/ai/AiAgent.idl():  				setMovementState(FOLLOWING);
	setMovementState(FOLLOWING);
	// server/zone/objects/creature/ai/AiAgent.idl():  				setTargetObject(obj);
	setTargetObject(obj);
}
}
}

void AiAgentImplementation::setTargetObject(SceneObject* obj) {
	// server/zone/objects/creature/ai/AiAgent.idl():  		}
{
	Locker _locker((&targetMutex));
	// server/zone/objects/creature/ai/AiAgent.idl():  		}
	if (followObject != obj){
	// server/zone/objects/creature/ai/AiAgent.idl():  				clearPatrolPoints();
	clearPatrolPoints();
	// server/zone/objects/creature/ai/AiAgent.idl():  				followObject = obj;
	followObject = obj;
}
}
}

ManagedWeakReference<SceneObject* > AiAgentImplementation::getFollowObject() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return followObject;
	return followObject;
}

void AiAgentImplementation::storeFollowObject() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		}
{
	Locker _locker((&targetMutex));
	// server/zone/objects/creature/ai/AiAgent.idl():  			followStore = followObject;
	followStore = followObject;
}
}

unsigned int AiAgentImplementation::getMovementState() const{
	// server/zone/objects/creature/ai/AiAgent.idl():  		return movementState;
	return movementState;
}

void AiAgentImplementation::setMovementState(int state) {
	// server/zone/objects/creature/ai/AiAgent.idl():  		}
{
	Locker _locker((&targetMutex));
	// server/zone/objects/creature/ai/AiAgent.idl():  			int oldState = movementState;
	int oldState = movementState;
	// server/zone/objects/creature/ai/AiAgent.idl():  			movementState 
	if (state != PATROLLING && state != WATCHING)	// server/zone/objects/creature/ai/AiAgent.idl():  				clearPatrolPoints();
	clearPatrolPoints();
	// server/zone/objects/creature/ai/AiAgent.idl():  			movementState = state;
	movementState = state;
	// server/zone/objects/creature/ai/AiAgent.idl():  		}
	if (oldState == LEASHING || state == LEASHING)	// server/zone/objects/creature/ai/AiAgent.idl():  				broadcastPvpStatusBitmask();
	broadcastPvpStatusBitmask();
}
}

bool AiAgentImplementation::isRetreating() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return getMovementState() == LEASHING;
	return getMovementState() == LEASHING;
}

bool AiAgentImplementation::isFleeing() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return getMovementState() == FLEEING;
	return getMovementState() == FLEEING;
}

bool AiAgentImplementation::isResting() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return getMovementState() == RESTING;
	return getMovementState() == RESTING;
}

float AiAgentImplementation::getKinetic() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		if 
	if (petDeed){
	// server/zone/objects/creature/ai/AiAgent.idl():  			return getReducedResist(petDeed.getKinetic());
	return getReducedResist(petDeed->getKinetic());
}
	// server/zone/objects/creature/ai/AiAgent.idl():  		return 
	if (!(&npcTemplate)->get())	// server/zone/objects/creature/ai/AiAgent.idl():  			return 0;
	return 0;
	// server/zone/objects/creature/ai/AiAgent.idl():  		return getReducedResist(npcTemplate.get().getKinetic());
	return getReducedResist((&npcTemplate)->get()->getKinetic());
}

float AiAgentImplementation::getEnergy() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		if 
	if (petDeed){
	// server/zone/objects/creature/ai/AiAgent.idl():  			return getReducedResist(petDeed.getEnergy());
	return getReducedResist(petDeed->getEnergy());
}
	// server/zone/objects/creature/ai/AiAgent.idl():  		return 
	if (!(&npcTemplate)->get())	// server/zone/objects/creature/ai/AiAgent.idl():  			return 0;
	return 0;
	// server/zone/objects/creature/ai/AiAgent.idl():  		return getReducedResist(npcTemplate.get().getEnergy());
	return getReducedResist((&npcTemplate)->get()->getEnergy());
}

float AiAgentImplementation::getElectricity() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		if 
	if (petDeed){
	// server/zone/objects/creature/ai/AiAgent.idl():  			return getReducedResist(petDeed.getElectric());
	return getReducedResist(petDeed->getElectric());
}
	// server/zone/objects/creature/ai/AiAgent.idl():  		return 
	if (!(&npcTemplate)->get())	// server/zone/objects/creature/ai/AiAgent.idl():  			return 0;
	return 0;
	// server/zone/objects/creature/ai/AiAgent.idl():  		return getReducedResist(npcTemplate.get().getElectricity());
	return getReducedResist((&npcTemplate)->get()->getElectricity());
}

float AiAgentImplementation::getStun() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		if 
	if (petDeed){
	// server/zone/objects/creature/ai/AiAgent.idl():  			return getReducedResist(petDeed.getStun());
	return getReducedResist(petDeed->getStun());
}
	// server/zone/objects/creature/ai/AiAgent.idl():  		return 
	if (!(&npcTemplate)->get())	// server/zone/objects/creature/ai/AiAgent.idl():  			return 0;
	return 0;
	// server/zone/objects/creature/ai/AiAgent.idl():  		return getReducedResist(npcTemplate.get().getStun());
	return getReducedResist((&npcTemplate)->get()->getStun());
}

float AiAgentImplementation::getBlast() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		if 
	if (petDeed){
	// server/zone/objects/creature/ai/AiAgent.idl():  			return getReducedResist(petDeed.getBlast());
	return getReducedResist(petDeed->getBlast());
}
	// server/zone/objects/creature/ai/AiAgent.idl():  		return 
	if (!(&npcTemplate)->get())	// server/zone/objects/creature/ai/AiAgent.idl():  			return 0;
	return 0;
	// server/zone/objects/creature/ai/AiAgent.idl():  		return getReducedResist(npcTemplate.get().getBlast());
	return getReducedResist((&npcTemplate)->get()->getBlast());
}

float AiAgentImplementation::getHeat() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		if 
	if (petDeed){
	// server/zone/objects/creature/ai/AiAgent.idl():  			return getReducedResist(petDeed.getHeat());
	return getReducedResist(petDeed->getHeat());
}
	// server/zone/objects/creature/ai/AiAgent.idl():  		return 
	if (!(&npcTemplate)->get())	// server/zone/objects/creature/ai/AiAgent.idl():  			return 0;
	return 0;
	// server/zone/objects/creature/ai/AiAgent.idl():  		return getReducedResist(npcTemplate.get().getHeat());
	return getReducedResist((&npcTemplate)->get()->getHeat());
}

float AiAgentImplementation::getCold() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		if 
	if (petDeed){
	// server/zone/objects/creature/ai/AiAgent.idl():  			return getReducedResist(petDeed.getCold());
	return getReducedResist(petDeed->getCold());
}
	// server/zone/objects/creature/ai/AiAgent.idl():  		return 
	if ((&npcTemplate)->get() == NULL)	// server/zone/objects/creature/ai/AiAgent.idl():  			return 0;
	return 0;
	// server/zone/objects/creature/ai/AiAgent.idl():  		return getReducedResist(npcTemplate.get().getCold());
	return getReducedResist((&npcTemplate)->get()->getCold());
}

float AiAgentImplementation::getAcid() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		if 
	if (petDeed){
	// server/zone/objects/creature/ai/AiAgent.idl():  			return getReducedResist(petDeed.getAcid());
	return getReducedResist(petDeed->getAcid());
}
	// server/zone/objects/creature/ai/AiAgent.idl():  		return 
	if ((&npcTemplate)->get() == NULL)	// server/zone/objects/creature/ai/AiAgent.idl():  			return 0;
	return 0;
	// server/zone/objects/creature/ai/AiAgent.idl():  		return getReducedResist(npcTemplate.get().getAcid());
	return getReducedResist((&npcTemplate)->get()->getAcid());
}

float AiAgentImplementation::getLightSaber() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		if 
	if (petDeed){
	// server/zone/objects/creature/ai/AiAgent.idl():  			return getReducedResist(petDeed.getSaber());
	return getReducedResist(petDeed->getSaber());
}
	// server/zone/objects/creature/ai/AiAgent.idl():  		return 
	if ((&npcTemplate)->get() == NULL)	// server/zone/objects/creature/ai/AiAgent.idl():  			return 0;
	return 0;
	// server/zone/objects/creature/ai/AiAgent.idl():  		return getReducedResist(npcTemplate.get().getLightSaber());
	return getReducedResist((&npcTemplate)->get()->getLightSaber());
}

bool AiAgentImplementation::isSpecialProtection(int resistType) {
	// server/zone/objects/creature/ai/AiAgent.idl():  		if 
	if (petDeed){
	// server/zone/objects/creature/ai/AiAgent.idl():  			return petDeed.isSpecialResist(resistType);
	return petDeed->isSpecialResist(resistType);
}
	// server/zone/objects/creature/ai/AiAgent.idl():  		return 
	if ((&npcTemplate)->get() == NULL)	// server/zone/objects/creature/ai/AiAgent.idl():  			return false;
	return false;
	// server/zone/objects/creature/ai/AiAgent.idl():  		return npcTemplate.get().isSpecialProtection(resistType);
	return (&npcTemplate)->get()->isSpecialProtection(resistType);
}

bool AiAgentImplementation::isStalker() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return 
	if ((&npcTemplate)->get() == NULL)	// server/zone/objects/creature/ai/AiAgent.idl():  			return false;
	return false;
	// server/zone/objects/creature/ai/AiAgent.idl():  		return npcTemplate.get().isStalker();
	return (&npcTemplate)->get()->isStalker();
}

bool AiAgentImplementation::isKiller() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return 
	if ((&npcTemplate)->get() == NULL)	// server/zone/objects/creature/ai/AiAgent.idl():  			return false;
	return false;
	// server/zone/objects/creature/ai/AiAgent.idl():  		return npcTemplate.get().isKiller();
	return (&npcTemplate)->get()->isKiller();
}

bool AiAgentImplementation::isHealer() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return 
	if ((&npcTemplate)->get() == NULL)	// server/zone/objects/creature/ai/AiAgent.idl():  			return false;
	return false;
	// server/zone/objects/creature/ai/AiAgent.idl():  		return npcTemplate.get().isHealer();
	return (&npcTemplate)->get()->isHealer();
}

unsigned int AiAgentImplementation::getFerocity() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return 
	if ((&npcTemplate)->get() == NULL)	// server/zone/objects/creature/ai/AiAgent.idl():  			return 0;
	return 0;
	// server/zone/objects/creature/ai/AiAgent.idl():  		return npcTemplate.get().getFerocity();
	return (&npcTemplate)->get()->getFerocity();
}

int AiAgentImplementation::getAggroRadius() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return 
	if ((&npcTemplate)->get() == NULL)	// server/zone/objects/creature/ai/AiAgent.idl():  			return 0;
	return 0;
	// server/zone/objects/creature/ai/AiAgent.idl():  		return npcTemplate.get().getAggroRadius();
	return (&npcTemplate)->get()->getAggroRadius();
}

unsigned int AiAgentImplementation::getArmor() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		if 
	if (petDeed){
	// server/zone/objects/creature/ai/AiAgent.idl():  			return petDeed.getArmor();
	return petDeed->getArmor();
}
	// server/zone/objects/creature/ai/AiAgent.idl():  		return 
	if ((&npcTemplate)->get() == NULL)	// server/zone/objects/creature/ai/AiAgent.idl():  			return 0;
	return 0;
	// server/zone/objects/creature/ai/AiAgent.idl():  		return npcTemplate.get().getArmor();
	return (&npcTemplate)->get()->getArmor();
}

bool AiAgentImplementation::getDespawnOnNoPlayerInRange() const{
	// server/zone/objects/creature/ai/AiAgent.idl():  		return despawnOnNoPlayerInRange;
	return despawnOnNoPlayerInRange;
}

int AiAgentImplementation::getNumberOfPlayersInRange() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return numberOfPlayersInRange.get();
	return (&numberOfPlayersInRange)->get();
}

String AiAgentImplementation::getFactionString() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return 
	if ((&npcTemplate)->get() == NULL)	// server/zone/objects/creature/ai/AiAgent.idl():  			return "";
	return "";
	// server/zone/objects/creature/ai/AiAgent.idl():  		return npcTemplate.get().getFaction();
	return (&npcTemplate)->get()->getFaction();
}

String AiAgentImplementation::getSocialGroup() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return 
	if ((&npcTemplate)->get() == NULL)	// server/zone/objects/creature/ai/AiAgent.idl():  			return "";
	return "";
	// server/zone/objects/creature/ai/AiAgent.idl():  		return npcTemplate.get().getSocialGroup();
	return (&npcTemplate)->get()->getSocialGroup();
}

String AiAgentImplementation::getHealerType() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return 
	if ((&npcTemplate)->get() == NULL)	// server/zone/objects/creature/ai/AiAgent.idl():  			return "";
	return "";
	// server/zone/objects/creature/ai/AiAgent.idl():  		return npcTemplate.get().getHealerType();
	return (&npcTemplate)->get()->getHealerType();
}

float AiAgentImplementation::getChanceHit() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		if 
	if (petDeed){
	// server/zone/objects/creature/ai/AiAgent.idl():  			return petDeed.getHitChance();
	return petDeed->getHitChance();
}
	// server/zone/objects/creature/ai/AiAgent.idl():  		return 
	if ((&npcTemplate)->get() == NULL)	// server/zone/objects/creature/ai/AiAgent.idl():  			return 0;
	return 0;
	// server/zone/objects/creature/ai/AiAgent.idl():  		return npcTemplate.get().getChanceHit();
	return (&npcTemplate)->get()->getChanceHit();
}

float AiAgentImplementation::getSpecialDamageMult() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return 
	if ((&npcTemplate)->get() == NULL)	// server/zone/objects/creature/ai/AiAgent.idl():  			return 1.f;
	return 1.f;
	// server/zone/objects/creature/ai/AiAgent.idl():  		return npcTemplate.get().getSpecialDamageMult();
	return (&npcTemplate)->get()->getSpecialDamageMult();
}

int AiAgentImplementation::getBaseXp() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		if 
	if (petDeed){
	// server/zone/objects/creature/ai/AiAgent.idl():  			return 100;
	return 100;
}
	// server/zone/objects/creature/ai/AiAgent.idl():  		return 
	if ((&npcTemplate)->get() == NULL || isEventMob())	// server/zone/objects/creature/ai/AiAgent.idl():  			return 0;
	return 0;
	// server/zone/objects/creature/ai/AiAgent.idl():  		return npcTemplate.get().getBaseXp();
	return (&npcTemplate)->get()->getBaseXp();
}

unsigned int AiAgentImplementation::getDiet() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return 
	if ((&npcTemplate)->get() == NULL)	// server/zone/objects/creature/ai/AiAgent.idl():  			return 0;
	return 0;
	// server/zone/objects/creature/ai/AiAgent.idl():  		return npcTemplate.get().getDiet();
	return (&npcTemplate)->get()->getDiet();
}

unsigned int AiAgentImplementation::getTemplateLevel() const{
	// server/zone/objects/creature/ai/AiAgent.idl():  		if 
	if (petDeed){
	// server/zone/objects/creature/ai/AiAgent.idl():  			return petDeed.getLevel();
	return petDeed->getLevel();
}
	// server/zone/objects/creature/ai/AiAgent.idl():  		return 
	if ((&npcTemplate)->get() == NULL)	// server/zone/objects/creature/ai/AiAgent.idl():  			return 1;
	return 1;
	// server/zone/objects/creature/ai/AiAgent.idl():  		return npcTemplate.get().getLevel();
	return (&npcTemplate)->get()->getLevel();
}

float AiAgentImplementation::getTame() const{
	// server/zone/objects/creature/ai/AiAgent.idl():  		if 
	if (petDeed){
	// server/zone/objects/creature/ai/AiAgent.idl():  			return 1;
	return 1;
}
	// server/zone/objects/creature/ai/AiAgent.idl():  		return 
	if ((&npcTemplate)->get() == NULL)	// server/zone/objects/creature/ai/AiAgent.idl():  			return 0;
	return 0;
	// server/zone/objects/creature/ai/AiAgent.idl():  		return npcTemplate.get().getTame();
	return (&npcTemplate)->get()->getTame();
}

const CreatureAttackMap* AiAgentImplementation::getAttackMap() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		}
	if (currentWeapon == primaryWeapon){
	// server/zone/objects/creature/ai/AiAgent.idl():  			return primaryAttackMap;
	return primaryAttackMap;
}

	else 	// server/zone/objects/creature/ai/AiAgent.idl():  		}
	if (currentWeapon == secondaryWeapon){
	// server/zone/objects/creature/ai/AiAgent.idl():  			return secondaryAttackMap;
	return secondaryAttackMap;
}

	else {
	// server/zone/objects/creature/ai/AiAgent.idl():  			return defaultAttackMap;
	return defaultAttackMap;
}
}

const CreatureAttackMap* AiAgentImplementation::getPrimaryAttackMap() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return primaryAttackMap;
	return primaryAttackMap;
}

const LootGroupCollection* AiAgentImplementation::getLootGroups() const{
	// server/zone/objects/creature/ai/AiAgent.idl():  		return 
	if ((&npcTemplate)->get() == NULL || isEventMob())	// server/zone/objects/creature/ai/AiAgent.idl():  			return null;
	return NULL;
	// server/zone/objects/creature/ai/AiAgent.idl():  		return npcTemplate.get().getLootGroups();
	return (&npcTemplate)->get()->getLootGroups();
}

String AiAgentImplementation::getReactionStf() const{
	// server/zone/objects/creature/ai/AiAgent.idl():  		return 
	if ((&npcTemplate)->get() == NULL)	// server/zone/objects/creature/ai/AiAgent.idl():  			return "";
	return "";
	// server/zone/objects/creature/ai/AiAgent.idl():  		return npcTemplate.get().getReactionStf();
	return (&npcTemplate)->get()->getReactionStf();
}

float AiAgentImplementation::getRespawnTimer() const{
	// server/zone/objects/creature/ai/AiAgent.idl():  		return respawnTimer;
	return respawnTimer;
}

bool AiAgentImplementation::getRandomRespawn() const{
	// server/zone/objects/creature/ai/AiAgent.idl():  		return randomRespawn;
	return randomRespawn;
}

int AiAgentImplementation::getRespawnCounter() const{
	// server/zone/objects/creature/ai/AiAgent.idl():  		return respawnCounter;
	return respawnCounter;
}

PatrolPoint* AiAgentImplementation::getHomeLocation() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return homeLocation;
	return (&homeLocation);
}

bool AiAgentImplementation::isAiAgent() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return true;
	return true;
}

const CreatureTemplate* AiAgentImplementation::getCreatureTemplate() const{
	// server/zone/objects/creature/ai/AiAgent.idl():  		return npcTemplate.get();
	return (&npcTemplate)->get();
}

void AiAgentImplementation::setShowNextPosition(bool val) {
	// server/zone/objects/creature/ai/AiAgent.idl():  		showNextMovementPosition = val;
	showNextMovementPosition = val;
}

void AiAgentImplementation::setHomeObject(SceneObject* home) {
	// server/zone/objects/creature/ai/AiAgent.idl():  		homeObject = home;
	homeObject = home;
}

ManagedWeakReference<SceneObject* > AiAgentImplementation::getHomeObject() const{
	// server/zone/objects/creature/ai/AiAgent.idl():  		return homeObject;
	return homeObject;
}

void AiAgentImplementation::setEventArea(ActiveArea* area) {
	// server/zone/objects/creature/ai/AiAgent.idl():  		eventArea = area;
	eventArea = area;
}

ManagedWeakReference<ActiveArea* > AiAgentImplementation::getEventArea() const{
	// server/zone/objects/creature/ai/AiAgent.idl():  		return eventArea;
	return eventArea;
}

unsigned int AiAgentImplementation::getCreatureBitmask() const{
	// server/zone/objects/creature/ai/AiAgent.idl():  		return creatureBitmask;
	return creatureBitmask;
}

void AiAgentImplementation::setCreatureBitmask(unsigned int mask) {
	// server/zone/objects/creature/ai/AiAgent.idl():  		creatureBitmask = mask;
	creatureBitmask = mask;
}

Time* AiAgentImplementation::getAlertedTime() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return alertedTime;
	return (&alertedTime);
}

Time* AiAgentImplementation::getAggroDelay() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return aggroDelay;
	return (&aggroDelay);
}

Time* AiAgentImplementation::getPostureSet() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return postureSet;
	return (&postureSet);
}

Time* AiAgentImplementation::getHealDelay() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return healDelay;
	return (&healDelay);
}

Time* AiAgentImplementation::getRestDelay() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return restDelay;
	return (&restDelay);
}

Time* AiAgentImplementation::getFleeDelay() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return fleeDelay;
	return (&fleeDelay);
}

Time* AiAgentImplementation::getLastPackNotify() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return lastPackNotify;
	return (&lastPackNotify);
}

Time* AiAgentImplementation::getLastCallForHelp() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return lastCallForHelp;
	return (&lastCallForHelp);
}

void AiAgentImplementation::setPetDeed(PetDeed* deed) {
	// server/zone/objects/creature/ai/AiAgent.idl():  		petDeed = deed;
	petDeed = deed;
}

bool AiAgentImplementation::hasPetDeed() const{
	// server/zone/objects/creature/ai/AiAgent.idl():  		return petDeed;
	return petDeed;
}

PetDeed* AiAgentImplementation::getPetDeed() const{
	// server/zone/objects/creature/ai/AiAgent.idl():  		return petDeed;
	return petDeed;
}

bool AiAgentImplementation::hasReactionChatMessages() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return getReactionStf() != "";
	return getReactionStf() != "";
}

int AiAgentImplementation::getReactionRank() const{
	// server/zone/objects/creature/ai/AiAgent.idl():  		return reactionRank;
	return reactionRank;
}

void AiAgentImplementation::setReactionRank(int rank) {
	// server/zone/objects/creature/ai/AiAgent.idl():  		reactionRank = rank;
	reactionRank = rank;
}

int AiAgentImplementation::getHamMaximum() const{
	// server/zone/objects/creature/ai/AiAgent.idl():  		return npcTemplate.get().getBaseHAMmax();
	return (&npcTemplate)->get()->getBaseHAMmax();
}

int AiAgentImplementation::getHamBase() const{
	// server/zone/objects/creature/ai/AiAgent.idl():  		return npcTemplate.get().getBaseHAM();
	return (&npcTemplate)->get()->getBaseHAM();
}

unsigned int AiAgentImplementation::getConvoTemplateCRC() const{
	// server/zone/objects/creature/ai/AiAgent.idl():  		return convoTemplateCRC;
	return convoTemplateCRC;
}

void AiAgentImplementation::setLairTemplateCRC(unsigned int crc) {
	// server/zone/objects/creature/ai/AiAgent.idl():  		lairTemplateCRC = crc;
	lairTemplateCRC = crc;
}

unsigned int AiAgentImplementation::getLairTemplateCRC() const{
	// server/zone/objects/creature/ai/AiAgent.idl():  		return lairTemplateCRC;
	return lairTemplateCRC;
}

bool AiAgentImplementation::peekBlackboard(const String& key) {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return blackboard.contains(key);
	return (&blackboard)->contains(key);
}

BlackboardData AiAgentImplementation::readBlackboard(const String& key) {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return blackboard.get(key);
	return (&blackboard)->get(key);
}

void AiAgentImplementation::eraseBlackboard(const String& key) {
	// server/zone/objects/creature/ai/AiAgent.idl():  		blackboard.drop(key);
	(&blackboard)->drop(key);
}

void AiAgentImplementation::wipeBlackboard() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		blackboard.removeAll();
	(&blackboard)->removeAll();
}

void AiAgentImplementation::setCustomAiMap(unsigned long long customMap) {
	// server/zone/objects/creature/ai/AiAgent.idl():  		customAiMap = customMap;
	customAiMap = customMap;
}

void AiAgentImplementation::setCurrentWeapon(WeaponObject* weap) {
	// server/zone/objects/creature/ai/AiAgent.idl():  		currentWeapon = weap;
	currentWeapon = weap;
}

void AiAgentImplementation::setDefaultWeapon(WeaponObject* weap) {
	// server/zone/objects/creature/ai/AiAgent.idl():  		defaultWeapon = weap;
	defaultWeapon = weap;
}

WeaponObject* AiAgentImplementation::getPrimaryWeapon() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return primaryWeapon;
	return primaryWeapon;
}

WeaponObject* AiAgentImplementation::getSecondaryWeapon() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return secondaryWeapon;
	return secondaryWeapon;
}

WeaponObject* AiAgentImplementation::getDefaultWeapon() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return defaultWeapon;
	return defaultWeapon;
}

WeaponObject* AiAgentImplementation::getThrownWeapon() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return thrownWeapon;
	return thrownWeapon;
}

void AiAgentImplementation::clearThrownWeapon() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		thrownWeapon = null;
	thrownWeapon = NULL;
}

WeaponObject* AiAgentImplementation::getCurrentWeapon() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return defaultWeapon;
	return defaultWeapon;
}

void AiAgentImplementation::nullifyWeapons() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		primaryWeapon = null;
	primaryWeapon = NULL;
	// server/zone/objects/creature/ai/AiAgent.idl():  		secondaryWeapon = null;
	secondaryWeapon = NULL;
	// server/zone/objects/creature/ai/AiAgent.idl():  		thrownWeapon = null;
	thrownWeapon = NULL;
	// server/zone/objects/creature/ai/AiAgent.idl():  		currentWeapon = null;
	currentWeapon = NULL;
}

int AiAgentImplementation::getMobType() const{
	// server/zone/objects/creature/ai/AiAgent.idl():  		return 
	if ((&npcTemplate)->get() == NULL)	// server/zone/objects/creature/ai/AiAgent.idl():  			return 0;
	return 0;
	// server/zone/objects/creature/ai/AiAgent.idl():  		return npcTemplate.get().getMobType();
	return (&npcTemplate)->get()->getMobType();
}

bool AiAgentImplementation::isHerbivore() const{
	// server/zone/objects/creature/ai/AiAgent.idl():  		return getMobType() == MOB_HERBIVORE;
	return getMobType() == MOB_HERBIVORE;
}

bool AiAgentImplementation::isCarnivore() const{
	// server/zone/objects/creature/ai/AiAgent.idl():  		return getMobType() == MOB_CARNIVORE;
	return getMobType() == MOB_CARNIVORE;
}

bool AiAgentImplementation::isMonster() const{
	// server/zone/objects/creature/ai/AiAgent.idl():  		int type = getMobType();
	int type = getMobType();
	// server/zone/objects/creature/ai/AiAgent.idl():  		return type == MOB_HERBIVORE || type == MOB_CARNIVORE;
	return type == MOB_HERBIVORE || type == MOB_CARNIVORE;
}

bool AiAgentImplementation::isDroid() const{
	// server/zone/objects/creature/ai/AiAgent.idl():  		return getMobType() == MOB_DROID;
	return getMobType() == MOB_DROID;
}

bool AiAgentImplementation::isAndroid() const{
	// server/zone/objects/creature/ai/AiAgent.idl():  		return getMobType() == MOB_ANDROID;
	return getMobType() == MOB_ANDROID;
}

bool AiAgentImplementation::isNpc() const{
	// server/zone/objects/creature/ai/AiAgent.idl():  		return getMobType() == MOB_NPC;
	return getMobType() == MOB_NPC;
}

bool AiAgentImplementation::isHumanoid() const{
	// server/zone/objects/creature/ai/AiAgent.idl():  		int type = getMobType();
	int type = getMobType();
	// server/zone/objects/creature/ai/AiAgent.idl():  		return type == MOB_ANDROID || type == MOB_NPC;
	return type == MOB_ANDROID || type == MOB_NPC;
}

bool AiAgentImplementation::isVehicleType() const{
	// server/zone/objects/creature/ai/AiAgent.idl():  		return getMobType() == MOB_VEHICLE;
	return getMobType() == MOB_VEHICLE;
}

VectorMap<unsigned long long, int>* AiAgentImplementation::getTargetMissCount() {
	// server/zone/objects/creature/ai/AiAgent.idl():  		return targetMissCount;
	return (&targetMissCount);
}

void AiAgentImplementation::addTargetMissCount(unsigned long long target, int misses) {
	// server/zone/objects/creature/ai/AiAgent.idl():  		targetMissCount.put(target, misses);
	(&targetMissCount)->put(target, misses);
}

void AiAgentImplementation::setTargetMissCount(unsigned long long target, int misses) {
	// server/zone/objects/creature/ai/AiAgent.idl():  		targetMissCount.drop(target);
	(&targetMissCount)->drop(target);
	// server/zone/objects/creature/ai/AiAgent.idl():  		targetMissCount.put(target, misses);
	(&targetMissCount)->put(target, misses);
}

void AiAgentImplementation::removeTargetMissCount(unsigned long long target) {
	// server/zone/objects/creature/ai/AiAgent.idl():  		targetMissCount.drop(target);
	(&targetMissCount)->drop(target);
}

bool AiAgentImplementation::isTauntable() const{
	// server/zone/objects/creature/ai/AiAgent.idl():  		return tauntable;
	return tauntable;
}

void AiAgentImplementation::setMindTricked(bool val) {
	// server/zone/objects/creature/ai/AiAgent.idl():  		mindTricked = val;
	mindTricked = val;
}

bool AiAgentImplementation::isMindTricked() const{
	// server/zone/objects/creature/ai/AiAgent.idl():  		return mindTricked;
	return mindTricked;
}

bool AiAgentImplementation::isHamRegenDisabled() const{
	// server/zone/objects/creature/ai/AiAgent.idl():  		return hamRegenDisabled;
	return hamRegenDisabled;
}

void AiAgentImplementation::setHamRegenDisabled(bool val) {
	// server/zone/objects/creature/ai/AiAgent.idl():  		hamRegenDisabled = val;
	hamRegenDisabled = val;
}

/*
 *	AiAgentAdapter
 */


#include "engine/orb/messages/InvokeMethodMessage.h"


AiAgentAdapter::AiAgentAdapter(AiAgent* obj) : CreatureObjectAdapter(obj) {
}

void AiAgentAdapter::invokeMethod(uint32 methid, DistributedMethod* inv) {
	DOBMessage* resp = inv->getInvocationMessage();

	switch (methid) {
	case RPC_INITIALIZETRANSIENTMEMBERS__:
		{
			
			initializeTransientMembers();
			
		}
		break;
	case RPC_NOTIFYLOADFROMDATABASE__:
		{
			
			notifyLoadFromDatabase();
			
		}
		break;
	case RPC_FINALIZE__:
		{
			
			finalize();
			
		}
		break;
	case RPC_GETLOGFILENAME__:
		{
			
			String _m_res = getLogFileName();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_GETLOGLEVEL__:
		{
			
			int _m_res = getLogLevel();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_ACTIVATERECOVERY__:
		{
			
			activateRecovery();
			
		}
		break;
	case RPC_ACTIVATEAIBEHAVIOR__BOOL_:
		{
			bool reschedule = inv->getBooleanParameter();
			
			activateAiBehavior(reschedule);
			
		}
		break;
	case RPC_CANCELBEHAVIOREVENT__:
		{
			
			cancelBehaviorEvent();
			
		}
		break;
	case RPC_CANCELRECOVERYEVENT__:
		{
			
			cancelRecoveryEvent();
			
		}
		break;
	case RPC_DORECOVERY__INT_:
		{
			int latency = inv->getSignedIntParameter();
			
			doRecovery(latency);
			
		}
		break;
	case RPC_RUNBEHAVIORTREE__:
		{
			
			runBehaviorTree();
			
		}
		break;
	case RPC_ISRUNNINGBEHAVIOR__INT_:
		{
			unsigned int id = inv->getUnsignedIntParameter();
			
			bool _m_res = isRunningBehavior(id);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ADDRUNNINGID__INT_:
		{
			unsigned int id = inv->getUnsignedIntParameter();
			
			addRunningID(id);
			
		}
		break;
	case RPC_POPRUNNINGCHAIN__:
		{
			
			popRunningChain();
			
		}
		break;
	case RPC_PEEKRUNNINGCHAIN__:
		{
			
			unsigned int _m_res = peekRunningChain();
			resp->insertInt(_m_res);
		}
		break;
	case RPC_CLEARRUNNINGCHAIN__:
		{
			
			clearRunningChain();
			
		}
		break;
	case RPC_SETAITEMPLATE__:
		{
			
			setAITemplate();
			
		}
		break;
	case RPC_LOADCREATUREBITMASK__:
		{
			
			loadCreatureBitmask();
			
		}
		break;
	case RPC_UNLOADCREATUREBITMASK__:
		{
			
			unloadCreatureBitmask();
			
		}
		break;
	case RPC_SETAIDEBUG__BOOL_:
		{
			bool flag = inv->getBooleanParameter();
			
			setAIDebug(flag);
			
		}
		break;
	case RPC_GETAIDEBUG__:
		{
			
			bool _m_res = getAIDebug();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETLEVEL__INT_BOOL_:
		{
			int lvl = inv->getSignedIntParameter();
			bool randomHam = inv->getBooleanParameter();
			
			setLevel(lvl, randomHam);
			
		}
		break;
	case RPC_SENDBASELINESTO__SCENEOBJECT_:
		{
			SceneObject* player = static_cast<SceneObject*>(inv->getObjectParameter());
			
			sendBaselinesTo(player);
			
		}
		break;
	case RPC_CALCULATEATTACKMINDAMAGE__INT_:
		{
			int level = inv->getSignedIntParameter();
			
			int _m_res = calculateAttackMinDamage(level);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_CALCULATEATTACKMAXDAMAGE__INT_:
		{
			int level = inv->getSignedIntParameter();
			
			int _m_res = calculateAttackMaxDamage(level);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_CALCULATEATTACKSPEED__INT_:
		{
			int level = inv->getSignedIntParameter();
			
			float _m_res = calculateAttackSpeed(level);
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETTARGETFROMMAP__:
		{
			
			DistributedObject* _m_res = getTargetFromMap();
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_GETTARGETFROMDEFENDERS__:
		{
			
			DistributedObject* _m_res = getTargetFromDefenders();
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_GETTARGETFROMTARGETSMAP__TANGIBLEOBJECT_:
		{
			TangibleObject* target = static_cast<TangibleObject*>(inv->getObjectParameter());
			
			DistributedObject* _m_res = getTargetFromTargetsMap(target);
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_GETTARGETFROMTARGETSDEFENDERS__:
		{
			
			DistributedObject* _m_res = getTargetFromTargetsDefenders();
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_VALIDATETARGET__:
		{
			
			bool _m_res = validateTarget();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_VALIDATETARGET__SCENEOBJECT_:
		{
			SceneObject* target = static_cast<SceneObject*>(inv->getObjectParameter());
			
			bool _m_res = validateTarget(target);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISCAMOUFLAGED__CREATUREOBJECT_:
		{
			CreatureObject* target = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			bool _m_res = isCamouflaged(target);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_FINDNEXTPOSITION__FLOAT_BOOL_:
		{
			float maxDistance = inv->getFloatParameter();
			bool walk = inv->getBooleanParameter();
			
			bool _m_res = findNextPosition(maxDistance, walk);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_CHECKLINEOFSIGHT__SCENEOBJECT_:
		{
			SceneObject* obj = static_cast<SceneObject*>(inv->getObjectParameter());
			
			bool _m_res = checkLineOfSight(obj);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_HANDLEOBJECTMENUSELECT__CREATUREOBJECT_BYTE_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			byte selectedID = inv->getByteParameter();
			
			int _m_res = handleObjectMenuSelect(player, selectedID);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_UPDATEHOMEDIRECTION__:
		{
			
			updateHomeDirection();
			
		}
		break;
	case RPC_CHECKNEWANGLE__:
		{
			
			checkNewAngle();
			
		}
		break;
	case RPC_SETNEXTPOSITION__FLOAT_FLOAT_FLOAT_CELLOBJECT_:
		{
			float x = inv->getFloatParameter();
			float z = inv->getFloatParameter();
			float y = inv->getFloatParameter();
			CellObject* cell = static_cast<CellObject*>(inv->getObjectParameter());
			
			setNextPosition(x, z, y, cell);
			
		}
		break;
	case RPC_SETNEXTSTEPPOSITION__FLOAT_FLOAT_FLOAT_CELLOBJECT_:
		{
			float x = inv->getFloatParameter();
			float z = inv->getFloatParameter();
			float y = inv->getFloatParameter();
			CellObject* cell = static_cast<CellObject*>(inv->getObjectParameter());
			
			setNextStepPosition(x, z, y, cell);
			
		}
		break;
	case RPC_NOTIFYPOSITIONUPDATE__QUADTREEENTRY_:
		{
			QuadTreeEntry* entry = static_cast<QuadTreeEntry*>(inv->getObjectParameter());
			
			notifyPositionUpdate(entry);
			
		}
		break;
	case RPC_CLEARPATROLPOINTS__:
		{
			
			clearPatrolPoints();
			
		}
		break;
	case RPC_CLEARCURRENTPATH__:
		{
			
			clearCurrentPath();
			
		}
		break;
	case RPC_CLEARSAVEDPATROLPOINTS__:
		{
			
			clearSavedPatrolPoints();
			
		}
		break;
	case RPC_INFLICTDAMAGE__TANGIBLEOBJECT_INT_FLOAT_BOOL_BOOL_BOOL_:
		{
			TangibleObject* attacker = static_cast<TangibleObject*>(inv->getObjectParameter());
			int damageType = inv->getSignedIntParameter();
			float damage = inv->getFloatParameter();
			bool destroy = inv->getBooleanParameter();
			bool notifyClient = inv->getBooleanParameter();
			bool isCombatAction = inv->getBooleanParameter();
			
			int _m_res = inflictDamage(attacker, damageType, damage, destroy, notifyClient, isCombatAction);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_INFLICTDAMAGE__TANGIBLEOBJECT_INT_FLOAT_BOOL_STRING_BOOL_BOOL_:
		{
			TangibleObject* attacker = static_cast<TangibleObject*>(inv->getObjectParameter());
			int damageType = inv->getSignedIntParameter();
			float damage = inv->getFloatParameter();
			bool destroy = inv->getBooleanParameter();
			 String xp; inv->getAsciiParameter(xp);
			bool notifyClient = inv->getBooleanParameter();
			bool isCombatAction = inv->getBooleanParameter();
			
			int _m_res = inflictDamage(attacker, damageType, damage, destroy, xp, notifyClient, isCombatAction);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_NOTIFYPACKMOBS__SCENEOBJECT_:
		{
			SceneObject* attacker = static_cast<SceneObject*>(inv->getObjectParameter());
			
			notifyPackMobs(attacker);
			
		}
		break;
	case RPC_ADDDOTSTATE__CREATUREOBJECT_LONG_LONG_INT_BYTE_INT_FLOAT_INT_INT_:
		{
			CreatureObject* attacker = static_cast<CreatureObject*>(inv->getObjectParameter());
			unsigned long long dotType = inv->getUnsignedLongParameter();
			unsigned long long objectID = inv->getUnsignedLongParameter();
			unsigned int strength = inv->getUnsignedIntParameter();
			byte type = inv->getByteParameter();
			unsigned int duration = inv->getUnsignedIntParameter();
			float potency = inv->getFloatParameter();
			unsigned int defense = inv->getUnsignedIntParameter();
			int secondaryStrength = inv->getSignedIntParameter();
			
			int _m_res = addDotState(attacker, dotType, objectID, strength, type, duration, potency, defense, secondaryStrength);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_SENDCONVERSATIONSTARTTO__SCENEOBJECT_:
		{
			SceneObject* player = static_cast<SceneObject*>(inv->getObjectParameter());
			
			bool _m_res = sendConversationStartTo(player);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_STOPCONVERSATION__:
		{
			
			bool _m_res = stopConversation();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SENDDEFAULTCONVERSATIONTO__SCENEOBJECT_:
		{
			SceneObject* player = static_cast<SceneObject*>(inv->getObjectParameter());
			
			sendDefaultConversationTo(player);
			
		}
		break;
	case RPC_SELECTCONVERSATIONOPTION__INT_SCENEOBJECT_:
		{
			int option = inv->getSignedIntParameter();
			SceneObject* obj = static_cast<SceneObject*>(inv->getObjectParameter());
			
			selectConversationOption(option, obj);
			
		}
		break;
	case RPC_NOTIFYOBJECTDESTRUCTIONOBSERVERS__TANGIBLEOBJECT_INT_BOOL_:
		{
			TangibleObject* attacker = static_cast<TangibleObject*>(inv->getObjectParameter());
			int condition = inv->getSignedIntParameter();
			bool isCombatAction = inv->getBooleanParameter();
			
			int _m_res = notifyObjectDestructionObservers(attacker, condition, isCombatAction);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_NOTIFYCONVERSEOBSERVERS__CREATUREOBJECT_:
		{
			CreatureObject* converser = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			int _m_res = notifyConverseObservers(converser);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_NOTIFYATTACK__OBSERVABLE_:
		{
			Observable* observable = static_cast<Observable*>(inv->getObjectParameter());
			
			int _m_res = notifyAttack(observable);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_DESTROYOBJECTFROMWORLD__BOOL_:
		{
			bool sendSelfDestroy = inv->getBooleanParameter();
			
			destroyObjectFromWorld(sendSelfDestroy);
			
		}
		break;
	case RPC_DESTROYOBJECTFROMDATABASE__BOOL_:
		{
			bool destroyContainedObjects = inv->getBooleanParameter();
			
			destroyObjectFromDatabase(destroyContainedObjects);
			
		}
		break;
	case RPC_ACTIVATEPOSTURERECOVERY__:
		{
			
			activatePostureRecovery();
			
		}
		break;
	case RPC_ACTIVATEHAMREGENERATION__INT_:
		{
			int latency = inv->getSignedIntParameter();
			
			activateHAMRegeneration(latency);
			
		}
		break;
	case RPC_QUEUEDIZZYFALLEVENT__:
		{
			
			queueDizzyFallEvent();
			
		}
		break;
	case RPC_CLEARCOMBATSTATE__BOOL_:
		{
			bool clearDefenders = inv->getBooleanParameter();
			
			clearCombatState(clearDefenders);
			
		}
		break;
	case RPC_SETDEFENDER__SCENEOBJECT_:
		{
			SceneObject* defender = static_cast<SceneObject*>(inv->getObjectParameter());
			
			setDefender(defender);
			
		}
		break;
	case RPC_ADDDEFENDER__SCENEOBJECT_:
		{
			SceneObject* defender = static_cast<SceneObject*>(inv->getObjectParameter());
			
			addDefender(defender);
			
		}
		break;
	case RPC_REMOVEDEFENDER__SCENEOBJECT_:
		{
			SceneObject* defender = static_cast<SceneObject*>(inv->getObjectParameter());
			
			removeDefender(defender);
			
		}
		break;
	case RPC_KILLPLAYER__SCENEOBJECT_:
		{
			SceneObject* player = static_cast<SceneObject*>(inv->getObjectParameter());
			
			bool _m_res = killPlayer(player);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_STALKPROSPECT__SCENEOBJECT_:
		{
			SceneObject* prospect = static_cast<SceneObject*>(inv->getObjectParameter());
			
			bool _m_res = stalkProspect(prospect);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_HEALTARGET__CREATUREOBJECT_:
		{
			CreatureObject* target = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			healTarget(target);
			
		}
		break;
	case RPC_SETDESPAWNONNOPLAYERINRANGE__BOOL_:
		{
			bool val = inv->getBooleanParameter();
			
			setDespawnOnNoPlayerInRange(val);
			
		}
		break;
	case RPC_NOTIFYDESPAWN__ZONE_:
		{
			Zone* zone = static_cast<Zone*>(inv->getObjectParameter());
			
			notifyDespawn(zone);
			
		}
		break;
	case RPC_SCHEDULEDESPAWN__:
		{
			
			scheduleDespawn();
			
		}
		break;
	case RPC_SCHEDULEDESPAWN__INT_:
		{
			int timeToDespawn = inv->getSignedIntParameter();
			
			scheduleDespawn(timeToDespawn);
			
		}
		break;
	case RPC_RESPAWN__ZONE_INT_:
		{
			Zone* zone = static_cast<Zone*>(inv->getObjectParameter());
			int level = inv->getSignedIntParameter();
			
			respawn(zone, level);
			
		}
		break;
	case RPC_SETHOMELOCATION__FLOAT_FLOAT_FLOAT_CELLOBJECT_FLOAT_:
		{
			float x = inv->getFloatParameter();
			float z = inv->getFloatParameter();
			float y = inv->getFloatParameter();
			CellObject* cell = static_cast<CellObject*>(inv->getObjectParameter());
			float direction = inv->getFloatParameter();
			
			setHomeLocation(x, z, y, cell, direction);
			
		}
		break;
	case RPC_SETRESPAWNTIMER__FLOAT_:
		{
			float resp = inv->getFloatParameter();
			
			setRespawnTimer(resp);
			
		}
		break;
	case RPC_SETRANDOMRESPAWN__BOOL_:
		{
			bool resp = inv->getBooleanParameter();
			
			setRandomRespawn(resp);
			
		}
		break;
	case RPC_RESETRESPAWNCOUNTER__:
		{
			
			resetRespawnCounter();
			
		}
		break;
	case RPC_ISATTACKABLEBY__CREATUREOBJECT_:
		{
			CreatureObject* object = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			bool _m_res = isAttackableBy(object);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISATTACKABLEBY__TANGIBLEOBJECT_:
		{
			TangibleObject* object = static_cast<TangibleObject*>(inv->getObjectParameter());
			
			bool _m_res = isAttackableBy(object);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISAGGRESSIVETO__CREATUREOBJECT_:
		{
			CreatureObject* object = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			bool _m_res = isAggressiveTo(object);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISAGGRESSIVE__CREATUREOBJECT_:
		{
			CreatureObject* object = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			bool _m_res = isAggressive(object);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETOBLIVIOUS__:
		{
			
			setOblivious();
			
		}
		break;
	case RPC_SETWATCHOBJECT__SCENEOBJECT_:
		{
			SceneObject* obj = static_cast<SceneObject*>(inv->getObjectParameter());
			
			setWatchObject(obj);
			
		}
		break;
	case RPC_SETSTALKOBJECT__SCENEOBJECT_:
		{
			SceneObject* obj = static_cast<SceneObject*>(inv->getObjectParameter());
			
			setStalkObject(obj);
			
		}
		break;
	case RPC_SETFOLLOWOBJECT__SCENEOBJECT_:
		{
			SceneObject* obj = static_cast<SceneObject*>(inv->getObjectParameter());
			
			setFollowObject(obj);
			
		}
		break;
	case RPC_SETTARGETOBJECT__SCENEOBJECT_:
		{
			SceneObject* obj = static_cast<SceneObject*>(inv->getObjectParameter());
			
			setTargetObject(obj);
			
		}
		break;
	case RPC_RUNAWAY__CREATUREOBJECT_FLOAT_BOOL_:
		{
			CreatureObject* target = static_cast<CreatureObject*>(inv->getObjectParameter());
			float range = inv->getFloatParameter();
			bool random = inv->getBooleanParameter();
			
			runAway(target, range, random);
			
		}
		break;
	case RPC_LEASH__BOOL_:
		{
			bool forcePeace = inv->getBooleanParameter();
			
			leash(forcePeace);
			
		}
		break;
	case RPC_GENERATEPATROL__INT_FLOAT_:
		{
			int num = inv->getSignedIntParameter();
			float dist = inv->getFloatParameter();
			
			bool _m_res = generatePatrol(num, dist);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETFOLLOWOBJECT__:
		{
			
			DistributedObject* _m_res = getFollowObject().get();
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_STOREFOLLOWOBJECT__:
		{
			
			storeFollowObject();
			
		}
		break;
	case RPC_RESTOREFOLLOWOBJECT__:
		{
			
			restoreFollowObject();
			
		}
		break;
	case RPC_GETMOVEMENTSTATE__:
		{
			
			unsigned int _m_res = getMovementState();
			resp->insertInt(_m_res);
		}
		break;
	case RPC_SETMOVEMENTSTATE__INT_:
		{
			int state = inv->getSignedIntParameter();
			
			setMovementState(state);
			
		}
		break;
	case RPC_GETMAXDISTANCE__:
		{
			
			float _m_res = getMaxDistance();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_SETDESTINATION__:
		{
			
			int _m_res = setDestination();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_SETWAIT__INT_:
		{
			int wait = inv->getSignedIntParameter();
			
			setWait(wait);
			
		}
		break;
	case RPC_STOPWAITING__:
		{
			
			stopWaiting();
			
		}
		break;
	case RPC_ISWAITING__:
		{
			
			bool _m_res = isWaiting();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_VALIDATESTATEATTACK__CREATUREOBJECT_INT_:
		{
			CreatureObject* target = static_cast<CreatureObject*>(inv->getObjectParameter());
			unsigned int actionCRC = inv->getUnsignedIntParameter();
			
			bool _m_res = validateStateAttack(target, actionCRC);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SELECTSPECIALATTACK__:
		{
			
			bool _m_res = selectSpecialAttack();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SELECTSPECIALATTACK__INT_:
		{
			int attackNum = inv->getSignedIntParameter();
			
			bool _m_res = selectSpecialAttack(attackNum);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SELECTDEFAULTATTACK__:
		{
			
			bool _m_res = selectDefaultAttack();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_VALIDATESTATEATTACK__:
		{
			
			bool _m_res = validateStateAttack();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ENQUEUEATTACK__INT_:
		{
			int priority = inv->getSignedIntParameter();
			
			int _m_res = enqueueAttack(priority);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_ISRETREATING__:
		{
			
			bool _m_res = isRetreating();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISFLEEING__:
		{
			
			bool _m_res = isFleeing();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISRESTING__:
		{
			
			bool _m_res = isResting();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_CLEARDESPAWNEVENT__:
		{
			
			clearDespawnEvent();
			
		}
		break;
	case RPC_GETKINETIC__:
		{
			
			float _m_res = getKinetic();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETENERGY__:
		{
			
			float _m_res = getEnergy();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETELECTRICITY__:
		{
			
			float _m_res = getElectricity();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETSTUN__:
		{
			
			float _m_res = getStun();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETBLAST__:
		{
			
			float _m_res = getBlast();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETHEAT__:
		{
			
			float _m_res = getHeat();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETCOLD__:
		{
			
			float _m_res = getCold();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETACID__:
		{
			
			float _m_res = getAcid();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETLIGHTSABER__:
		{
			
			float _m_res = getLightSaber();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_ISSPECIALPROTECTION__INT_:
		{
			int resistType = inv->getSignedIntParameter();
			
			bool _m_res = isSpecialProtection(resistType);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISSTALKER__:
		{
			
			bool _m_res = isStalker();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISKILLER__:
		{
			
			bool _m_res = isKiller();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISHEALER__:
		{
			
			bool _m_res = isHealer();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETFEROCITY__:
		{
			
			unsigned int _m_res = getFerocity();
			resp->insertInt(_m_res);
		}
		break;
	case RPC_GETAGGRORADIUS__:
		{
			
			int _m_res = getAggroRadius();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETARMOR__:
		{
			
			unsigned int _m_res = getArmor();
			resp->insertInt(_m_res);
		}
		break;
	case RPC_GETDESPAWNONNOPLAYERINRANGE__:
		{
			
			bool _m_res = getDespawnOnNoPlayerInRange();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETNUMBEROFPLAYERSINRANGE__:
		{
			
			int _m_res = getNumberOfPlayersInRange();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETFACTIONSTRING__:
		{
			
			String _m_res = getFactionString();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_GETSOCIALGROUP__:
		{
			
			String _m_res = getSocialGroup();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_GETHEALERTYPE__:
		{
			
			String _m_res = getHealerType();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_GETCHANCEHIT__:
		{
			
			float _m_res = getChanceHit();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETDAMAGEMIN__:
		{
			
			int _m_res = getDamageMin();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETDAMAGEMAX__:
		{
			
			int _m_res = getDamageMax();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETSPECIALDAMAGEMULT__:
		{
			
			float _m_res = getSpecialDamageMult();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETBASEXP__:
		{
			
			int _m_res = getBaseXp();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETDIET__:
		{
			
			unsigned int _m_res = getDiet();
			resp->insertInt(_m_res);
		}
		break;
	case RPC_GETTEMPLATELEVEL__:
		{
			
			unsigned int _m_res = getTemplateLevel();
			resp->insertInt(_m_res);
		}
		break;
	case RPC_GETTAME__:
		{
			
			float _m_res = getTame();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETREACTIONSTF__:
		{
			
			String _m_res = getReactionStf();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_GETRESPAWNTIMER__:
		{
			
			float _m_res = getRespawnTimer();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETRANDOMRESPAWN__:
		{
			
			bool _m_res = getRandomRespawn();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETRESPAWNCOUNTER__:
		{
			
			int _m_res = getRespawnCounter();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_ISAIAGENT__:
		{
			
			bool _m_res = isAiAgent();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_HASLOOT__:
		{
			
			bool _m_res = hasLoot();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETSHOWNEXTPOSITION__BOOL_:
		{
			bool val = inv->getBooleanParameter();
			
			setShowNextPosition(val);
			
		}
		break;
	case RPC_ISEVENTMOB__:
		{
			
			bool _m_res = isEventMob();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISPET__:
		{
			
			bool _m_res = isPet();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETHOMEOBJECT__SCENEOBJECT_:
		{
			SceneObject* home = static_cast<SceneObject*>(inv->getObjectParameter());
			
			setHomeObject(home);
			
		}
		break;
	case RPC_SETEVENTAREA__ACTIVEAREA_:
		{
			ActiveArea* area = static_cast<ActiveArea*>(inv->getObjectParameter());
			
			setEventArea(area);
			
		}
		break;
	case RPC_SETCOMBATSTATE__:
		{
			
			setCombatState();
			
		}
		break;
	case RPC_GETCREATUREBITMASK__:
		{
			
			unsigned int _m_res = getCreatureBitmask();
			resp->insertInt(_m_res);
		}
		break;
	case RPC_SETCREATUREBITMASK__INT_:
		{
			unsigned int mask = inv->getUnsignedIntParameter();
			
			setCreatureBitmask(mask);
			
		}
		break;
	case RPC_SETCREATUREBIT__INT_:
		{
			unsigned int option = inv->getUnsignedIntParameter();
			
			setCreatureBit(option);
			
		}
		break;
	case RPC_CLEARCREATUREBIT__INT_:
		{
			unsigned int option = inv->getUnsignedIntParameter();
			
			clearCreatureBit(option);
			
		}
		break;
	case RPC_ADDCREATUREFLAG__INT_:
		{
			unsigned int flag = inv->getUnsignedIntParameter();
			
			addCreatureFlag(flag);
			
		}
		break;
	case RPC_REMOVECREATUREFLAG__INT_:
		{
			unsigned int flag = inv->getUnsignedIntParameter();
			
			removeCreatureFlag(flag);
			
		}
		break;
	case RPC_HASRANGEDWEAPON__:
		{
			
			bool _m_res = hasRangedWeapon();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_HASMELEEWEAPON__:
		{
			
			bool _m_res = hasMeleeWeapon();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETUSERANGED__:
		{
			
			bool _m_res = getUseRanged();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_HASSPECIALATTACK__INT_:
		{
			int num = inv->getSignedIntParameter();
			
			bool _m_res = hasSpecialAttack(num);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETPETDEED__PETDEED_:
		{
			PetDeed* deed = static_cast<PetDeed*>(inv->getObjectParameter());
			
			setPetDeed(deed);
			
		}
		break;
	case RPC_HASPETDEED__:
		{
			
			bool _m_res = hasPetDeed();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETPETDEED__:
		{
			
			DistributedObject* _m_res = getPetDeed();
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_SENDREACTIONCHAT__SCENEOBJECT_INT_INT_BOOL_:
		{
			SceneObject* object = static_cast<SceneObject*>(inv->getObjectParameter());
			int type = inv->getSignedIntParameter();
			int state = inv->getSignedIntParameter();
			bool force = inv->getBooleanParameter();
			
			sendReactionChat(object, type, state, force);
			
		}
		break;
	case RPC_HASREACTIONCHATMESSAGES__:
		{
			
			bool _m_res = hasReactionChatMessages();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETPERSONALITYSTF__:
		{
			
			String _m_res = getPersonalityStf();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_GETREACTIONRANK__:
		{
			
			int _m_res = getReactionRank();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_SETREACTIONRANK__INT_:
		{
			int rank = inv->getSignedIntParameter();
			
			setReactionRank(rank);
			
		}
		break;
	case RPC_GETHAMMAXIMUM__:
		{
			
			int _m_res = getHamMaximum();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETHAMBASE__:
		{
			
			int _m_res = getHamBase();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_SETMAXHAM__INT_INT_BOOL_:
		{
			int type = inv->getSignedIntParameter();
			int value = inv->getSignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setMaxHAM(type, value, notifyClient);
			
		}
		break;
	case RPC_RELOADTEMPLATE__:
		{
			
			reloadTemplate();
			
		}
		break;
	case RPC_GETCONVOTEMPLATECRC__:
		{
			
			unsigned int _m_res = getConvoTemplateCRC();
			resp->insertInt(_m_res);
		}
		break;
	case RPC_SETCONVOTEMPLATE__STRING_:
		{
			 String templateString; inv->getAsciiParameter(templateString);
			
			setConvoTemplate(templateString);
			
		}
		break;
	case RPC_SETLAIRTEMPLATECRC__INT_:
		{
			unsigned int crc = inv->getUnsignedIntParameter();
			
			setLairTemplateCRC(crc);
			
		}
		break;
	case RPC_GETLAIRTEMPLATECRC__:
		{
			
			unsigned int _m_res = getLairTemplateCRC();
			resp->insertInt(_m_res);
		}
		break;
	case RPC_SETCUSTOMAIMAP__LONG_:
		{
			unsigned long long customMap = inv->getUnsignedLongParameter();
			
			setCustomAiMap(customMap);
			
		}
		break;
	case RPC_SETCURRENTWEAPON__WEAPONOBJECT_:
		{
			WeaponObject* weap = static_cast<WeaponObject*>(inv->getObjectParameter());
			
			setCurrentWeapon(weap);
			
		}
		break;
	case RPC_SETDEFAULTWEAPON__WEAPONOBJECT_:
		{
			WeaponObject* weap = static_cast<WeaponObject*>(inv->getObjectParameter());
			
			setDefaultWeapon(weap);
			
		}
		break;
	case RPC_GETPRIMARYWEAPON__:
		{
			
			DistributedObject* _m_res = getPrimaryWeapon();
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_GETSECONDARYWEAPON__:
		{
			
			DistributedObject* _m_res = getSecondaryWeapon();
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_GETDEFAULTWEAPON__:
		{
			
			DistributedObject* _m_res = getDefaultWeapon();
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_GETTHROWNWEAPON__:
		{
			
			DistributedObject* _m_res = getThrownWeapon();
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_CLEARTHROWNWEAPON__:
		{
			
			clearThrownWeapon();
			
		}
		break;
	case RPC_GETCURRENTWEAPON__:
		{
			
			DistributedObject* _m_res = getCurrentWeapon();
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_NULLIFYWEAPONS__:
		{
			
			nullifyWeapons();
			
		}
		break;
	case RPC_GETMOBTYPE__:
		{
			
			int _m_res = getMobType();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_ISHERBIVORE__:
		{
			
			bool _m_res = isHerbivore();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISCARNIVORE__:
		{
			
			bool _m_res = isCarnivore();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISMONSTER__:
		{
			
			bool _m_res = isMonster();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISDROID__:
		{
			
			bool _m_res = isDroid();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISANDROID__:
		{
			
			bool _m_res = isAndroid();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISNPC__:
		{
			
			bool _m_res = isNpc();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISHUMANOID__:
		{
			
			bool _m_res = isHumanoid();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISVEHICLETYPE__:
		{
			
			bool _m_res = isVehicleType();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ADDTARGETMISSCOUNT__LONG_INT_:
		{
			unsigned long long target = inv->getUnsignedLongParameter();
			int misses = inv->getSignedIntParameter();
			
			addTargetMissCount(target, misses);
			
		}
		break;
	case RPC_SETTARGETMISSCOUNT__LONG_INT_:
		{
			unsigned long long target = inv->getUnsignedLongParameter();
			int misses = inv->getSignedIntParameter();
			
			setTargetMissCount(target, misses);
			
		}
		break;
	case RPC_REMOVETARGETMISSCOUNT__LONG_:
		{
			unsigned long long target = inv->getUnsignedLongParameter();
			
			removeTargetMissCount(target);
			
		}
		break;
	case RPC_GETERRORCONTEXT__:
		{
			
			String _m_res = getErrorContext();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_ISTAUNTABLE__:
		{
			
			bool _m_res = isTauntable();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETMINDTRICKED__BOOL_:
		{
			bool val = inv->getBooleanParameter();
			
			setMindTricked(val);
			
		}
		break;
	case RPC_ISMINDTRICKED__:
		{
			
			bool _m_res = isMindTricked();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISHAMREGENDISABLED__:
		{
			
			bool _m_res = isHamRegenDisabled();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETHAMREGENDISABLED__BOOL_:
		{
			bool val = inv->getBooleanParameter();
			
			setHamRegenDisabled(val);
			
		}
		break;
	default:
		CreatureObjectAdapter::invokeMethod(methid, inv);
	}
}

void AiAgentAdapter::initializeTransientMembers() {
	(static_cast<AiAgent*>(stub))->initializeTransientMembers();
}

void AiAgentAdapter::notifyLoadFromDatabase() {
	(static_cast<AiAgent*>(stub))->notifyLoadFromDatabase();
}

void AiAgentAdapter::finalize() {
	(static_cast<AiAgent*>(stub))->finalize();
}

String AiAgentAdapter::getLogFileName() const {
	return (static_cast<AiAgent*>(stub))->getLogFileName();
}

int AiAgentAdapter::getLogLevel() const {
	return (static_cast<AiAgent*>(stub))->getLogLevel();
}

void AiAgentAdapter::activateRecovery() {
	(static_cast<AiAgent*>(stub))->activateRecovery();
}

void AiAgentAdapter::activateAiBehavior(bool reschedule) {
	(static_cast<AiAgent*>(stub))->activateAiBehavior(reschedule);
}

void AiAgentAdapter::cancelBehaviorEvent() {
	(static_cast<AiAgent*>(stub))->cancelBehaviorEvent();
}

void AiAgentAdapter::cancelRecoveryEvent() {
	(static_cast<AiAgent*>(stub))->cancelRecoveryEvent();
}

void AiAgentAdapter::doRecovery(int latency) {
	(static_cast<AiAgent*>(stub))->doRecovery(latency);
}

void AiAgentAdapter::runBehaviorTree() {
	(static_cast<AiAgent*>(stub))->runBehaviorTree();
}

bool AiAgentAdapter::isRunningBehavior(unsigned int id) {
	return (static_cast<AiAgent*>(stub))->isRunningBehavior(id);
}

void AiAgentAdapter::addRunningID(unsigned int id) {
	(static_cast<AiAgent*>(stub))->addRunningID(id);
}

void AiAgentAdapter::popRunningChain() {
	(static_cast<AiAgent*>(stub))->popRunningChain();
}

unsigned int AiAgentAdapter::peekRunningChain() {
	return (static_cast<AiAgent*>(stub))->peekRunningChain();
}

void AiAgentAdapter::clearRunningChain() {
	(static_cast<AiAgent*>(stub))->clearRunningChain();
}

void AiAgentAdapter::setAITemplate() {
	(static_cast<AiAgent*>(stub))->setAITemplate();
}

void AiAgentAdapter::loadCreatureBitmask() {
	(static_cast<AiAgent*>(stub))->loadCreatureBitmask();
}

void AiAgentAdapter::unloadCreatureBitmask() {
	(static_cast<AiAgent*>(stub))->unloadCreatureBitmask();
}

void AiAgentAdapter::setAIDebug(bool flag) {
	(static_cast<AiAgent*>(stub))->setAIDebug(flag);
}

bool AiAgentAdapter::getAIDebug() {
	return (static_cast<AiAgent*>(stub))->getAIDebug();
}

void AiAgentAdapter::setLevel(int lvl, bool randomHam) {
	(static_cast<AiAgent*>(stub))->setLevel(lvl, randomHam);
}

void AiAgentAdapter::sendBaselinesTo(SceneObject* player) {
	(static_cast<AiAgent*>(stub))->sendBaselinesTo(player);
}

int AiAgentAdapter::calculateAttackMinDamage(int level) {
	return (static_cast<AiAgent*>(stub))->calculateAttackMinDamage(level);
}

int AiAgentAdapter::calculateAttackMaxDamage(int level) {
	return (static_cast<AiAgent*>(stub))->calculateAttackMaxDamage(level);
}

float AiAgentAdapter::calculateAttackSpeed(int level) {
	return (static_cast<AiAgent*>(stub))->calculateAttackSpeed(level);
}

SceneObject* AiAgentAdapter::getTargetFromMap() {
	return (static_cast<AiAgent*>(stub))->getTargetFromMap();
}

SceneObject* AiAgentAdapter::getTargetFromDefenders() {
	return (static_cast<AiAgent*>(stub))->getTargetFromDefenders();
}

SceneObject* AiAgentAdapter::getTargetFromTargetsMap(TangibleObject* target) {
	return (static_cast<AiAgent*>(stub))->getTargetFromTargetsMap(target);
}

SceneObject* AiAgentAdapter::getTargetFromTargetsDefenders() {
	return (static_cast<AiAgent*>(stub))->getTargetFromTargetsDefenders();
}

bool AiAgentAdapter::validateTarget() {
	return (static_cast<AiAgent*>(stub))->validateTarget();
}

bool AiAgentAdapter::validateTarget(SceneObject* target) {
	return (static_cast<AiAgent*>(stub))->validateTarget(target);
}

bool AiAgentAdapter::isCamouflaged(CreatureObject* target) {
	return (static_cast<AiAgent*>(stub))->isCamouflaged(target);
}

bool AiAgentAdapter::findNextPosition(float maxDistance, bool walk) {
	return (static_cast<AiAgent*>(stub))->findNextPosition(maxDistance, walk);
}

bool AiAgentAdapter::checkLineOfSight(SceneObject* obj) {
	return (static_cast<AiAgent*>(stub))->checkLineOfSight(obj);
}

int AiAgentAdapter::handleObjectMenuSelect(CreatureObject* player, byte selectedID) {
	return (static_cast<AiAgent*>(stub))->handleObjectMenuSelect(player, selectedID);
}

void AiAgentAdapter::updateHomeDirection() {
	(static_cast<AiAgent*>(stub))->updateHomeDirection();
}

void AiAgentAdapter::checkNewAngle() {
	(static_cast<AiAgent*>(stub))->checkNewAngle();
}

void AiAgentAdapter::setNextPosition(float x, float z, float y, CellObject* cell) {
	(static_cast<AiAgent*>(stub))->setNextPosition(x, z, y, cell);
}

void AiAgentAdapter::setNextStepPosition(float x, float z, float y, CellObject* cell) {
	(static_cast<AiAgent*>(stub))->setNextStepPosition(x, z, y, cell);
}

void AiAgentAdapter::notifyPositionUpdate(QuadTreeEntry* entry) {
	(static_cast<AiAgent*>(stub))->notifyPositionUpdate(entry);
}

void AiAgentAdapter::clearPatrolPoints() {
	(static_cast<AiAgent*>(stub))->clearPatrolPoints();
}

void AiAgentAdapter::clearCurrentPath() {
	(static_cast<AiAgent*>(stub))->clearCurrentPath();
}

void AiAgentAdapter::clearSavedPatrolPoints() {
	(static_cast<AiAgent*>(stub))->clearSavedPatrolPoints();
}

int AiAgentAdapter::inflictDamage(TangibleObject* attacker, int damageType, float damage, bool destroy, bool notifyClient, bool isCombatAction) {
	return (static_cast<AiAgent*>(stub))->inflictDamage(attacker, damageType, damage, destroy, notifyClient, isCombatAction);
}

int AiAgentAdapter::inflictDamage(TangibleObject* attacker, int damageType, float damage, bool destroy, const String& xp, bool notifyClient, bool isCombatAction) {
	return (static_cast<AiAgent*>(stub))->inflictDamage(attacker, damageType, damage, destroy, xp, notifyClient, isCombatAction);
}

void AiAgentAdapter::notifyPackMobs(SceneObject* attacker) {
	(static_cast<AiAgent*>(stub))->notifyPackMobs(attacker);
}

int AiAgentAdapter::addDotState(CreatureObject* attacker, unsigned long long dotType, unsigned long long objectID, unsigned int strength, byte type, unsigned int duration, float potency, unsigned int defense, int secondaryStrength) {
	return (static_cast<AiAgent*>(stub))->addDotState(attacker, dotType, objectID, strength, type, duration, potency, defense, secondaryStrength);
}

bool AiAgentAdapter::sendConversationStartTo(SceneObject* player) {
	return (static_cast<AiAgent*>(stub))->sendConversationStartTo(player);
}

bool AiAgentAdapter::stopConversation() {
	return (static_cast<AiAgent*>(stub))->stopConversation();
}

void AiAgentAdapter::sendDefaultConversationTo(SceneObject* player) {
	(static_cast<AiAgent*>(stub))->sendDefaultConversationTo(player);
}

void AiAgentAdapter::selectConversationOption(int option, SceneObject* obj) {
	(static_cast<AiAgent*>(stub))->selectConversationOption(option, obj);
}

int AiAgentAdapter::notifyObjectDestructionObservers(TangibleObject* attacker, int condition, bool isCombatAction) {
	return (static_cast<AiAgent*>(stub))->notifyObjectDestructionObservers(attacker, condition, isCombatAction);
}

int AiAgentAdapter::notifyConverseObservers(CreatureObject* converser) {
	return (static_cast<AiAgent*>(stub))->notifyConverseObservers(converser);
}

int AiAgentAdapter::notifyAttack(Observable* observable) {
	return (static_cast<AiAgent*>(stub))->notifyAttack(observable);
}

void AiAgentAdapter::destroyObjectFromWorld(bool sendSelfDestroy) {
	(static_cast<AiAgent*>(stub))->destroyObjectFromWorld(sendSelfDestroy);
}

void AiAgentAdapter::destroyObjectFromDatabase(bool destroyContainedObjects) {
	(static_cast<AiAgent*>(stub))->destroyObjectFromDatabase(destroyContainedObjects);
}

void AiAgentAdapter::activatePostureRecovery() {
	(static_cast<AiAgent*>(stub))->activatePostureRecovery();
}

void AiAgentAdapter::activateHAMRegeneration(int latency) {
	(static_cast<AiAgent*>(stub))->activateHAMRegeneration(latency);
}

void AiAgentAdapter::queueDizzyFallEvent() {
	(static_cast<AiAgent*>(stub))->queueDizzyFallEvent();
}

void AiAgentAdapter::clearCombatState(bool clearDefenders) {
	(static_cast<AiAgent*>(stub))->clearCombatState(clearDefenders);
}

void AiAgentAdapter::setDefender(SceneObject* defender) {
	(static_cast<AiAgent*>(stub))->setDefender(defender);
}

void AiAgentAdapter::addDefender(SceneObject* defender) {
	(static_cast<AiAgent*>(stub))->addDefender(defender);
}

void AiAgentAdapter::removeDefender(SceneObject* defender) {
	(static_cast<AiAgent*>(stub))->removeDefender(defender);
}

bool AiAgentAdapter::killPlayer(SceneObject* player) {
	return (static_cast<AiAgent*>(stub))->killPlayer(player);
}

bool AiAgentAdapter::stalkProspect(SceneObject* prospect) {
	return (static_cast<AiAgent*>(stub))->stalkProspect(prospect);
}

void AiAgentAdapter::healTarget(CreatureObject* target) {
	(static_cast<AiAgent*>(stub))->healTarget(target);
}

void AiAgentAdapter::setDespawnOnNoPlayerInRange(bool val) {
	(static_cast<AiAgent*>(stub))->setDespawnOnNoPlayerInRange(val);
}

void AiAgentAdapter::notifyDespawn(Zone* zone) {
	(static_cast<AiAgent*>(stub))->notifyDespawn(zone);
}

void AiAgentAdapter::scheduleDespawn() {
	(static_cast<AiAgent*>(stub))->scheduleDespawn();
}

void AiAgentAdapter::scheduleDespawn(int timeToDespawn) {
	(static_cast<AiAgent*>(stub))->scheduleDespawn(timeToDespawn);
}

void AiAgentAdapter::respawn(Zone* zone, int level) {
	(static_cast<AiAgent*>(stub))->respawn(zone, level);
}

void AiAgentAdapter::setHomeLocation(float x, float z, float y, CellObject* cell, float direction) {
	(static_cast<AiAgent*>(stub))->setHomeLocation(x, z, y, cell, direction);
}

void AiAgentAdapter::setRespawnTimer(float resp) {
	(static_cast<AiAgent*>(stub))->setRespawnTimer(resp);
}

void AiAgentAdapter::setRandomRespawn(bool resp) {
	(static_cast<AiAgent*>(stub))->setRandomRespawn(resp);
}

void AiAgentAdapter::resetRespawnCounter() {
	(static_cast<AiAgent*>(stub))->resetRespawnCounter();
}

bool AiAgentAdapter::isAttackableBy(CreatureObject* object) {
	return (static_cast<AiAgent*>(stub))->isAttackableBy(object);
}

bool AiAgentAdapter::isAttackableBy(TangibleObject* object) {
	return (static_cast<AiAgent*>(stub))->isAttackableBy(object);
}

bool AiAgentAdapter::isAggressiveTo(CreatureObject* object) {
	return (static_cast<AiAgent*>(stub))->isAggressiveTo(object);
}

bool AiAgentAdapter::isAggressive(CreatureObject* object) {
	return (static_cast<AiAgent*>(stub))->isAggressive(object);
}

void AiAgentAdapter::setOblivious() {
	(static_cast<AiAgent*>(stub))->setOblivious();
}

void AiAgentAdapter::setWatchObject(SceneObject* obj) {
	(static_cast<AiAgent*>(stub))->setWatchObject(obj);
}

void AiAgentAdapter::setStalkObject(SceneObject* obj) {
	(static_cast<AiAgent*>(stub))->setStalkObject(obj);
}

void AiAgentAdapter::setFollowObject(SceneObject* obj) {
	(static_cast<AiAgent*>(stub))->setFollowObject(obj);
}

void AiAgentAdapter::setTargetObject(SceneObject* obj) {
	(static_cast<AiAgent*>(stub))->setTargetObject(obj);
}

void AiAgentAdapter::runAway(CreatureObject* target, float range, bool random) {
	(static_cast<AiAgent*>(stub))->runAway(target, range, random);
}

void AiAgentAdapter::leash(bool forcePeace) {
	(static_cast<AiAgent*>(stub))->leash(forcePeace);
}

bool AiAgentAdapter::generatePatrol(int num, float dist) {
	return (static_cast<AiAgent*>(stub))->generatePatrol(num, dist);
}

ManagedWeakReference<SceneObject* > AiAgentAdapter::getFollowObject() {
	return (static_cast<AiAgent*>(stub))->getFollowObject();
}

void AiAgentAdapter::storeFollowObject() {
	(static_cast<AiAgent*>(stub))->storeFollowObject();
}

void AiAgentAdapter::restoreFollowObject() {
	(static_cast<AiAgent*>(stub))->restoreFollowObject();
}

unsigned int AiAgentAdapter::getMovementState() const {
	return (static_cast<AiAgent*>(stub))->getMovementState();
}

void AiAgentAdapter::setMovementState(int state) {
	(static_cast<AiAgent*>(stub))->setMovementState(state);
}

float AiAgentAdapter::getMaxDistance() {
	return (static_cast<AiAgent*>(stub))->getMaxDistance();
}

int AiAgentAdapter::setDestination() {
	return (static_cast<AiAgent*>(stub))->setDestination();
}

void AiAgentAdapter::setWait(int wait) {
	(static_cast<AiAgent*>(stub))->setWait(wait);
}

void AiAgentAdapter::stopWaiting() {
	(static_cast<AiAgent*>(stub))->stopWaiting();
}

bool AiAgentAdapter::isWaiting() const {
	return (static_cast<AiAgent*>(stub))->isWaiting();
}

bool AiAgentAdapter::validateStateAttack(CreatureObject* target, unsigned int actionCRC) {
	return (static_cast<AiAgent*>(stub))->validateStateAttack(target, actionCRC);
}

bool AiAgentAdapter::selectSpecialAttack() {
	return (static_cast<AiAgent*>(stub))->selectSpecialAttack();
}

bool AiAgentAdapter::selectSpecialAttack(int attackNum) {
	return (static_cast<AiAgent*>(stub))->selectSpecialAttack(attackNum);
}

bool AiAgentAdapter::selectDefaultAttack() {
	return (static_cast<AiAgent*>(stub))->selectDefaultAttack();
}

bool AiAgentAdapter::validateStateAttack() {
	return (static_cast<AiAgent*>(stub))->validateStateAttack();
}

int AiAgentAdapter::enqueueAttack(int priority) {
	return (static_cast<AiAgent*>(stub))->enqueueAttack(priority);
}

bool AiAgentAdapter::isRetreating() {
	return (static_cast<AiAgent*>(stub))->isRetreating();
}

bool AiAgentAdapter::isFleeing() {
	return (static_cast<AiAgent*>(stub))->isFleeing();
}

bool AiAgentAdapter::isResting() {
	return (static_cast<AiAgent*>(stub))->isResting();
}

void AiAgentAdapter::clearDespawnEvent() {
	(static_cast<AiAgent*>(stub))->clearDespawnEvent();
}

float AiAgentAdapter::getKinetic() {
	return (static_cast<AiAgent*>(stub))->getKinetic();
}

float AiAgentAdapter::getEnergy() {
	return (static_cast<AiAgent*>(stub))->getEnergy();
}

float AiAgentAdapter::getElectricity() {
	return (static_cast<AiAgent*>(stub))->getElectricity();
}

float AiAgentAdapter::getStun() {
	return (static_cast<AiAgent*>(stub))->getStun();
}

float AiAgentAdapter::getBlast() {
	return (static_cast<AiAgent*>(stub))->getBlast();
}

float AiAgentAdapter::getHeat() {
	return (static_cast<AiAgent*>(stub))->getHeat();
}

float AiAgentAdapter::getCold() {
	return (static_cast<AiAgent*>(stub))->getCold();
}

float AiAgentAdapter::getAcid() {
	return (static_cast<AiAgent*>(stub))->getAcid();
}

float AiAgentAdapter::getLightSaber() {
	return (static_cast<AiAgent*>(stub))->getLightSaber();
}

bool AiAgentAdapter::isSpecialProtection(int resistType) {
	return (static_cast<AiAgent*>(stub))->isSpecialProtection(resistType);
}

bool AiAgentAdapter::isStalker() {
	return (static_cast<AiAgent*>(stub))->isStalker();
}

bool AiAgentAdapter::isKiller() {
	return (static_cast<AiAgent*>(stub))->isKiller();
}

bool AiAgentAdapter::isHealer() {
	return (static_cast<AiAgent*>(stub))->isHealer();
}

unsigned int AiAgentAdapter::getFerocity() {
	return (static_cast<AiAgent*>(stub))->getFerocity();
}

int AiAgentAdapter::getAggroRadius() {
	return (static_cast<AiAgent*>(stub))->getAggroRadius();
}

unsigned int AiAgentAdapter::getArmor() {
	return (static_cast<AiAgent*>(stub))->getArmor();
}

bool AiAgentAdapter::getDespawnOnNoPlayerInRange() const {
	return (static_cast<AiAgent*>(stub))->getDespawnOnNoPlayerInRange();
}

int AiAgentAdapter::getNumberOfPlayersInRange() {
	return (static_cast<AiAgent*>(stub))->getNumberOfPlayersInRange();
}

String AiAgentAdapter::getFactionString() {
	return (static_cast<AiAgent*>(stub))->getFactionString();
}

String AiAgentAdapter::getSocialGroup() {
	return (static_cast<AiAgent*>(stub))->getSocialGroup();
}

String AiAgentAdapter::getHealerType() {
	return (static_cast<AiAgent*>(stub))->getHealerType();
}

float AiAgentAdapter::getChanceHit() {
	return (static_cast<AiAgent*>(stub))->getChanceHit();
}

int AiAgentAdapter::getDamageMin() {
	return (static_cast<AiAgent*>(stub))->getDamageMin();
}

int AiAgentAdapter::getDamageMax() {
	return (static_cast<AiAgent*>(stub))->getDamageMax();
}

float AiAgentAdapter::getSpecialDamageMult() {
	return (static_cast<AiAgent*>(stub))->getSpecialDamageMult();
}

int AiAgentAdapter::getBaseXp() {
	return (static_cast<AiAgent*>(stub))->getBaseXp();
}

unsigned int AiAgentAdapter::getDiet() {
	return (static_cast<AiAgent*>(stub))->getDiet();
}

unsigned int AiAgentAdapter::getTemplateLevel() const {
	return (static_cast<AiAgent*>(stub))->getTemplateLevel();
}

float AiAgentAdapter::getTame() const {
	return (static_cast<AiAgent*>(stub))->getTame();
}

String AiAgentAdapter::getReactionStf() const {
	return (static_cast<AiAgent*>(stub))->getReactionStf();
}

float AiAgentAdapter::getRespawnTimer() const {
	return (static_cast<AiAgent*>(stub))->getRespawnTimer();
}

bool AiAgentAdapter::getRandomRespawn() const {
	return (static_cast<AiAgent*>(stub))->getRandomRespawn();
}

int AiAgentAdapter::getRespawnCounter() const {
	return (static_cast<AiAgent*>(stub))->getRespawnCounter();
}

bool AiAgentAdapter::isAiAgent() {
	return (static_cast<AiAgent*>(stub))->isAiAgent();
}

bool AiAgentAdapter::hasLoot() {
	return (static_cast<AiAgent*>(stub))->hasLoot();
}

void AiAgentAdapter::setShowNextPosition(bool val) {
	(static_cast<AiAgent*>(stub))->setShowNextPosition(val);
}

bool AiAgentAdapter::isEventMob() const {
	return (static_cast<AiAgent*>(stub))->isEventMob();
}

bool AiAgentAdapter::isPet() const {
	return (static_cast<AiAgent*>(stub))->isPet();
}

void AiAgentAdapter::setHomeObject(SceneObject* home) {
	(static_cast<AiAgent*>(stub))->setHomeObject(home);
}

void AiAgentAdapter::setEventArea(ActiveArea* area) {
	(static_cast<AiAgent*>(stub))->setEventArea(area);
}

void AiAgentAdapter::setCombatState() {
	(static_cast<AiAgent*>(stub))->setCombatState();
}

unsigned int AiAgentAdapter::getCreatureBitmask() const {
	return (static_cast<AiAgent*>(stub))->getCreatureBitmask();
}

void AiAgentAdapter::setCreatureBitmask(unsigned int mask) {
	(static_cast<AiAgent*>(stub))->setCreatureBitmask(mask);
}

void AiAgentAdapter::setCreatureBit(unsigned int option) {
	(static_cast<AiAgent*>(stub))->setCreatureBit(option);
}

void AiAgentAdapter::clearCreatureBit(unsigned int option) {
	(static_cast<AiAgent*>(stub))->clearCreatureBit(option);
}

void AiAgentAdapter::addCreatureFlag(unsigned int flag) {
	(static_cast<AiAgent*>(stub))->addCreatureFlag(flag);
}

void AiAgentAdapter::removeCreatureFlag(unsigned int flag) {
	(static_cast<AiAgent*>(stub))->removeCreatureFlag(flag);
}

bool AiAgentAdapter::hasRangedWeapon() {
	return (static_cast<AiAgent*>(stub))->hasRangedWeapon();
}

bool AiAgentAdapter::hasMeleeWeapon() {
	return (static_cast<AiAgent*>(stub))->hasMeleeWeapon();
}

bool AiAgentAdapter::getUseRanged() {
	return (static_cast<AiAgent*>(stub))->getUseRanged();
}

bool AiAgentAdapter::hasSpecialAttack(int num) {
	return (static_cast<AiAgent*>(stub))->hasSpecialAttack(num);
}

void AiAgentAdapter::setPetDeed(PetDeed* deed) {
	(static_cast<AiAgent*>(stub))->setPetDeed(deed);
}

bool AiAgentAdapter::hasPetDeed() const {
	return (static_cast<AiAgent*>(stub))->hasPetDeed();
}

PetDeed* AiAgentAdapter::getPetDeed() const {
	return (static_cast<AiAgent*>(stub))->getPetDeed();
}

void AiAgentAdapter::sendReactionChat(SceneObject* object, int type, int state, bool force) {
	(static_cast<AiAgent*>(stub))->sendReactionChat(object, type, state, force);
}

bool AiAgentAdapter::hasReactionChatMessages() {
	return (static_cast<AiAgent*>(stub))->hasReactionChatMessages();
}

String AiAgentAdapter::getPersonalityStf() {
	return (static_cast<AiAgent*>(stub))->getPersonalityStf();
}

int AiAgentAdapter::getReactionRank() const {
	return (static_cast<AiAgent*>(stub))->getReactionRank();
}

void AiAgentAdapter::setReactionRank(int rank) {
	(static_cast<AiAgent*>(stub))->setReactionRank(rank);
}

int AiAgentAdapter::getHamMaximum() const {
	return (static_cast<AiAgent*>(stub))->getHamMaximum();
}

int AiAgentAdapter::getHamBase() const {
	return (static_cast<AiAgent*>(stub))->getHamBase();
}

void AiAgentAdapter::setMaxHAM(int type, int value, bool notifyClient) {
	(static_cast<AiAgent*>(stub))->setMaxHAM(type, value, notifyClient);
}

void AiAgentAdapter::reloadTemplate() {
	(static_cast<AiAgent*>(stub))->reloadTemplate();
}

unsigned int AiAgentAdapter::getConvoTemplateCRC() const {
	return (static_cast<AiAgent*>(stub))->getConvoTemplateCRC();
}

void AiAgentAdapter::setConvoTemplate(const String& templateString) {
	(static_cast<AiAgent*>(stub))->setConvoTemplate(templateString);
}

void AiAgentAdapter::setLairTemplateCRC(unsigned int crc) {
	(static_cast<AiAgent*>(stub))->setLairTemplateCRC(crc);
}

unsigned int AiAgentAdapter::getLairTemplateCRC() const {
	return (static_cast<AiAgent*>(stub))->getLairTemplateCRC();
}

void AiAgentAdapter::setCustomAiMap(unsigned long long customMap) {
	(static_cast<AiAgent*>(stub))->setCustomAiMap(customMap);
}

void AiAgentAdapter::setCurrentWeapon(WeaponObject* weap) {
	(static_cast<AiAgent*>(stub))->setCurrentWeapon(weap);
}

void AiAgentAdapter::setDefaultWeapon(WeaponObject* weap) {
	(static_cast<AiAgent*>(stub))->setDefaultWeapon(weap);
}

WeaponObject* AiAgentAdapter::getPrimaryWeapon() {
	return (static_cast<AiAgent*>(stub))->getPrimaryWeapon();
}

WeaponObject* AiAgentAdapter::getSecondaryWeapon() {
	return (static_cast<AiAgent*>(stub))->getSecondaryWeapon();
}

WeaponObject* AiAgentAdapter::getDefaultWeapon() {
	return (static_cast<AiAgent*>(stub))->getDefaultWeapon();
}

WeaponObject* AiAgentAdapter::getThrownWeapon() {
	return (static_cast<AiAgent*>(stub))->getThrownWeapon();
}

void AiAgentAdapter::clearThrownWeapon() {
	(static_cast<AiAgent*>(stub))->clearThrownWeapon();
}

WeaponObject* AiAgentAdapter::getCurrentWeapon() {
	return (static_cast<AiAgent*>(stub))->getCurrentWeapon();
}

void AiAgentAdapter::nullifyWeapons() {
	(static_cast<AiAgent*>(stub))->nullifyWeapons();
}

int AiAgentAdapter::getMobType() const {
	return (static_cast<AiAgent*>(stub))->getMobType();
}

bool AiAgentAdapter::isHerbivore() const {
	return (static_cast<AiAgent*>(stub))->isHerbivore();
}

bool AiAgentAdapter::isCarnivore() const {
	return (static_cast<AiAgent*>(stub))->isCarnivore();
}

bool AiAgentAdapter::isMonster() const {
	return (static_cast<AiAgent*>(stub))->isMonster();
}

bool AiAgentAdapter::isDroid() const {
	return (static_cast<AiAgent*>(stub))->isDroid();
}

bool AiAgentAdapter::isAndroid() const {
	return (static_cast<AiAgent*>(stub))->isAndroid();
}

bool AiAgentAdapter::isNpc() const {
	return (static_cast<AiAgent*>(stub))->isNpc();
}

bool AiAgentAdapter::isHumanoid() const {
	return (static_cast<AiAgent*>(stub))->isHumanoid();
}

bool AiAgentAdapter::isVehicleType() const {
	return (static_cast<AiAgent*>(stub))->isVehicleType();
}

void AiAgentAdapter::addTargetMissCount(unsigned long long target, int misses) {
	(static_cast<AiAgent*>(stub))->addTargetMissCount(target, misses);
}

void AiAgentAdapter::setTargetMissCount(unsigned long long target, int misses) {
	(static_cast<AiAgent*>(stub))->setTargetMissCount(target, misses);
}

void AiAgentAdapter::removeTargetMissCount(unsigned long long target) {
	(static_cast<AiAgent*>(stub))->removeTargetMissCount(target);
}

String AiAgentAdapter::getErrorContext() {
	return (static_cast<AiAgent*>(stub))->getErrorContext();
}

bool AiAgentAdapter::isTauntable() const {
	return (static_cast<AiAgent*>(stub))->isTauntable();
}

void AiAgentAdapter::setMindTricked(bool val) {
	(static_cast<AiAgent*>(stub))->setMindTricked(val);
}

bool AiAgentAdapter::isMindTricked() const {
	return (static_cast<AiAgent*>(stub))->isMindTricked();
}

bool AiAgentAdapter::isHamRegenDisabled() const {
	return (static_cast<AiAgent*>(stub))->isHamRegenDisabled();
}

void AiAgentAdapter::setHamRegenDisabled(bool val) {
	(static_cast<AiAgent*>(stub))->setHamRegenDisabled(val);
}

/*
 *	AiAgentHelper
 */

AiAgentHelper* AiAgentHelper::staticInitializer = AiAgentHelper::instance();

AiAgentHelper::AiAgentHelper() {
	className = "AiAgent";

	Core::getObjectBroker()->registerClass(className, this);
}

void AiAgentHelper::finalizeHelper() {
	AiAgentHelper::finalize();
}

DistributedObject* AiAgentHelper::instantiateObject() {
	return new AiAgent(DummyConstructorParameter::instance());
}

DistributedObjectServant* AiAgentHelper::instantiateServant() {
	return new AiAgentImplementation();
}

DistributedObjectPOD* AiAgentHelper::instantiatePOD() {
	return new AiAgentPOD();
}

DistributedObjectAdapter* AiAgentHelper::createAdapter(DistributedObjectStub* obj) {
	DistributedObjectAdapter* adapter = new AiAgentAdapter(static_cast<AiAgent*>(obj));

	obj->_setClassName(className);
	obj->_setClassHelper(this);

	adapter->setStub(obj);

	return adapter;
}

/*
 *	AiAgentPOD
 */

AiAgentPOD::~AiAgentPOD() {
	finalize();
}

AiAgentPOD::AiAgentPOD(void) {
	_className = "AiAgent";
}


void AiAgentPOD::writeJSON(nlohmann::json& j) {
	CreatureObjectPOD::writeJSON(j);

	nlohmann::json thisObject = nlohmann::json::object();
	if (skillCommands)
		thisObject["skillCommands"] = skillCommands.value();

	if (defaultWeapon)
		thisObject["defaultWeapon"] = defaultWeapon.value();

	if (primaryWeapon)
		thisObject["primaryWeapon"] = primaryWeapon.value();

	if (secondaryWeapon)
		thisObject["secondaryWeapon"] = secondaryWeapon.value();

	if (thrownWeapon)
		thisObject["thrownWeapon"] = thrownWeapon.value();

	if (currentWeapon)
		thisObject["currentWeapon"] = currentWeapon.value();

	if (npcTemplate)
		thisObject["npcTemplate"] = npcTemplate.value();

	if (convoTemplateCRC)
		thisObject["convoTemplateCRC"] = convoTemplateCRC.value();

	if (homeObject)
		thisObject["homeObject"] = homeObject.value();

	if (eventArea)
		thisObject["eventArea"] = eventArea.value();

	if (showNextMovementPosition)
		thisObject["showNextMovementPosition"] = showNextMovementPosition.value();

	if (movementMarkers)
		thisObject["movementMarkers"] = movementMarkers.value();

	if (despawnOnNoPlayerInRange)
		thisObject["despawnOnNoPlayerInRange"] = despawnOnNoPlayerInRange.value();

	if (followObject)
		thisObject["followObject"] = followObject.value();

	if (followStore)
		thisObject["followStore"] = followStore.value();

	if (movementState)
		thisObject["movementState"] = movementState.value();

	if (nextBehaviorInterval)
		thisObject["nextBehaviorInterval"] = nextBehaviorInterval.value();

	if (reactionRank)
		thisObject["reactionRank"] = reactionRank.value();

	if (respawnTimer)
		thisObject["respawnTimer"] = respawnTimer.value();

	if (respawnCounter)
		thisObject["respawnCounter"] = respawnCounter.value();

	if (randomRespawn)
		thisObject["randomRespawn"] = randomRespawn.value();

	if (coordinateMin)
		thisObject["coordinateMin"] = coordinateMin.value();

	if (coordinateMax)
		thisObject["coordinateMax"] = coordinateMax.value();

	if (loadedOutfit)
		thisObject["loadedOutfit"] = loadedOutfit.value();

	if (petDeed)
		thisObject["petDeed"] = petDeed.value();

	if (aiTemplate)
		thisObject["aiTemplate"] = aiTemplate.value();

	if (lairTemplateCRC)
		thisObject["lairTemplateCRC"] = lairTemplateCRC.value();

	if (creatureBitmask)
		thisObject["creatureBitmask"] = creatureBitmask.value();

	if (fleeRange)
		thisObject["fleeRange"] = fleeRange.value();

	if (tauntable)
		thisObject["tauntable"] = tauntable.value();

	if (nextActionCRC)
		thisObject["nextActionCRC"] = nextActionCRC.value();

	if (nextActionArgs)
		thisObject["nextActionArgs"] = nextActionArgs.value();

	j["AiAgent"] = thisObject;
}


void AiAgentPOD::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = AiAgentPOD::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int AiAgentPOD::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = CreatureObjectPOD::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	if (skillCommands) {
	_nameHashCode = 0xbf666870; //AiAgent.skillCommands
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector<String> >::toBinaryStream(&skillCommands.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (defaultWeapon) {
	_nameHashCode = 0xd110fe72; //AiAgent.defaultWeapon
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedReference<WeaponObjectPOD* > >::toBinaryStream(&defaultWeapon.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (primaryWeapon) {
	_nameHashCode = 0xf6a74276; //AiAgent.primaryWeapon
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedReference<WeaponObjectPOD* > >::toBinaryStream(&primaryWeapon.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (secondaryWeapon) {
	_nameHashCode = 0x569d4777; //AiAgent.secondaryWeapon
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedReference<WeaponObjectPOD* > >::toBinaryStream(&secondaryWeapon.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (thrownWeapon) {
	_nameHashCode = 0xcb2e56a1; //AiAgent.thrownWeapon
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedReference<WeaponObjectPOD* > >::toBinaryStream(&thrownWeapon.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (currentWeapon) {
	_nameHashCode = 0x708319c4; //AiAgent.currentWeapon
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedReference<WeaponObjectPOD* > >::toBinaryStream(&currentWeapon.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (npcTemplate) {
	_nameHashCode = 0x3ce94741; //AiAgent.npcTemplate
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<CreatureTemplateReference >::toBinaryStream(&npcTemplate.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (convoTemplateCRC) {
	_nameHashCode = 0x170c1aa2; //AiAgent.convoTemplateCRC
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned int >::toBinaryStream(&convoTemplateCRC.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (homeObject) {
	_nameHashCode = 0x6ccc7b64; //AiAgent.homeObject
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedWeakReference<SceneObjectPOD* > >::toBinaryStream(&homeObject.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (eventArea) {
	_nameHashCode = 0x8abad218; //AiAgent.eventArea
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedWeakReference<ActiveAreaPOD* > >::toBinaryStream(&eventArea.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (showNextMovementPosition) {
	_nameHashCode = 0x903a02dc; //AiAgent.showNextMovementPosition
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&showNextMovementPosition.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (movementMarkers) {
	_nameHashCode = 0x35937577; //AiAgent.movementMarkers
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector<ManagedReference<SceneObjectPOD* > > >::toBinaryStream(&movementMarkers.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (despawnOnNoPlayerInRange) {
	_nameHashCode = 0x9ad20484; //AiAgent.despawnOnNoPlayerInRange
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&despawnOnNoPlayerInRange.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (followObject) {
	_nameHashCode = 0x63fb116c; //AiAgent.followObject
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedWeakReference<SceneObjectPOD* > >::toBinaryStream(&followObject.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (followStore) {
	_nameHashCode = 0xab948a97; //AiAgent.followStore
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedWeakReference<SceneObjectPOD* > >::toBinaryStream(&followStore.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (movementState) {
	_nameHashCode = 0x1607a4a3; //AiAgent.movementState
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned int >::toBinaryStream(&movementState.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (nextBehaviorInterval) {
	_nameHashCode = 0xfb7d99f9; //AiAgent.nextBehaviorInterval
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&nextBehaviorInterval.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (reactionRank) {
	_nameHashCode = 0xc629a7b0; //AiAgent.reactionRank
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&reactionRank.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (respawnTimer) {
	_nameHashCode = 0x1bd8778f; //AiAgent.respawnTimer
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&respawnTimer.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (respawnCounter) {
	_nameHashCode = 0x43da33b7; //AiAgent.respawnCounter
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&respawnCounter.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (randomRespawn) {
	_nameHashCode = 0x6c050a2e; //AiAgent.randomRespawn
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&randomRespawn.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (coordinateMin) {
	_nameHashCode = 0xdae0cc7f; //AiAgent.coordinateMin
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&coordinateMin.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (coordinateMax) {
	_nameHashCode = 0x63f19ef; //AiAgent.coordinateMax
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&coordinateMax.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (loadedOutfit) {
	_nameHashCode = 0x8b8554f8; //AiAgent.loadedOutfit
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&loadedOutfit.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (petDeed) {
	_nameHashCode = 0x8f637eb; //AiAgent.petDeed
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedReference<PetDeedPOD* > >::toBinaryStream(&petDeed.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (aiTemplate) {
	_nameHashCode = 0x44c03b92; //AiAgent.aiTemplate
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&aiTemplate.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (lairTemplateCRC) {
	_nameHashCode = 0x2b21755e; //AiAgent.lairTemplateCRC
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned int >::toBinaryStream(&lairTemplateCRC.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (creatureBitmask) {
	_nameHashCode = 0x1f128f38; //AiAgent.creatureBitmask
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned int >::toBinaryStream(&creatureBitmask.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (fleeRange) {
	_nameHashCode = 0x5eec736c; //AiAgent.fleeRange
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&fleeRange.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (tauntable) {
	_nameHashCode = 0x11c742b6; //AiAgent.tauntable
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&tauntable.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (nextActionCRC) {
	_nameHashCode = 0xe272963f; //AiAgent.nextActionCRC
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned int >::toBinaryStream(&nextActionCRC.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (nextActionArgs) {
	_nameHashCode = 0x35f6d4; //AiAgent.nextActionArgs
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&nextActionArgs.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}


	return _count;
}

bool AiAgentPOD::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (CreatureObjectPOD::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0xbf666870: //AiAgent.skillCommands
		{
			Vector<String> _mnskillCommands;
			TypeInfo<Vector<String> >::parseFromBinaryStream(&_mnskillCommands, stream);
			skillCommands = std::move(_mnskillCommands);
		}
		return true;

	case 0xd110fe72: //AiAgent.defaultWeapon
		{
			ManagedReference<WeaponObjectPOD* > _mndefaultWeapon;
			TypeInfo<ManagedReference<WeaponObjectPOD* > >::parseFromBinaryStream(&_mndefaultWeapon, stream);
			defaultWeapon = std::move(_mndefaultWeapon);
		}
		return true;

	case 0xf6a74276: //AiAgent.primaryWeapon
		{
			ManagedReference<WeaponObjectPOD* > _mnprimaryWeapon;
			TypeInfo<ManagedReference<WeaponObjectPOD* > >::parseFromBinaryStream(&_mnprimaryWeapon, stream);
			primaryWeapon = std::move(_mnprimaryWeapon);
		}
		return true;

	case 0x569d4777: //AiAgent.secondaryWeapon
		{
			ManagedReference<WeaponObjectPOD* > _mnsecondaryWeapon;
			TypeInfo<ManagedReference<WeaponObjectPOD* > >::parseFromBinaryStream(&_mnsecondaryWeapon, stream);
			secondaryWeapon = std::move(_mnsecondaryWeapon);
		}
		return true;

	case 0xcb2e56a1: //AiAgent.thrownWeapon
		{
			ManagedReference<WeaponObjectPOD* > _mnthrownWeapon;
			TypeInfo<ManagedReference<WeaponObjectPOD* > >::parseFromBinaryStream(&_mnthrownWeapon, stream);
			thrownWeapon = std::move(_mnthrownWeapon);
		}
		return true;

	case 0x708319c4: //AiAgent.currentWeapon
		{
			ManagedReference<WeaponObjectPOD* > _mncurrentWeapon;
			TypeInfo<ManagedReference<WeaponObjectPOD* > >::parseFromBinaryStream(&_mncurrentWeapon, stream);
			currentWeapon = std::move(_mncurrentWeapon);
		}
		return true;

	case 0x3ce94741: //AiAgent.npcTemplate
		{
			CreatureTemplateReference _mnnpcTemplate;
			TypeInfo<CreatureTemplateReference >::parseFromBinaryStream(&_mnnpcTemplate, stream);
			npcTemplate = std::move(_mnnpcTemplate);
		}
		return true;

	case 0x170c1aa2: //AiAgent.convoTemplateCRC
		{
			unsigned int _mnconvoTemplateCRC;
			TypeInfo<unsigned int >::parseFromBinaryStream(&_mnconvoTemplateCRC, stream);
			convoTemplateCRC = std::move(_mnconvoTemplateCRC);
		}
		return true;

	case 0x6ccc7b64: //AiAgent.homeObject
		{
			ManagedWeakReference<SceneObjectPOD* > _mnhomeObject;
			TypeInfo<ManagedWeakReference<SceneObjectPOD* > >::parseFromBinaryStream(&_mnhomeObject, stream);
			homeObject = std::move(_mnhomeObject);
		}
		return true;

	case 0x8abad218: //AiAgent.eventArea
		{
			ManagedWeakReference<ActiveAreaPOD* > _mneventArea;
			TypeInfo<ManagedWeakReference<ActiveAreaPOD* > >::parseFromBinaryStream(&_mneventArea, stream);
			eventArea = std::move(_mneventArea);
		}
		return true;

	case 0x903a02dc: //AiAgent.showNextMovementPosition
		{
			bool _mnshowNextMovementPosition;
			TypeInfo<bool >::parseFromBinaryStream(&_mnshowNextMovementPosition, stream);
			showNextMovementPosition = std::move(_mnshowNextMovementPosition);
		}
		return true;

	case 0x35937577: //AiAgent.movementMarkers
		{
			Vector<ManagedReference<SceneObjectPOD* > > _mnmovementMarkers;
			TypeInfo<Vector<ManagedReference<SceneObjectPOD* > > >::parseFromBinaryStream(&_mnmovementMarkers, stream);
			movementMarkers = std::move(_mnmovementMarkers);
		}
		return true;

	case 0x9ad20484: //AiAgent.despawnOnNoPlayerInRange
		{
			bool _mndespawnOnNoPlayerInRange;
			TypeInfo<bool >::parseFromBinaryStream(&_mndespawnOnNoPlayerInRange, stream);
			despawnOnNoPlayerInRange = std::move(_mndespawnOnNoPlayerInRange);
		}
		return true;

	case 0x63fb116c: //AiAgent.followObject
		{
			ManagedWeakReference<SceneObjectPOD* > _mnfollowObject;
			TypeInfo<ManagedWeakReference<SceneObjectPOD* > >::parseFromBinaryStream(&_mnfollowObject, stream);
			followObject = std::move(_mnfollowObject);
		}
		return true;

	case 0xab948a97: //AiAgent.followStore
		{
			ManagedWeakReference<SceneObjectPOD* > _mnfollowStore;
			TypeInfo<ManagedWeakReference<SceneObjectPOD* > >::parseFromBinaryStream(&_mnfollowStore, stream);
			followStore = std::move(_mnfollowStore);
		}
		return true;

	case 0x1607a4a3: //AiAgent.movementState
		{
			unsigned int _mnmovementState;
			TypeInfo<unsigned int >::parseFromBinaryStream(&_mnmovementState, stream);
			movementState = std::move(_mnmovementState);
		}
		return true;

	case 0xfb7d99f9: //AiAgent.nextBehaviorInterval
		{
			int _mnnextBehaviorInterval;
			TypeInfo<int >::parseFromBinaryStream(&_mnnextBehaviorInterval, stream);
			nextBehaviorInterval = std::move(_mnnextBehaviorInterval);
		}
		return true;

	case 0xc629a7b0: //AiAgent.reactionRank
		{
			int _mnreactionRank;
			TypeInfo<int >::parseFromBinaryStream(&_mnreactionRank, stream);
			reactionRank = std::move(_mnreactionRank);
		}
		return true;

	case 0x1bd8778f: //AiAgent.respawnTimer
		{
			float _mnrespawnTimer;
			TypeInfo<float >::parseFromBinaryStream(&_mnrespawnTimer, stream);
			respawnTimer = std::move(_mnrespawnTimer);
		}
		return true;

	case 0x43da33b7: //AiAgent.respawnCounter
		{
			int _mnrespawnCounter;
			TypeInfo<int >::parseFromBinaryStream(&_mnrespawnCounter, stream);
			respawnCounter = std::move(_mnrespawnCounter);
		}
		return true;

	case 0x6c050a2e: //AiAgent.randomRespawn
		{
			bool _mnrandomRespawn;
			TypeInfo<bool >::parseFromBinaryStream(&_mnrandomRespawn, stream);
			randomRespawn = std::move(_mnrandomRespawn);
		}
		return true;

	case 0xdae0cc7f: //AiAgent.coordinateMin
		{
			float _mncoordinateMin;
			TypeInfo<float >::parseFromBinaryStream(&_mncoordinateMin, stream);
			coordinateMin = std::move(_mncoordinateMin);
		}
		return true;

	case 0x63f19ef: //AiAgent.coordinateMax
		{
			float _mncoordinateMax;
			TypeInfo<float >::parseFromBinaryStream(&_mncoordinateMax, stream);
			coordinateMax = std::move(_mncoordinateMax);
		}
		return true;

	case 0x8b8554f8: //AiAgent.loadedOutfit
		{
			bool _mnloadedOutfit;
			TypeInfo<bool >::parseFromBinaryStream(&_mnloadedOutfit, stream);
			loadedOutfit = std::move(_mnloadedOutfit);
		}
		return true;

	case 0x8f637eb: //AiAgent.petDeed
		{
			ManagedReference<PetDeedPOD* > _mnpetDeed;
			TypeInfo<ManagedReference<PetDeedPOD* > >::parseFromBinaryStream(&_mnpetDeed, stream);
			petDeed = std::move(_mnpetDeed);
		}
		return true;

	case 0x44c03b92: //AiAgent.aiTemplate
		{
			String _mnaiTemplate;
			TypeInfo<String >::parseFromBinaryStream(&_mnaiTemplate, stream);
			aiTemplate = std::move(_mnaiTemplate);
		}
		return true;

	case 0x2b21755e: //AiAgent.lairTemplateCRC
		{
			unsigned int _mnlairTemplateCRC;
			TypeInfo<unsigned int >::parseFromBinaryStream(&_mnlairTemplateCRC, stream);
			lairTemplateCRC = std::move(_mnlairTemplateCRC);
		}
		return true;

	case 0x1f128f38: //AiAgent.creatureBitmask
		{
			unsigned int _mncreatureBitmask;
			TypeInfo<unsigned int >::parseFromBinaryStream(&_mncreatureBitmask, stream);
			creatureBitmask = std::move(_mncreatureBitmask);
		}
		return true;

	case 0x5eec736c: //AiAgent.fleeRange
		{
			float _mnfleeRange;
			TypeInfo<float >::parseFromBinaryStream(&_mnfleeRange, stream);
			fleeRange = std::move(_mnfleeRange);
		}
		return true;

	case 0x11c742b6: //AiAgent.tauntable
		{
			bool _mntauntable;
			TypeInfo<bool >::parseFromBinaryStream(&_mntauntable, stream);
			tauntable = std::move(_mntauntable);
		}
		return true;

	case 0xe272963f: //AiAgent.nextActionCRC
		{
			unsigned int _mnnextActionCRC;
			TypeInfo<unsigned int >::parseFromBinaryStream(&_mnnextActionCRC, stream);
			nextActionCRC = std::move(_mnnextActionCRC);
		}
		return true;

	case 0x35f6d4: //AiAgent.nextActionArgs
		{
			String _mnnextActionArgs;
			TypeInfo<String >::parseFromBinaryStream(&_mnnextActionArgs, stream);
			nextActionArgs = std::move(_mnnextActionArgs);
		}
		return true;

	}

	return false;
}

void AiAgentPOD::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(AiAgentPOD::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

}

void AiAgentPOD::writeObjectCompact(ObjectOutputStream* stream) {
	CreatureObjectPOD::writeObjectCompact(stream);

	TypeInfo<Vector<String> >::toBinaryStream(&skillCommands.value(), stream);

	TypeInfo<ManagedReference<WeaponObjectPOD* > >::toBinaryStream(&defaultWeapon.value(), stream);

	TypeInfo<ManagedReference<WeaponObjectPOD* > >::toBinaryStream(&primaryWeapon.value(), stream);

	TypeInfo<ManagedReference<WeaponObjectPOD* > >::toBinaryStream(&secondaryWeapon.value(), stream);

	TypeInfo<ManagedReference<WeaponObjectPOD* > >::toBinaryStream(&thrownWeapon.value(), stream);

	TypeInfo<ManagedReference<WeaponObjectPOD* > >::toBinaryStream(&currentWeapon.value(), stream);

	TypeInfo<CreatureTemplateReference >::toBinaryStream(&npcTemplate.value(), stream);

	TypeInfo<unsigned int >::toBinaryStream(&convoTemplateCRC.value(), stream);

	TypeInfo<ManagedWeakReference<SceneObjectPOD* > >::toBinaryStream(&homeObject.value(), stream);

	TypeInfo<ManagedWeakReference<ActiveAreaPOD* > >::toBinaryStream(&eventArea.value(), stream);

	TypeInfo<bool >::toBinaryStream(&showNextMovementPosition.value(), stream);

	TypeInfo<Vector<ManagedReference<SceneObjectPOD* > > >::toBinaryStream(&movementMarkers.value(), stream);

	TypeInfo<bool >::toBinaryStream(&despawnOnNoPlayerInRange.value(), stream);

	TypeInfo<ManagedWeakReference<SceneObjectPOD* > >::toBinaryStream(&followObject.value(), stream);

	TypeInfo<ManagedWeakReference<SceneObjectPOD* > >::toBinaryStream(&followStore.value(), stream);

	TypeInfo<unsigned int >::toBinaryStream(&movementState.value(), stream);

	TypeInfo<int >::toBinaryStream(&nextBehaviorInterval.value(), stream);

	TypeInfo<int >::toBinaryStream(&reactionRank.value(), stream);

	TypeInfo<float >::toBinaryStream(&respawnTimer.value(), stream);

	TypeInfo<int >::toBinaryStream(&respawnCounter.value(), stream);

	TypeInfo<bool >::toBinaryStream(&randomRespawn.value(), stream);

	TypeInfo<float >::toBinaryStream(&coordinateMin.value(), stream);

	TypeInfo<float >::toBinaryStream(&coordinateMax.value(), stream);

	TypeInfo<bool >::toBinaryStream(&loadedOutfit.value(), stream);

	TypeInfo<ManagedReference<PetDeedPOD* > >::toBinaryStream(&petDeed.value(), stream);

	TypeInfo<String >::toBinaryStream(&aiTemplate.value(), stream);

	TypeInfo<unsigned int >::toBinaryStream(&lairTemplateCRC.value(), stream);

	TypeInfo<unsigned int >::toBinaryStream(&creatureBitmask.value(), stream);

	TypeInfo<float >::toBinaryStream(&fleeRange.value(), stream);

	TypeInfo<bool >::toBinaryStream(&tauntable.value(), stream);

	TypeInfo<unsigned int >::toBinaryStream(&nextActionCRC.value(), stream);

	TypeInfo<String >::toBinaryStream(&nextActionArgs.value(), stream);


}

