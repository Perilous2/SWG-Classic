/*
 *	autogen/server/zone/objects/area/ActiveArea.h generated by engine3 IDL compiler 0.70
 */

#ifndef ACTIVEAREA_H_
#define ACTIVEAREA_H_

#include "engine/core/Core.h"

#include "engine/core/ManagedReference.h"

#include "engine/core/ManagedWeakReference.h"

#include "system/util/Optional.h"

#ifndef likely
#ifdef __GNUC__
#define likely(x)       __builtin_expect(!!(x), 1)
#define unlikely(x)     __builtin_expect(!!(x), 0)
#else
#define likely(x)       (x)
#define unlikely(x)     (x)
#endif
#endif
#include "engine/util/json_utils.h"

namespace server {
namespace zone {

class Zone;

class ZonePOD;

} // namespace zone
} // namespace server

using namespace server::zone;

namespace server {
namespace zone {
namespace objects {
namespace pathfinding {

class NavArea;

class NavAreaPOD;

} // namespace pathfinding
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::pathfinding;

namespace server {
namespace zone {
namespace objects {
namespace region {

class Region;

class RegionPOD;

} // namespace region
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::region;

#include "gmock/gmock.h"

#include "server/zone/objects/scene/SceneObject.h"

#include "server/zone/objects/area/areashapes/AreaShape.h"

#include "system/util/Vector.h"

#include "engine/util/u3d/Vector3.h"

#include "engine/util/u3d/Vector4.h"

namespace server {
namespace zone {
namespace objects {
namespace area {

class ActiveArea : public SceneObject {
public:
	static const int UNDEFINEDAREA = 0x000000;

	static const int SPAWNAREA = 0x000001;

	static const int NOSPAWNAREA = 0x000002;

	static const int WORLDSPAWNAREA = 0x000004;

	static const int NOWORLDSPAWNAREA = 0x000008;

	static const int NOBUILDZONEAREA = 0x000010;

	static const int CAMPINGAREA = 0x000020;

	static const int CITY = 0x000040;

	static const int NAVAREA = 0x000080;

	static const int NAMEDREGION = 0x000100;

	static const int LOCKEDAREA = 0x000200;

	static const int CIRCLE = 1;

	static const int RECTANGLE = 2;

	static const int RING = 3;

	ActiveArea();

	/**
	 * Sends the necessary messages to player in order to create this object
	 * @pre { this object is locked }
	 * @post { this object is locked, player received this object }
	 * @param player SceneObject that will receive the messages
	 * @param doClose if true a SceneObjectCloseMessage is sent to finish the object
	 */
	void sendTo(SceneObject* player, bool doClose, bool forceLoadContainer = true);

	virtual void enqueueEnterEvent(SceneObject* obj);

	virtual void enqueueExitEvent(SceneObject* obj);

	void notifyEnter(SceneObject* object);

	void notifyExit(SceneObject* object);

	void sendDebugMessage(SceneObject* creature, bool entry);

	void setZone(Zone* zone);

	bool containsPoint(float x, float y, unsigned long long cellid) const;

	bool containsPoint(float x, float y) const;

	bool intersectsWith(ActiveArea* area) const;

	NavArea* asNavArea();

	Region* asRegion();

	void setRegionFlags(unsigned int flags);

	void setAreaName(const String& name);

	bool isActiveArea();

	bool isRegion();

	bool isNavArea() const;

	bool isCampArea();

	bool isUndefinedRegion() const;

	bool isCityRegion() const;

	bool isSpawnArea() const;

	bool isNoSpawnArea() const;

	bool isWorldSpawnArea() const;

	bool isNoWorldSpawnArea() const;

	bool isNoBuildZone() const;

	bool isCampingArea() const;

	bool shouldBuildNavmesh() const;

	bool isNamedRegion() const;

	bool isLockedArea() const;

	bool isPvpArea() const;

	bool isOvertOnlyArea() const;

	bool isRebelOnlyArea() const;

	bool isImperialOnlyArea() const;

	bool isNoCombatArea() const;

	bool isNoPetArea() const;

	bool isRectangularAreaShape() const;

	void addAreaFlag(unsigned int flag);

	void removeAreaFlag(unsigned int flag);

	void setRadius(float r);

	void setPvpArea(bool val);

	void setOvertOnlyArea(bool val);

	void setRebelOnlyArea(bool val);

	void setImperialOnlyArea(bool val);

	void setNoCombatArea(bool val);

	void setNoPetArea(bool val);

	void setLockedArea(bool val);

	void setCellObjectID(unsigned long long celloid);

	void setAreaShape(AreaShape* area);

	int getAreaFlags() const;

	Vector3 getAreaCenter() const;

	float getRadius2() const;

	float getRadius() const;

	float getHeight() const;

	float getWidth() const;

	Vector4 getRectangularDimensions() const;

	unsigned long long getCellObjectID() const;

	AreaShape* getAreaShape() const;

	String getAreaName() const;

	void attachScenery(SceneObject* scene);

	void initializeChildObject(SceneObject* controllerObject);

	bool ejectFromArea(SceneObject* object);

	DistributedObjectServant* _getImplementation();
	DistributedObjectServant* _getImplementationForRead() const;

	void _setImplementation(DistributedObjectServant* servant);

protected:
	ActiveArea(DummyConstructorParameter* param);

	virtual ~ActiveArea();

	friend class ActiveAreaHelper;
};

} // namespace area
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::area;

namespace server {
namespace zone {
namespace objects {
namespace area {

class ActiveAreaImplementation : public SceneObjectImplementation {
protected:
	unsigned long long cellObjectID;

	bool pvpArea;

	bool overtOnlyArea;

	bool rebelOnlyArea;

	bool imperialOnlyArea;

	bool noCombatArea;

	bool noPetArea;

	ManagedReference<AreaShape* > areaShape;

	Vector<ManagedReference<SceneObject* > > attachedScenery;

	unsigned int areaFlags;

	String areaName;

public:
	static const int UNDEFINEDAREA = 0x000000;

	static const int SPAWNAREA = 0x000001;

	static const int NOSPAWNAREA = 0x000002;

	static const int WORLDSPAWNAREA = 0x000004;

	static const int NOWORLDSPAWNAREA = 0x000008;

	static const int NOBUILDZONEAREA = 0x000010;

	static const int CAMPINGAREA = 0x000020;

	static const int CITY = 0x000040;

	static const int NAVAREA = 0x000080;

	static const int NAMEDREGION = 0x000100;

	static const int LOCKEDAREA = 0x000200;

	static const int CIRCLE = 1;

	static const int RECTANGLE = 2;

	static const int RING = 3;

	ActiveAreaImplementation();

	ActiveAreaImplementation(DummyConstructorParameter* param);

	/**
	 * Sends the necessary messages to player in order to create this object
	 * @pre { this object is locked }
	 * @post { this object is locked, player received this object }
	 * @param player SceneObject that will receive the messages
	 * @param doClose if true a SceneObjectCloseMessage is sent to finish the object
	 */
	void sendTo(SceneObject* player, bool doClose, bool forceLoadContainer = true);

	virtual void enqueueEnterEvent(SceneObject* obj);

	virtual void enqueueExitEvent(SceneObject* obj);

	virtual void notifyEnter(SceneObject* object);

	virtual void notifyExit(SceneObject* object);

	void sendDebugMessage(SceneObject* creature, bool entry);

	void setZone(Zone* zone);

	bool containsPoint(float x, float y, unsigned long long cellid) const;

	virtual bool containsPoint(float x, float y) const;

	bool intersectsWith(ActiveArea* area) const;

	virtual NavArea* asNavArea();

	virtual Region* asRegion();

	void setRegionFlags(unsigned int flags);

	void setAreaName(const String& name);

	bool isActiveArea();

	virtual bool isRegion();

	virtual bool isNavArea() const;

	virtual bool isCampArea();

	bool isUndefinedRegion() const;

	bool isCityRegion() const;

	bool isSpawnArea() const;

	bool isNoSpawnArea() const;

	bool isWorldSpawnArea() const;

	bool isNoWorldSpawnArea() const;

	bool isNoBuildZone() const;

	bool isCampingArea() const;

	bool shouldBuildNavmesh() const;

	bool isNamedRegion() const;

	bool isLockedArea() const;

	bool isPvpArea() const;

	bool isOvertOnlyArea() const;

	bool isRebelOnlyArea() const;

	bool isImperialOnlyArea() const;

	bool isNoCombatArea() const;

	bool isNoPetArea() const;

	bool isRectangularAreaShape() const;

	void addAreaFlag(unsigned int flag);

	void removeAreaFlag(unsigned int flag);

	void setRadius(float r);

	void setPvpArea(bool val);

	void setOvertOnlyArea(bool val);

	void setRebelOnlyArea(bool val);

	void setImperialOnlyArea(bool val);

	void setNoCombatArea(bool val);

	void setNoPetArea(bool val);

	void setLockedArea(bool val);

	void setCellObjectID(unsigned long long celloid);

	void setAreaShape(AreaShape* area);

	int getAreaFlags() const;

	Vector3 getAreaCenter() const;

	float getRadius2() const;

	float getRadius() const;

	float getHeight() const;

	float getWidth() const;

	Vector4 getRectangularDimensions() const;

	unsigned long long getCellObjectID() const;

	AreaShape* getAreaShape() const;

	String getAreaName() const;

	void attachScenery(SceneObject* scene);

	void initializeChildObject(SceneObject* controllerObject);

	bool ejectFromArea(SceneObject* object);

	WeakReference<ActiveArea*> _this;

	operator const ActiveArea*();

	DistributedObjectStub* _getStub();
	virtual void readObject(ObjectInputStream* stream);
	virtual void writeObject(ObjectOutputStream* stream);
	virtual void writeJSON(nlohmann::json& j);
protected:
	virtual ~ActiveAreaImplementation();

	void finalize();

	void _initializeImplementation();

	void _setStub(DistributedObjectStub* stub);

	void lock(bool doLock = true);

	void lock(ManagedObject* obj);

	void rlock(bool doLock = true);

	void wlock(bool doLock = true);

	void wlock(ManagedObject* obj);

	void unlock(bool doLock = true);

	void runlock(bool doLock = true);

	void _serializationHelperMethod();
	bool readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode);
	int writeObjectMembers(ObjectOutputStream* stream);

	friend class ActiveArea;
};

class ActiveAreaAdapter : public SceneObjectAdapter {
public:
	ActiveAreaAdapter(ActiveArea* impl);

	void invokeMethod(sys::uint32 methid, DistributedMethod* method);

	void sendTo(SceneObject* player, bool doClose, bool forceLoadContainer);

	void enqueueEnterEvent(SceneObject* obj);

	void enqueueExitEvent(SceneObject* obj);

	void notifyEnter(SceneObject* object);

	void notifyExit(SceneObject* object);

	void sendDebugMessage(SceneObject* creature, bool entry);

	void setZone(Zone* zone);

	bool containsPoint(float x, float y, unsigned long long cellid) const;

	bool containsPoint(float x, float y) const;

	bool intersectsWith(ActiveArea* area) const;

	void setRegionFlags(unsigned int flags);

	void setAreaName(const String& name);

	bool isActiveArea();

	bool isRegion();

	bool isNavArea() const;

	bool isCampArea();

	bool isUndefinedRegion() const;

	bool isCityRegion() const;

	bool isSpawnArea() const;

	bool isNoSpawnArea() const;

	bool isWorldSpawnArea() const;

	bool isNoWorldSpawnArea() const;

	bool isNoBuildZone() const;

	bool isCampingArea() const;

	bool shouldBuildNavmesh() const;

	bool isNamedRegion() const;

	bool isLockedArea() const;

	bool isPvpArea() const;

	bool isOvertOnlyArea() const;

	bool isRebelOnlyArea() const;

	bool isImperialOnlyArea() const;

	bool isNoCombatArea() const;

	bool isNoPetArea() const;

	bool isRectangularAreaShape() const;

	void addAreaFlag(unsigned int flag);

	void removeAreaFlag(unsigned int flag);

	void setRadius(float r);

	void setPvpArea(bool val);

	void setOvertOnlyArea(bool val);

	void setRebelOnlyArea(bool val);

	void setImperialOnlyArea(bool val);

	void setNoCombatArea(bool val);

	void setNoPetArea(bool val);

	void setLockedArea(bool val);

	void setCellObjectID(unsigned long long celloid);

	void setAreaShape(AreaShape* area);

	int getAreaFlags() const;

	float getRadius2() const;

	float getRadius() const;

	float getHeight() const;

	float getWidth() const;

	unsigned long long getCellObjectID() const;

	AreaShape* getAreaShape() const;

	String getAreaName() const;

	void attachScenery(SceneObject* scene);

	void initializeChildObject(SceneObject* controllerObject);

};

class ActiveAreaHelper : public DistributedObjectClassHelper, public Singleton<ActiveAreaHelper> {
	static ActiveAreaHelper* staticInitializer;

public:
	ActiveAreaHelper();

	void finalizeHelper();

	DistributedObject* instantiateObject();

	DistributedObjectPOD* instantiatePOD();

	DistributedObjectServant* instantiateServant();

	DistributedObjectAdapter* createAdapter(DistributedObjectStub* obj);

	friend class Singleton<ActiveAreaHelper>;
};

class MockActiveArea : public ActiveArea {
public:

	MOCK_METHOD1(enqueueEnterEvent,void(SceneObject* obj));
	MOCK_METHOD1(enqueueExitEvent,void(SceneObject* obj));
	MOCK_METHOD2(isInRange,bool(SceneObject* obj, float range));
	MOCK_METHOD1(getSlottedObjects,void(VectorMap<String, ManagedReference<SceneObject* > >& objects));
	MOCK_METHOD1(getDistanceTo,float(SceneObject* object));
	MOCK_METHOD1(getDistanceTo,float(Coordinate* coordinate));
	MOCK_METHOD0(getZone,Zone*());
	MOCK_METHOD0(getZoneUnsafe,Zone*());
	MOCK_METHOD0(getWorldPositionX,float());
	MOCK_METHOD0(getWorldPositionY,float());
	MOCK_METHOD0(getWorldPositionZ,float());
	MOCK_METHOD0(getWorldPosition,Vector3());
	MOCK_METHOD1(getSlottedObject,Reference<SceneObject* >(const String& slot));
	MOCK_METHOD1(isFacingObject,bool(SceneObject* obj));
	MOCK_METHOD0(getParent,ManagedWeakReference<SceneObject* >());
	MOCK_METHOD0(asCreatureObject,CreatureObject*());
	MOCK_METHOD0(asAiAgent,AiAgent*());
	MOCK_METHOD0(asTangibleObject,TangibleObject*());
	MOCK_METHOD0(getTemplateRadius,float());

};

} // namespace area
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::area;

namespace server {
namespace zone {
namespace objects {
namespace area {

class ActiveAreaPOD : public SceneObjectPOD {
public:
	Optional<unsigned long long> cellObjectID;

	Optional<bool> pvpArea;

	Optional<bool> overtOnlyArea;

	Optional<bool> rebelOnlyArea;

	Optional<bool> imperialOnlyArea;

	Optional<bool> noCombatArea;

	Optional<bool> noPetArea;

	Optional<ManagedReference<AreaShapePOD* >> areaShape;

	Optional<unsigned int> areaFlags;

	Optional<String> areaName;

	String _className;
	ActiveAreaPOD();
	virtual void writeJSON(nlohmann::json& j);
	virtual void readObject(ObjectInputStream* stream);
	virtual void writeObject(ObjectOutputStream* stream);
	bool readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode);
	int writeObjectMembers(ObjectOutputStream* stream);
	void writeObjectCompact(ObjectOutputStream* stream);



	virtual ~ActiveAreaPOD();

};

} // namespace area
} // namespace objects
} // namespace zone
} // namespace server

using namespace server::zone::objects::area;

#endif /*ACTIVEAREAPOD_H_*/
