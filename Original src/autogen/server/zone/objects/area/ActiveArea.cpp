/*
 *	autogen/server/zone/objects/area/ActiveArea.cpp generated by engine3 IDL compiler 0.70
 */

#include "ActiveArea.h"

#include "server/zone/Zone.h"

#include "server/zone/objects/pathfinding/NavArea.h"

#include "server/zone/objects/region/Region.h"

/*
 *	ActiveAreaStub
 */

enum {RPC_SENDTO__SCENEOBJECT_BOOL_BOOL_ = 1878528101,RPC_ENQUEUEENTEREVENT__SCENEOBJECT_,RPC_ENQUEUEEXITEVENT__SCENEOBJECT_,RPC_NOTIFYENTER__SCENEOBJECT_,RPC_NOTIFYEXIT__SCENEOBJECT_,RPC_SENDDEBUGMESSAGE__SCENEOBJECT_BOOL_,RPC_SETZONE__ZONE_,RPC_CONTAINSPOINT__FLOAT_FLOAT_LONG_,RPC_CONTAINSPOINT__FLOAT_FLOAT_,RPC_INTERSECTSWITH__ACTIVEAREA_,RPC_SETREGIONFLAGS__INT_,RPC_SETAREANAME__STRING_,RPC_ISACTIVEAREA__,RPC_ISREGION__,RPC_ISNAVAREA__,RPC_ISCAMPAREA__,RPC_ISUNDEFINEDREGION__,RPC_ISCITYREGION__,RPC_ISSPAWNAREA__,RPC_ISNOSPAWNAREA__,RPC_ISWORLDSPAWNAREA__,RPC_ISNOWORLDSPAWNAREA__,RPC_ISNOBUILDZONE__,RPC_ISCAMPINGAREA__,RPC_SHOULDBUILDNAVMESH__,RPC_ISNAMEDREGION__,RPC_ISLOCKEDAREA__,RPC_ISPVPAREA__,RPC_ISOVERTONLYAREA__,RPC_ISREBELONLYAREA__,RPC_ISIMPERIALONLYAREA__,RPC_ISNOCOMBATAREA__,RPC_ISNOPETAREA__,RPC_ISRECTANGULARAREASHAPE__,RPC_ADDAREAFLAG__INT_,RPC_REMOVEAREAFLAG__INT_,RPC_SETRADIUS__FLOAT_,RPC_SETPVPAREA__BOOL_,RPC_SETOVERTONLYAREA__BOOL_,RPC_SETREBELONLYAREA__BOOL_,RPC_SETIMPERIALONLYAREA__BOOL_,RPC_SETNOCOMBATAREA__BOOL_,RPC_SETNOPETAREA__BOOL_,RPC_SETLOCKEDAREA__BOOL_,RPC_SETCELLOBJECTID__LONG_,RPC_SETAREASHAPE__AREASHAPE_,RPC_GETAREAFLAGS__,RPC_GETRADIUS2__,RPC_GETRADIUS__,RPC_GETHEIGHT__,RPC_GETWIDTH__,RPC_GETCELLOBJECTID__,RPC_GETAREASHAPE__,RPC_GETAREANAME__,RPC_ATTACHSCENERY__SCENEOBJECT_,RPC_INITIALIZECHILDOBJECT__SCENEOBJECT_,};

ActiveArea::ActiveArea() : SceneObject(DummyConstructorParameter::instance()) {
	ActiveAreaImplementation* _implementation = new ActiveAreaImplementation();
	_impl = _implementation;
	_impl->_setStub(this);
	_setClassName("ActiveArea");
}

ActiveArea::ActiveArea(DummyConstructorParameter* param) : SceneObject(param) {
	_setClassName("ActiveArea");
}

ActiveArea::~ActiveArea() {
}



void ActiveArea::sendTo(SceneObject* player, bool doClose, bool forceLoadContainer) {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDTO__SCENEOBJECT_BOOL_BOOL_);
		method.addObjectParameter(player);
		method.addBooleanParameter(doClose);
		method.addBooleanParameter(forceLoadContainer);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendTo(player, doClose, forceLoadContainer);
	}
}

void ActiveArea::enqueueEnterEvent(SceneObject* obj) {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ENQUEUEENTEREVENT__SCENEOBJECT_);
		method.addObjectParameter(obj);

		method.executeWithVoidReturn();
	} else {
		_implementation->enqueueEnterEvent(obj);
	}
}

void ActiveArea::enqueueExitEvent(SceneObject* obj) {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ENQUEUEEXITEVENT__SCENEOBJECT_);
		method.addObjectParameter(obj);

		method.executeWithVoidReturn();
	} else {
		_implementation->enqueueExitEvent(obj);
	}
}

void ActiveArea::notifyEnter(SceneObject* object) {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYENTER__SCENEOBJECT_);
		method.addObjectParameter(object);

		method.executeWithVoidReturn();
	} else {
		_implementation->notifyEnter(object);
	}
}

void ActiveArea::notifyExit(SceneObject* object) {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYEXIT__SCENEOBJECT_);
		method.addObjectParameter(object);

		method.executeWithVoidReturn();
	} else {
		_implementation->notifyExit(object);
	}
}

void ActiveArea::sendDebugMessage(SceneObject* creature, bool entry) {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDDEBUGMESSAGE__SCENEOBJECT_BOOL_);
		method.addObjectParameter(creature);
		method.addBooleanParameter(entry);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendDebugMessage(creature, entry);
	}
}

void ActiveArea::setZone(Zone* zone) {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETZONE__ZONE_);
		method.addObjectParameter(zone);

		method.executeWithVoidReturn();
	} else {
		_implementation->setZone(zone);
	}
}

bool ActiveArea::containsPoint(float x, float y, unsigned long long cellid) const {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CONTAINSPOINT__FLOAT_FLOAT_LONG_);
		method.addFloatParameter(x);
		method.addFloatParameter(y);
		method.addUnsignedLongParameter(cellid);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->containsPoint(x, y, cellid);
	}
}

bool ActiveArea::containsPoint(float x, float y) const {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CONTAINSPOINT__FLOAT_FLOAT_);
		method.addFloatParameter(x);
		method.addFloatParameter(y);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->containsPoint(x, y);
	}
}

bool ActiveArea::intersectsWith(ActiveArea* area) const {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INTERSECTSWITH__ACTIVEAREA_);
		method.addObjectParameter(area);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->intersectsWith(area);
	}
}

NavArea* ActiveArea::asNavArea() {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->asNavArea();
	}
}

Region* ActiveArea::asRegion() {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->asRegion();
	}
}

void ActiveArea::setRegionFlags(unsigned int flags) {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETREGIONFLAGS__INT_);
		method.addUnsignedIntParameter(flags);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setRegionFlags(flags);
	}
}

void ActiveArea::setAreaName(const String& name) {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETAREANAME__STRING_);
		method.addAsciiParameter(name);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setAreaName(name);
	}
}

bool ActiveArea::isActiveArea() {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISACTIVEAREA__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isActiveArea();
	}
}

bool ActiveArea::isRegion() {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISREGION__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isRegion();
	}
}

bool ActiveArea::isNavArea() const {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISNAVAREA__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isNavArea();
	}
}

bool ActiveArea::isCampArea() {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISCAMPAREA__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isCampArea();
	}
}

bool ActiveArea::isUndefinedRegion() const {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISUNDEFINEDREGION__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isUndefinedRegion();
	}
}

bool ActiveArea::isCityRegion() const {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISCITYREGION__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isCityRegion();
	}
}

bool ActiveArea::isSpawnArea() const {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISSPAWNAREA__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isSpawnArea();
	}
}

bool ActiveArea::isNoSpawnArea() const {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISNOSPAWNAREA__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isNoSpawnArea();
	}
}

bool ActiveArea::isWorldSpawnArea() const {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISWORLDSPAWNAREA__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isWorldSpawnArea();
	}
}

bool ActiveArea::isNoWorldSpawnArea() const {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISNOWORLDSPAWNAREA__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isNoWorldSpawnArea();
	}
}

bool ActiveArea::isNoBuildZone() const {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISNOBUILDZONE__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isNoBuildZone();
	}
}

bool ActiveArea::isCampingArea() const {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISCAMPINGAREA__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isCampingArea();
	}
}

bool ActiveArea::shouldBuildNavmesh() const {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SHOULDBUILDNAVMESH__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->shouldBuildNavmesh();
	}
}

bool ActiveArea::isNamedRegion() const {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISNAMEDREGION__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isNamedRegion();
	}
}

bool ActiveArea::isLockedArea() const {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISLOCKEDAREA__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isLockedArea();
	}
}

bool ActiveArea::isPvpArea() const {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISPVPAREA__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isPvpArea();
	}
}

bool ActiveArea::isOvertOnlyArea() const {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISOVERTONLYAREA__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isOvertOnlyArea();
	}
}

bool ActiveArea::isRebelOnlyArea() const {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISREBELONLYAREA__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isRebelOnlyArea();
	}
}

bool ActiveArea::isImperialOnlyArea() const {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISIMPERIALONLYAREA__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isImperialOnlyArea();
	}
}

bool ActiveArea::isNoCombatArea() const {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISNOCOMBATAREA__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isNoCombatArea();
	}
}

bool ActiveArea::isNoPetArea() const {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISNOPETAREA__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isNoPetArea();
	}
}

bool ActiveArea::isRectangularAreaShape() const {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISRECTANGULARAREASHAPE__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isRectangularAreaShape();
	}
}

void ActiveArea::addAreaFlag(unsigned int flag) {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDAREAFLAG__INT_);
		method.addUnsignedIntParameter(flag);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->addAreaFlag(flag);
	}
}

void ActiveArea::removeAreaFlag(unsigned int flag) {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEAREAFLAG__INT_);
		method.addUnsignedIntParameter(flag);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->removeAreaFlag(flag);
	}
}

void ActiveArea::setRadius(float r) {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETRADIUS__FLOAT_);
		method.addFloatParameter(r);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setRadius(r);
	}
}

void ActiveArea::setPvpArea(bool val) {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETPVPAREA__BOOL_);
		method.addBooleanParameter(val);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setPvpArea(val);
	}
}

void ActiveArea::setOvertOnlyArea(bool val) {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETOVERTONLYAREA__BOOL_);
		method.addBooleanParameter(val);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setOvertOnlyArea(val);
	}
}

void ActiveArea::setRebelOnlyArea(bool val) {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETREBELONLYAREA__BOOL_);
		method.addBooleanParameter(val);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setRebelOnlyArea(val);
	}
}

void ActiveArea::setImperialOnlyArea(bool val) {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETIMPERIALONLYAREA__BOOL_);
		method.addBooleanParameter(val);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setImperialOnlyArea(val);
	}
}

void ActiveArea::setNoCombatArea(bool val) {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETNOCOMBATAREA__BOOL_);
		method.addBooleanParameter(val);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setNoCombatArea(val);
	}
}

void ActiveArea::setNoPetArea(bool val) {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETNOPETAREA__BOOL_);
		method.addBooleanParameter(val);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setNoPetArea(val);
	}
}

void ActiveArea::setLockedArea(bool val) {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETLOCKEDAREA__BOOL_);
		method.addBooleanParameter(val);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setLockedArea(val);
	}
}

void ActiveArea::setCellObjectID(unsigned long long celloid) {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCELLOBJECTID__LONG_);
		method.addUnsignedLongParameter(celloid);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setCellObjectID(celloid);
	}
}

void ActiveArea::setAreaShape(AreaShape* area) {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETAREASHAPE__AREASHAPE_);
		method.addObjectParameter(area);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->setAreaShape(area);
	}
}

int ActiveArea::getAreaFlags() const {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETAREAFLAGS__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getAreaFlags();
	}
}

Vector3 ActiveArea::getAreaCenter() const {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getAreaCenter();
	}
}

float ActiveArea::getRadius2() const {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETRADIUS2__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getRadius2();
	}
}

float ActiveArea::getRadius() const {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETRADIUS__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getRadius();
	}
}

float ActiveArea::getHeight() const {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETHEIGHT__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getHeight();
	}
}

float ActiveArea::getWidth() const {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETWIDTH__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getWidth();
	}
}

Vector4 ActiveArea::getRectangularDimensions() const {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getRectangularDimensions();
	}
}

unsigned long long ActiveArea::getCellObjectID() const {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCELLOBJECTID__);

		return method.executeWithUnsignedLongReturn();
	} else {
		return _implementation->getCellObjectID();
	}
}

AreaShape* ActiveArea::getAreaShape() const {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETAREASHAPE__);

		return static_cast<AreaShape*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getAreaShape();
	}
}

String ActiveArea::getAreaName() const {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETAREANAME__);

		String _return_getAreaName;
		method.executeWithAsciiReturn(_return_getAreaName);
		return _return_getAreaName;
	} else {
		return _implementation->getAreaName();
	}
}

void ActiveArea::attachScenery(SceneObject* scene) {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ATTACHSCENERY__SCENEOBJECT_);
		method.addObjectParameter(scene);

		method.executeWithVoidReturn();
	} else {
		assert(this->isLockedByCurrentThread());
		_implementation->attachScenery(scene);
	}
}

void ActiveArea::initializeChildObject(SceneObject* controllerObject) {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INITIALIZECHILDOBJECT__SCENEOBJECT_);
		method.addObjectParameter(controllerObject);

		method.executeWithVoidReturn();
	} else {
		_implementation->initializeChildObject(controllerObject);
	}
}

bool ActiveArea::ejectFromArea(SceneObject* object) {
	ActiveAreaImplementation* _implementation = static_cast<ActiveAreaImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->ejectFromArea(object);
	}
}

DistributedObjectServant* ActiveArea::_getImplementation() {

	 if (!_updated) _updated = true;
	return _impl;
}

DistributedObjectServant* ActiveArea::_getImplementationForRead() const {
	return _impl;
}

void ActiveArea::_setImplementation(DistributedObjectServant* servant) {
	_impl = servant;
}

/*
 *	ActiveAreaImplementation
 */

ActiveAreaImplementation::ActiveAreaImplementation(DummyConstructorParameter* param) : SceneObjectImplementation(param) {
	_initializeImplementation();
}


ActiveAreaImplementation::~ActiveAreaImplementation() {
}


void ActiveAreaImplementation::finalize() {
}

void ActiveAreaImplementation::_initializeImplementation() {
	_setClassHelper(ActiveAreaHelper::instance());

	_this = NULL;

	_serializationHelperMethod();
}

void ActiveAreaImplementation::_setStub(DistributedObjectStub* stub) {
	_this = static_cast<ActiveArea*>(stub);
	SceneObjectImplementation::_setStub(stub);
}

DistributedObjectStub* ActiveAreaImplementation::_getStub() {
	return _this.get();
}

ActiveAreaImplementation::operator const ActiveArea*() {
	return _this.get();
}

void ActiveAreaImplementation::lock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->lock(doLock);
}

void ActiveAreaImplementation::lock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->lock(obj);
}

void ActiveAreaImplementation::rlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->rlock(doLock);
}

void ActiveAreaImplementation::wlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->wlock(doLock);
}

void ActiveAreaImplementation::wlock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->wlock(obj);
}

void ActiveAreaImplementation::unlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->unlock(doLock);
}

void ActiveAreaImplementation::runlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->runlock(doLock);
}

void ActiveAreaImplementation::_serializationHelperMethod() {
	SceneObjectImplementation::_serializationHelperMethod();

	_setClassName("ActiveArea");

}

void ActiveAreaImplementation::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(ActiveAreaImplementation::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

	initializeTransientMembers();
}

bool ActiveAreaImplementation::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (SceneObjectImplementation::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0x1d1bd89e: //ActiveArea.cellObjectID
		TypeInfo<unsigned long long >::parseFromBinaryStream(&cellObjectID, stream);
		return true;

	case 0x2588bd57: //ActiveArea.pvpArea
		TypeInfo<bool >::parseFromBinaryStream(&pvpArea, stream);
		return true;

	case 0x20162d1b: //ActiveArea.overtOnlyArea
		TypeInfo<bool >::parseFromBinaryStream(&overtOnlyArea, stream);
		return true;

	case 0x2fcb28e6: //ActiveArea.rebelOnlyArea
		TypeInfo<bool >::parseFromBinaryStream(&rebelOnlyArea, stream);
		return true;

	case 0x29f32369: //ActiveArea.imperialOnlyArea
		TypeInfo<bool >::parseFromBinaryStream(&imperialOnlyArea, stream);
		return true;

	case 0x2f13263b: //ActiveArea.noCombatArea
		TypeInfo<bool >::parseFromBinaryStream(&noCombatArea, stream);
		return true;

	case 0x829d6cd7: //ActiveArea.noPetArea
		TypeInfo<bool >::parseFromBinaryStream(&noPetArea, stream);
		return true;

	case 0x1bb3704b: //ActiveArea.areaShape
		TypeInfo<ManagedReference<AreaShape* > >::parseFromBinaryStream(&areaShape, stream);
		return true;

	case 0xfc64a5e7: //ActiveArea.areaFlags
		TypeInfo<unsigned int >::parseFromBinaryStream(&areaFlags, stream);
		return true;

	case 0x50693d74: //ActiveArea.areaName
		TypeInfo<String >::parseFromBinaryStream(&areaName, stream);
		return true;

	}

	return false;
}

void ActiveAreaImplementation::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = ActiveAreaImplementation::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int ActiveAreaImplementation::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = SceneObjectImplementation::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	_nameHashCode = 0x1d1bd89e; //ActiveArea.cellObjectID
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&cellObjectID, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x2588bd57; //ActiveArea.pvpArea
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&pvpArea, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x20162d1b; //ActiveArea.overtOnlyArea
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&overtOnlyArea, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x2fcb28e6; //ActiveArea.rebelOnlyArea
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&rebelOnlyArea, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x29f32369; //ActiveArea.imperialOnlyArea
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&imperialOnlyArea, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x2f13263b; //ActiveArea.noCombatArea
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&noCombatArea, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x829d6cd7; //ActiveArea.noPetArea
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&noPetArea, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x1bb3704b; //ActiveArea.areaShape
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedReference<AreaShape* > >::toBinaryStream(&areaShape, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xfc64a5e7; //ActiveArea.areaFlags
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned int >::toBinaryStream(&areaFlags, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x50693d74; //ActiveArea.areaName
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&areaName, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;


	return _count;
}

void ActiveAreaImplementation::writeJSON(nlohmann::json& j) {
	SceneObjectImplementation::writeJSON(j);

	nlohmann::json thisObject = nlohmann::json::object();
	thisObject["cellObjectID"] = cellObjectID;

	thisObject["pvpArea"] = pvpArea;

	thisObject["overtOnlyArea"] = overtOnlyArea;

	thisObject["rebelOnlyArea"] = rebelOnlyArea;

	thisObject["imperialOnlyArea"] = imperialOnlyArea;

	thisObject["noCombatArea"] = noCombatArea;

	thisObject["noPetArea"] = noPetArea;

	thisObject["areaShape"] = areaShape;

	thisObject["areaFlags"] = areaFlags;

	thisObject["areaName"] = areaName;

	j["ActiveArea"] = thisObject;
}

ActiveAreaImplementation::ActiveAreaImplementation() {
	_initializeImplementation();
	// server/zone/objects/area/ActiveArea.idl():  		cellObjectID = 0;
	cellObjectID = 0;
	// server/zone/objects/area/ActiveArea.idl():  		pvpArea = false;
	pvpArea = false;
	// server/zone/objects/area/ActiveArea.idl():  		overtOnlyArea = false;
	overtOnlyArea = false;
	// server/zone/objects/area/ActiveArea.idl():  		rebelOnlyArea = false;
	rebelOnlyArea = false;
	// server/zone/objects/area/ActiveArea.idl():  		imperialOnlyArea = false;
	imperialOnlyArea = false;
	// server/zone/objects/area/ActiveArea.idl():  		noCombatArea = false;
	noCombatArea = false;
	// server/zone/objects/area/ActiveArea.idl():  		noPetArea = false;
	noPetArea = false;
	// server/zone/objects/area/ActiveArea.idl():  		areaShape = null;
	areaShape = NULL;
	// server/zone/objects/area/ActiveArea.idl():  		areaName = "";
	areaName = "";
	// server/zone/objects/area/ActiveArea.idl():  		areaFlags = 0;
	areaFlags = 0;
	// server/zone/objects/area/ActiveArea.idl():  		Logger.setLoggingName("ActiveArea");
	Logger::setLoggingName("ActiveArea");
}

void ActiveAreaImplementation::sendTo(SceneObject* player, bool doClose, bool forceLoadContainer) {
}

NavArea* ActiveAreaImplementation::asNavArea() {
	// server/zone/objects/area/ActiveArea.idl():  		return null;
	return NULL;
}

Region* ActiveAreaImplementation::asRegion() {
	// server/zone/objects/area/ActiveArea.idl():  		return null;
	return NULL;
}

void ActiveAreaImplementation::setRegionFlags(unsigned int flags) {
	// server/zone/objects/area/ActiveArea.idl():  		areaFlags = flags;
	areaFlags = flags;
}

void ActiveAreaImplementation::setAreaName(const String& name) {
	// server/zone/objects/area/ActiveArea.idl():  		areaName = name;
	areaName = name;
}

bool ActiveAreaImplementation::isActiveArea() {
	// server/zone/objects/area/ActiveArea.idl():  		return true;
	return true;
}

bool ActiveAreaImplementation::isRegion() {
	// server/zone/objects/area/ActiveArea.idl():  		return false;
	return false;
}

bool ActiveAreaImplementation::isNavArea() const{
	// server/zone/objects/area/ActiveArea.idl():  		return false;
	return false;
}

bool ActiveAreaImplementation::isCampArea() {
	// server/zone/objects/area/ActiveArea.idl():  		return false;
	return false;
}

bool ActiveAreaImplementation::isUndefinedRegion() const{
	// server/zone/objects/area/ActiveArea.idl():  		return areaFlags & UNDEFINEDAREA;
	return areaFlags & UNDEFINEDAREA;
}

bool ActiveAreaImplementation::isCityRegion() const{
	// server/zone/objects/area/ActiveArea.idl():  		return areaFlags & CITY;
	return areaFlags & CITY;
}

bool ActiveAreaImplementation::isSpawnArea() const{
	// server/zone/objects/area/ActiveArea.idl():  		return areaFlags & SPAWNAREA;
	return areaFlags & SPAWNAREA;
}

bool ActiveAreaImplementation::isNoSpawnArea() const{
	// server/zone/objects/area/ActiveArea.idl():  		return areaFlags & NOSPAWNAREA;
	return areaFlags & NOSPAWNAREA;
}

bool ActiveAreaImplementation::isWorldSpawnArea() const{
	// server/zone/objects/area/ActiveArea.idl():  		return areaFlags & WORLDSPAWNAREA;
	return areaFlags & WORLDSPAWNAREA;
}

bool ActiveAreaImplementation::isNoWorldSpawnArea() const{
	// server/zone/objects/area/ActiveArea.idl():  		return areaFlags & NOWORLDSPAWNAREA;
	return areaFlags & NOWORLDSPAWNAREA;
}

bool ActiveAreaImplementation::isNoBuildZone() const{
	// server/zone/objects/area/ActiveArea.idl():  		return areaFlags & NOBUILDZONEAREA;
	return areaFlags & NOBUILDZONEAREA;
}

bool ActiveAreaImplementation::isCampingArea() const{
	// server/zone/objects/area/ActiveArea.idl():  		return areaFlags & CAMPINGAREA;
	return areaFlags & CAMPINGAREA;
}

bool ActiveAreaImplementation::shouldBuildNavmesh() const{
	// server/zone/objects/area/ActiveArea.idl():  		return areaFlags & NAVAREA;
	return areaFlags & NAVAREA;
}

bool ActiveAreaImplementation::isNamedRegion() const{
	// server/zone/objects/area/ActiveArea.idl():  		return areaFlags & NAMEDREGION;
	return areaFlags & NAMEDREGION;
}

bool ActiveAreaImplementation::isLockedArea() const{
	// server/zone/objects/area/ActiveArea.idl():  		return areaFlags & LOCKEDAREA;
	return areaFlags & LOCKEDAREA;
}

bool ActiveAreaImplementation::isPvpArea() const{
	// server/zone/objects/area/ActiveArea.idl():  		return pvpArea;
	return pvpArea;
}

bool ActiveAreaImplementation::isOvertOnlyArea() const{
	// server/zone/objects/area/ActiveArea.idl():  		return overtOnlyArea;
	return overtOnlyArea;
}

bool ActiveAreaImplementation::isRebelOnlyArea() const{
	// server/zone/objects/area/ActiveArea.idl():  		return rebelOnlyArea;
	return rebelOnlyArea;
}

bool ActiveAreaImplementation::isImperialOnlyArea() const{
	// server/zone/objects/area/ActiveArea.idl():  		return imperialOnlyArea;
	return imperialOnlyArea;
}

bool ActiveAreaImplementation::isNoCombatArea() const{
	// server/zone/objects/area/ActiveArea.idl():  		return noCombatArea;
	return noCombatArea;
}

bool ActiveAreaImplementation::isNoPetArea() const{
	// server/zone/objects/area/ActiveArea.idl():  		return noPetArea;
	return noPetArea;
}

bool ActiveAreaImplementation::isRectangularAreaShape() const{
	// server/zone/objects/area/ActiveArea.idl():  		return areaShape && areaShape.isRectangularAreaShape();
	return areaShape && areaShape->isRectangularAreaShape();
}

void ActiveAreaImplementation::setRadius(float r) {
	// server/zone/objects/area/ActiveArea.idl():  		super.
	if (areaShape && r < areaShape->getRadius()){
	// server/zone/objects/area/ActiveArea.idl():  			r = areaShape.getRadius();
	r = areaShape->getRadius();
}
	// server/zone/objects/area/ActiveArea.idl():  		super.setRadius(r);
	SceneObjectImplementation::setRadius(r);
}

void ActiveAreaImplementation::setPvpArea(bool val) {
	// server/zone/objects/area/ActiveArea.idl():  		pvpArea = val;
	pvpArea = val;
}

void ActiveAreaImplementation::setOvertOnlyArea(bool val) {
	// server/zone/objects/area/ActiveArea.idl():  		overtOnlyArea = val;
	overtOnlyArea = val;
}

void ActiveAreaImplementation::setRebelOnlyArea(bool val) {
	// server/zone/objects/area/ActiveArea.idl():  		rebelOnlyArea = val;
	rebelOnlyArea = val;
}

void ActiveAreaImplementation::setImperialOnlyArea(bool val) {
	// server/zone/objects/area/ActiveArea.idl():  		imperialOnlyArea = val;
	imperialOnlyArea = val;
}

void ActiveAreaImplementation::setNoCombatArea(bool val) {
	// server/zone/objects/area/ActiveArea.idl():  		noCombatArea = val;
	noCombatArea = val;
}

void ActiveAreaImplementation::setNoPetArea(bool val) {
	// server/zone/objects/area/ActiveArea.idl():  		noPetArea = val;
	noPetArea = val;
}

void ActiveAreaImplementation::setLockedArea(bool val) {
	// server/zone/objects/area/ActiveArea.idl():  		}
	if (val){
	// server/zone/objects/area/ActiveArea.idl():  			addAreaFlag(LOCKEDAREA);
	addAreaFlag(LOCKEDAREA);
}

	else {
	// server/zone/objects/area/ActiveArea.idl():  			removeAreaFlag(LOCKEDAREA);
	removeAreaFlag(LOCKEDAREA);
}
}

void ActiveAreaImplementation::setCellObjectID(unsigned long long celloid) {
	// server/zone/objects/area/ActiveArea.idl():  		cellObjectID = celloid;
	cellObjectID = celloid;
}

void ActiveAreaImplementation::setAreaShape(AreaShape* area) {
	// server/zone/objects/area/ActiveArea.idl():  		areaShape = area;
	areaShape = area;
	// server/zone/objects/area/ActiveArea.idl():  	}
	if (areaShape){
	// server/zone/objects/area/ActiveArea.idl():  			setRadius(areaShape.getRadius());
	setRadius(areaShape->getRadius());
}
}

int ActiveAreaImplementation::getAreaFlags() const{
	// server/zone/objects/area/ActiveArea.idl():  		return areaFlags;
	return areaFlags;
}

float ActiveAreaImplementation::getRadius2() const{
	// server/zone/objects/area/ActiveArea.idl():  		float radius = getRadius();
	float radius = getRadius();
	// server/zone/objects/area/ActiveArea.idl():  		return radius * radius;
	return radius * radius;
}

float ActiveAreaImplementation::getRadius() const{
	// server/zone/objects/area/ActiveArea.idl():  		}
	if (areaShape){
	// server/zone/objects/area/ActiveArea.idl():  			return areaShape.getRadius();
	return areaShape->getRadius();
}

	else {
	// server/zone/objects/area/ActiveArea.idl():  			return super.getRadius();
	return SceneObjectImplementation::getRadius();
}
}

unsigned long long ActiveAreaImplementation::getCellObjectID() const{
	// server/zone/objects/area/ActiveArea.idl():  		return cellObjectID;
	return cellObjectID;
}

AreaShape* ActiveAreaImplementation::getAreaShape() const{
	// server/zone/objects/area/ActiveArea.idl():  		return areaShape;
	return areaShape;
}

String ActiveAreaImplementation::getAreaName() const{
	// server/zone/objects/area/ActiveArea.idl():  		return areaName;
	return areaName;
}

void ActiveAreaImplementation::attachScenery(SceneObject* scene) {
	// server/zone/objects/area/ActiveArea.idl():  		attachedScenery.add(scene);
	(&attachedScenery)->add(scene);
}

/*
 *	ActiveAreaAdapter
 */


#include "engine/orb/messages/InvokeMethodMessage.h"


ActiveAreaAdapter::ActiveAreaAdapter(ActiveArea* obj) : SceneObjectAdapter(obj) {
}

void ActiveAreaAdapter::invokeMethod(uint32 methid, DistributedMethod* inv) {
	DOBMessage* resp = inv->getInvocationMessage();

	switch (methid) {
	case RPC_SENDTO__SCENEOBJECT_BOOL_BOOL_:
		{
			SceneObject* player = static_cast<SceneObject*>(inv->getObjectParameter());
			bool doClose = inv->getBooleanParameter();
			bool forceLoadContainer = inv->getBooleanParameter();
			
			sendTo(player, doClose, forceLoadContainer);
			
		}
		break;
	case RPC_ENQUEUEENTEREVENT__SCENEOBJECT_:
		{
			SceneObject* obj = static_cast<SceneObject*>(inv->getObjectParameter());
			
			enqueueEnterEvent(obj);
			
		}
		break;
	case RPC_ENQUEUEEXITEVENT__SCENEOBJECT_:
		{
			SceneObject* obj = static_cast<SceneObject*>(inv->getObjectParameter());
			
			enqueueExitEvent(obj);
			
		}
		break;
	case RPC_NOTIFYENTER__SCENEOBJECT_:
		{
			SceneObject* object = static_cast<SceneObject*>(inv->getObjectParameter());
			
			notifyEnter(object);
			
		}
		break;
	case RPC_NOTIFYEXIT__SCENEOBJECT_:
		{
			SceneObject* object = static_cast<SceneObject*>(inv->getObjectParameter());
			
			notifyExit(object);
			
		}
		break;
	case RPC_SENDDEBUGMESSAGE__SCENEOBJECT_BOOL_:
		{
			SceneObject* creature = static_cast<SceneObject*>(inv->getObjectParameter());
			bool entry = inv->getBooleanParameter();
			
			sendDebugMessage(creature, entry);
			
		}
		break;
	case RPC_SETZONE__ZONE_:
		{
			Zone* zone = static_cast<Zone*>(inv->getObjectParameter());
			
			setZone(zone);
			
		}
		break;
	case RPC_CONTAINSPOINT__FLOAT_FLOAT_LONG_:
		{
			float x = inv->getFloatParameter();
			float y = inv->getFloatParameter();
			unsigned long long cellid = inv->getUnsignedLongParameter();
			
			bool _m_res = containsPoint(x, y, cellid);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_CONTAINSPOINT__FLOAT_FLOAT_:
		{
			float x = inv->getFloatParameter();
			float y = inv->getFloatParameter();
			
			bool _m_res = containsPoint(x, y);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_INTERSECTSWITH__ACTIVEAREA_:
		{
			ActiveArea* area = static_cast<ActiveArea*>(inv->getObjectParameter());
			
			bool _m_res = intersectsWith(area);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETREGIONFLAGS__INT_:
		{
			unsigned int flags = inv->getUnsignedIntParameter();
			
			setRegionFlags(flags);
			
		}
		break;
	case RPC_SETAREANAME__STRING_:
		{
			 String name; inv->getAsciiParameter(name);
			
			setAreaName(name);
			
		}
		break;
	case RPC_ISACTIVEAREA__:
		{
			
			bool _m_res = isActiveArea();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISREGION__:
		{
			
			bool _m_res = isRegion();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISNAVAREA__:
		{
			
			bool _m_res = isNavArea();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISCAMPAREA__:
		{
			
			bool _m_res = isCampArea();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISUNDEFINEDREGION__:
		{
			
			bool _m_res = isUndefinedRegion();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISCITYREGION__:
		{
			
			bool _m_res = isCityRegion();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISSPAWNAREA__:
		{
			
			bool _m_res = isSpawnArea();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISNOSPAWNAREA__:
		{
			
			bool _m_res = isNoSpawnArea();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISWORLDSPAWNAREA__:
		{
			
			bool _m_res = isWorldSpawnArea();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISNOWORLDSPAWNAREA__:
		{
			
			bool _m_res = isNoWorldSpawnArea();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISNOBUILDZONE__:
		{
			
			bool _m_res = isNoBuildZone();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISCAMPINGAREA__:
		{
			
			bool _m_res = isCampingArea();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SHOULDBUILDNAVMESH__:
		{
			
			bool _m_res = shouldBuildNavmesh();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISNAMEDREGION__:
		{
			
			bool _m_res = isNamedRegion();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISLOCKEDAREA__:
		{
			
			bool _m_res = isLockedArea();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISPVPAREA__:
		{
			
			bool _m_res = isPvpArea();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISOVERTONLYAREA__:
		{
			
			bool _m_res = isOvertOnlyArea();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISREBELONLYAREA__:
		{
			
			bool _m_res = isRebelOnlyArea();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISIMPERIALONLYAREA__:
		{
			
			bool _m_res = isImperialOnlyArea();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISNOCOMBATAREA__:
		{
			
			bool _m_res = isNoCombatArea();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISNOPETAREA__:
		{
			
			bool _m_res = isNoPetArea();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISRECTANGULARAREASHAPE__:
		{
			
			bool _m_res = isRectangularAreaShape();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ADDAREAFLAG__INT_:
		{
			unsigned int flag = inv->getUnsignedIntParameter();
			
			addAreaFlag(flag);
			
		}
		break;
	case RPC_REMOVEAREAFLAG__INT_:
		{
			unsigned int flag = inv->getUnsignedIntParameter();
			
			removeAreaFlag(flag);
			
		}
		break;
	case RPC_SETRADIUS__FLOAT_:
		{
			float r = inv->getFloatParameter();
			
			setRadius(r);
			
		}
		break;
	case RPC_SETPVPAREA__BOOL_:
		{
			bool val = inv->getBooleanParameter();
			
			setPvpArea(val);
			
		}
		break;
	case RPC_SETOVERTONLYAREA__BOOL_:
		{
			bool val = inv->getBooleanParameter();
			
			setOvertOnlyArea(val);
			
		}
		break;
	case RPC_SETREBELONLYAREA__BOOL_:
		{
			bool val = inv->getBooleanParameter();
			
			setRebelOnlyArea(val);
			
		}
		break;
	case RPC_SETIMPERIALONLYAREA__BOOL_:
		{
			bool val = inv->getBooleanParameter();
			
			setImperialOnlyArea(val);
			
		}
		break;
	case RPC_SETNOCOMBATAREA__BOOL_:
		{
			bool val = inv->getBooleanParameter();
			
			setNoCombatArea(val);
			
		}
		break;
	case RPC_SETNOPETAREA__BOOL_:
		{
			bool val = inv->getBooleanParameter();
			
			setNoPetArea(val);
			
		}
		break;
	case RPC_SETLOCKEDAREA__BOOL_:
		{
			bool val = inv->getBooleanParameter();
			
			setLockedArea(val);
			
		}
		break;
	case RPC_SETCELLOBJECTID__LONG_:
		{
			unsigned long long celloid = inv->getUnsignedLongParameter();
			
			setCellObjectID(celloid);
			
		}
		break;
	case RPC_SETAREASHAPE__AREASHAPE_:
		{
			AreaShape* area = static_cast<AreaShape*>(inv->getObjectParameter());
			
			setAreaShape(area);
			
		}
		break;
	case RPC_GETAREAFLAGS__:
		{
			
			int _m_res = getAreaFlags();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETRADIUS2__:
		{
			
			float _m_res = getRadius2();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETRADIUS__:
		{
			
			float _m_res = getRadius();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETHEIGHT__:
		{
			
			float _m_res = getHeight();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETWIDTH__:
		{
			
			float _m_res = getWidth();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_GETCELLOBJECTID__:
		{
			
			unsigned long long _m_res = getCellObjectID();
			resp->insertLong(_m_res);
		}
		break;
	case RPC_GETAREASHAPE__:
		{
			
			DistributedObject* _m_res = getAreaShape();
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_GETAREANAME__:
		{
			
			String _m_res = getAreaName();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_ATTACHSCENERY__SCENEOBJECT_:
		{
			SceneObject* scene = static_cast<SceneObject*>(inv->getObjectParameter());
			
			attachScenery(scene);
			
		}
		break;
	case RPC_INITIALIZECHILDOBJECT__SCENEOBJECT_:
		{
			SceneObject* controllerObject = static_cast<SceneObject*>(inv->getObjectParameter());
			
			initializeChildObject(controllerObject);
			
		}
		break;
	default:
		SceneObjectAdapter::invokeMethod(methid, inv);
	}
}

void ActiveAreaAdapter::sendTo(SceneObject* player, bool doClose, bool forceLoadContainer) {
	(static_cast<ActiveArea*>(stub))->sendTo(player, doClose, forceLoadContainer);
}

void ActiveAreaAdapter::enqueueEnterEvent(SceneObject* obj) {
	(static_cast<ActiveArea*>(stub))->enqueueEnterEvent(obj);
}

void ActiveAreaAdapter::enqueueExitEvent(SceneObject* obj) {
	(static_cast<ActiveArea*>(stub))->enqueueExitEvent(obj);
}

void ActiveAreaAdapter::notifyEnter(SceneObject* object) {
	(static_cast<ActiveArea*>(stub))->notifyEnter(object);
}

void ActiveAreaAdapter::notifyExit(SceneObject* object) {
	(static_cast<ActiveArea*>(stub))->notifyExit(object);
}

void ActiveAreaAdapter::sendDebugMessage(SceneObject* creature, bool entry) {
	(static_cast<ActiveArea*>(stub))->sendDebugMessage(creature, entry);
}

void ActiveAreaAdapter::setZone(Zone* zone) {
	(static_cast<ActiveArea*>(stub))->setZone(zone);
}

bool ActiveAreaAdapter::containsPoint(float x, float y, unsigned long long cellid) const {
	return (static_cast<ActiveArea*>(stub))->containsPoint(x, y, cellid);
}

bool ActiveAreaAdapter::containsPoint(float x, float y) const {
	return (static_cast<ActiveArea*>(stub))->containsPoint(x, y);
}

bool ActiveAreaAdapter::intersectsWith(ActiveArea* area) const {
	return (static_cast<ActiveArea*>(stub))->intersectsWith(area);
}

void ActiveAreaAdapter::setRegionFlags(unsigned int flags) {
	(static_cast<ActiveArea*>(stub))->setRegionFlags(flags);
}

void ActiveAreaAdapter::setAreaName(const String& name) {
	(static_cast<ActiveArea*>(stub))->setAreaName(name);
}

bool ActiveAreaAdapter::isActiveArea() {
	return (static_cast<ActiveArea*>(stub))->isActiveArea();
}

bool ActiveAreaAdapter::isRegion() {
	return (static_cast<ActiveArea*>(stub))->isRegion();
}

bool ActiveAreaAdapter::isNavArea() const {
	return (static_cast<ActiveArea*>(stub))->isNavArea();
}

bool ActiveAreaAdapter::isCampArea() {
	return (static_cast<ActiveArea*>(stub))->isCampArea();
}

bool ActiveAreaAdapter::isUndefinedRegion() const {
	return (static_cast<ActiveArea*>(stub))->isUndefinedRegion();
}

bool ActiveAreaAdapter::isCityRegion() const {
	return (static_cast<ActiveArea*>(stub))->isCityRegion();
}

bool ActiveAreaAdapter::isSpawnArea() const {
	return (static_cast<ActiveArea*>(stub))->isSpawnArea();
}

bool ActiveAreaAdapter::isNoSpawnArea() const {
	return (static_cast<ActiveArea*>(stub))->isNoSpawnArea();
}

bool ActiveAreaAdapter::isWorldSpawnArea() const {
	return (static_cast<ActiveArea*>(stub))->isWorldSpawnArea();
}

bool ActiveAreaAdapter::isNoWorldSpawnArea() const {
	return (static_cast<ActiveArea*>(stub))->isNoWorldSpawnArea();
}

bool ActiveAreaAdapter::isNoBuildZone() const {
	return (static_cast<ActiveArea*>(stub))->isNoBuildZone();
}

bool ActiveAreaAdapter::isCampingArea() const {
	return (static_cast<ActiveArea*>(stub))->isCampingArea();
}

bool ActiveAreaAdapter::shouldBuildNavmesh() const {
	return (static_cast<ActiveArea*>(stub))->shouldBuildNavmesh();
}

bool ActiveAreaAdapter::isNamedRegion() const {
	return (static_cast<ActiveArea*>(stub))->isNamedRegion();
}

bool ActiveAreaAdapter::isLockedArea() const {
	return (static_cast<ActiveArea*>(stub))->isLockedArea();
}

bool ActiveAreaAdapter::isPvpArea() const {
	return (static_cast<ActiveArea*>(stub))->isPvpArea();
}

bool ActiveAreaAdapter::isOvertOnlyArea() const {
	return (static_cast<ActiveArea*>(stub))->isOvertOnlyArea();
}

bool ActiveAreaAdapter::isRebelOnlyArea() const {
	return (static_cast<ActiveArea*>(stub))->isRebelOnlyArea();
}

bool ActiveAreaAdapter::isImperialOnlyArea() const {
	return (static_cast<ActiveArea*>(stub))->isImperialOnlyArea();
}

bool ActiveAreaAdapter::isNoCombatArea() const {
	return (static_cast<ActiveArea*>(stub))->isNoCombatArea();
}

bool ActiveAreaAdapter::isNoPetArea() const {
	return (static_cast<ActiveArea*>(stub))->isNoPetArea();
}

bool ActiveAreaAdapter::isRectangularAreaShape() const {
	return (static_cast<ActiveArea*>(stub))->isRectangularAreaShape();
}

void ActiveAreaAdapter::addAreaFlag(unsigned int flag) {
	(static_cast<ActiveArea*>(stub))->addAreaFlag(flag);
}

void ActiveAreaAdapter::removeAreaFlag(unsigned int flag) {
	(static_cast<ActiveArea*>(stub))->removeAreaFlag(flag);
}

void ActiveAreaAdapter::setRadius(float r) {
	(static_cast<ActiveArea*>(stub))->setRadius(r);
}

void ActiveAreaAdapter::setPvpArea(bool val) {
	(static_cast<ActiveArea*>(stub))->setPvpArea(val);
}

void ActiveAreaAdapter::setOvertOnlyArea(bool val) {
	(static_cast<ActiveArea*>(stub))->setOvertOnlyArea(val);
}

void ActiveAreaAdapter::setRebelOnlyArea(bool val) {
	(static_cast<ActiveArea*>(stub))->setRebelOnlyArea(val);
}

void ActiveAreaAdapter::setImperialOnlyArea(bool val) {
	(static_cast<ActiveArea*>(stub))->setImperialOnlyArea(val);
}

void ActiveAreaAdapter::setNoCombatArea(bool val) {
	(static_cast<ActiveArea*>(stub))->setNoCombatArea(val);
}

void ActiveAreaAdapter::setNoPetArea(bool val) {
	(static_cast<ActiveArea*>(stub))->setNoPetArea(val);
}

void ActiveAreaAdapter::setLockedArea(bool val) {
	(static_cast<ActiveArea*>(stub))->setLockedArea(val);
}

void ActiveAreaAdapter::setCellObjectID(unsigned long long celloid) {
	(static_cast<ActiveArea*>(stub))->setCellObjectID(celloid);
}

void ActiveAreaAdapter::setAreaShape(AreaShape* area) {
	(static_cast<ActiveArea*>(stub))->setAreaShape(area);
}

int ActiveAreaAdapter::getAreaFlags() const {
	return (static_cast<ActiveArea*>(stub))->getAreaFlags();
}

float ActiveAreaAdapter::getRadius2() const {
	return (static_cast<ActiveArea*>(stub))->getRadius2();
}

float ActiveAreaAdapter::getRadius() const {
	return (static_cast<ActiveArea*>(stub))->getRadius();
}

float ActiveAreaAdapter::getHeight() const {
	return (static_cast<ActiveArea*>(stub))->getHeight();
}

float ActiveAreaAdapter::getWidth() const {
	return (static_cast<ActiveArea*>(stub))->getWidth();
}

unsigned long long ActiveAreaAdapter::getCellObjectID() const {
	return (static_cast<ActiveArea*>(stub))->getCellObjectID();
}

AreaShape* ActiveAreaAdapter::getAreaShape() const {
	return (static_cast<ActiveArea*>(stub))->getAreaShape();
}

String ActiveAreaAdapter::getAreaName() const {
	return (static_cast<ActiveArea*>(stub))->getAreaName();
}

void ActiveAreaAdapter::attachScenery(SceneObject* scene) {
	(static_cast<ActiveArea*>(stub))->attachScenery(scene);
}

void ActiveAreaAdapter::initializeChildObject(SceneObject* controllerObject) {
	(static_cast<ActiveArea*>(stub))->initializeChildObject(controllerObject);
}

/*
 *	ActiveAreaHelper
 */

ActiveAreaHelper* ActiveAreaHelper::staticInitializer = ActiveAreaHelper::instance();

ActiveAreaHelper::ActiveAreaHelper() {
	className = "ActiveArea";

	Core::getObjectBroker()->registerClass(className, this);
}

void ActiveAreaHelper::finalizeHelper() {
	ActiveAreaHelper::finalize();
}

DistributedObject* ActiveAreaHelper::instantiateObject() {
	return new ActiveArea(DummyConstructorParameter::instance());
}

DistributedObjectServant* ActiveAreaHelper::instantiateServant() {
	return new ActiveAreaImplementation();
}

DistributedObjectPOD* ActiveAreaHelper::instantiatePOD() {
	return new ActiveAreaPOD();
}

DistributedObjectAdapter* ActiveAreaHelper::createAdapter(DistributedObjectStub* obj) {
	DistributedObjectAdapter* adapter = new ActiveAreaAdapter(static_cast<ActiveArea*>(obj));

	obj->_setClassName(className);
	obj->_setClassHelper(this);

	adapter->setStub(obj);

	return adapter;
}

/*
 *	ActiveAreaPOD
 */

ActiveAreaPOD::~ActiveAreaPOD() {
	finalize();
}

ActiveAreaPOD::ActiveAreaPOD(void) {
	_className = "ActiveArea";
}


void ActiveAreaPOD::writeJSON(nlohmann::json& j) {
	SceneObjectPOD::writeJSON(j);

	nlohmann::json thisObject = nlohmann::json::object();
	if (cellObjectID)
		thisObject["cellObjectID"] = cellObjectID.value();

	if (pvpArea)
		thisObject["pvpArea"] = pvpArea.value();

	if (overtOnlyArea)
		thisObject["overtOnlyArea"] = overtOnlyArea.value();

	if (rebelOnlyArea)
		thisObject["rebelOnlyArea"] = rebelOnlyArea.value();

	if (imperialOnlyArea)
		thisObject["imperialOnlyArea"] = imperialOnlyArea.value();

	if (noCombatArea)
		thisObject["noCombatArea"] = noCombatArea.value();

	if (noPetArea)
		thisObject["noPetArea"] = noPetArea.value();

	if (areaShape)
		thisObject["areaShape"] = areaShape.value();

	if (areaFlags)
		thisObject["areaFlags"] = areaFlags.value();

	if (areaName)
		thisObject["areaName"] = areaName.value();

	j["ActiveArea"] = thisObject;
}


void ActiveAreaPOD::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = ActiveAreaPOD::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int ActiveAreaPOD::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = SceneObjectPOD::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	if (cellObjectID) {
	_nameHashCode = 0x1d1bd89e; //ActiveArea.cellObjectID
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&cellObjectID.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (pvpArea) {
	_nameHashCode = 0x2588bd57; //ActiveArea.pvpArea
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&pvpArea.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (overtOnlyArea) {
	_nameHashCode = 0x20162d1b; //ActiveArea.overtOnlyArea
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&overtOnlyArea.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (rebelOnlyArea) {
	_nameHashCode = 0x2fcb28e6; //ActiveArea.rebelOnlyArea
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&rebelOnlyArea.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (imperialOnlyArea) {
	_nameHashCode = 0x29f32369; //ActiveArea.imperialOnlyArea
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&imperialOnlyArea.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (noCombatArea) {
	_nameHashCode = 0x2f13263b; //ActiveArea.noCombatArea
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&noCombatArea.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (noPetArea) {
	_nameHashCode = 0x829d6cd7; //ActiveArea.noPetArea
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&noPetArea.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (areaShape) {
	_nameHashCode = 0x1bb3704b; //ActiveArea.areaShape
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedReference<AreaShapePOD* > >::toBinaryStream(&areaShape.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (areaFlags) {
	_nameHashCode = 0xfc64a5e7; //ActiveArea.areaFlags
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned int >::toBinaryStream(&areaFlags.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (areaName) {
	_nameHashCode = 0x50693d74; //ActiveArea.areaName
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&areaName.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}


	return _count;
}

bool ActiveAreaPOD::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (SceneObjectPOD::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0x1d1bd89e: //ActiveArea.cellObjectID
		{
			unsigned long long _mncellObjectID;
			TypeInfo<unsigned long long >::parseFromBinaryStream(&_mncellObjectID, stream);
			cellObjectID = std::move(_mncellObjectID);
		}
		return true;

	case 0x2588bd57: //ActiveArea.pvpArea
		{
			bool _mnpvpArea;
			TypeInfo<bool >::parseFromBinaryStream(&_mnpvpArea, stream);
			pvpArea = std::move(_mnpvpArea);
		}
		return true;

	case 0x20162d1b: //ActiveArea.overtOnlyArea
		{
			bool _mnovertOnlyArea;
			TypeInfo<bool >::parseFromBinaryStream(&_mnovertOnlyArea, stream);
			overtOnlyArea = std::move(_mnovertOnlyArea);
		}
		return true;

	case 0x2fcb28e6: //ActiveArea.rebelOnlyArea
		{
			bool _mnrebelOnlyArea;
			TypeInfo<bool >::parseFromBinaryStream(&_mnrebelOnlyArea, stream);
			rebelOnlyArea = std::move(_mnrebelOnlyArea);
		}
		return true;

	case 0x29f32369: //ActiveArea.imperialOnlyArea
		{
			bool _mnimperialOnlyArea;
			TypeInfo<bool >::parseFromBinaryStream(&_mnimperialOnlyArea, stream);
			imperialOnlyArea = std::move(_mnimperialOnlyArea);
		}
		return true;

	case 0x2f13263b: //ActiveArea.noCombatArea
		{
			bool _mnnoCombatArea;
			TypeInfo<bool >::parseFromBinaryStream(&_mnnoCombatArea, stream);
			noCombatArea = std::move(_mnnoCombatArea);
		}
		return true;

	case 0x829d6cd7: //ActiveArea.noPetArea
		{
			bool _mnnoPetArea;
			TypeInfo<bool >::parseFromBinaryStream(&_mnnoPetArea, stream);
			noPetArea = std::move(_mnnoPetArea);
		}
		return true;

	case 0x1bb3704b: //ActiveArea.areaShape
		{
			ManagedReference<AreaShapePOD* > _mnareaShape;
			TypeInfo<ManagedReference<AreaShapePOD* > >::parseFromBinaryStream(&_mnareaShape, stream);
			areaShape = std::move(_mnareaShape);
		}
		return true;

	case 0xfc64a5e7: //ActiveArea.areaFlags
		{
			unsigned int _mnareaFlags;
			TypeInfo<unsigned int >::parseFromBinaryStream(&_mnareaFlags, stream);
			areaFlags = std::move(_mnareaFlags);
		}
		return true;

	case 0x50693d74: //ActiveArea.areaName
		{
			String _mnareaName;
			TypeInfo<String >::parseFromBinaryStream(&_mnareaName, stream);
			areaName = std::move(_mnareaName);
		}
		return true;

	}

	return false;
}

void ActiveAreaPOD::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(ActiveAreaPOD::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

}

void ActiveAreaPOD::writeObjectCompact(ObjectOutputStream* stream) {
	SceneObjectPOD::writeObjectCompact(stream);

	TypeInfo<unsigned long long >::toBinaryStream(&cellObjectID.value(), stream);

	TypeInfo<bool >::toBinaryStream(&pvpArea.value(), stream);

	TypeInfo<bool >::toBinaryStream(&overtOnlyArea.value(), stream);

	TypeInfo<bool >::toBinaryStream(&rebelOnlyArea.value(), stream);

	TypeInfo<bool >::toBinaryStream(&imperialOnlyArea.value(), stream);

	TypeInfo<bool >::toBinaryStream(&noCombatArea.value(), stream);

	TypeInfo<bool >::toBinaryStream(&noPetArea.value(), stream);

	TypeInfo<ManagedReference<AreaShapePOD* > >::toBinaryStream(&areaShape.value(), stream);

	TypeInfo<unsigned int >::toBinaryStream(&areaFlags.value(), stream);

	TypeInfo<String >::toBinaryStream(&areaName.value(), stream);


}

