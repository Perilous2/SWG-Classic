/*
 *	autogen/server/zone/objects/player/sessions/EntertainingSession.cpp generated by engine3 IDL compiler 0.70
 */

#include "EntertainingSession.h"

#include "server/zone/objects/creature/CreatureObject.h"

#include "server/zone/objects/tangible/Instrument.h"

#include "server/zone/objects/player/events/EntertainingSessionTask.h"

#include "server/zone/objects/player/EntertainingObserver.h"

/*
 *	EntertainingSessionStub
 */

enum {RPC_DOENTERTAINERPATRONEFFECTS__ = 2018339486,RPC_DOPERFORMANCEACTION__,RPC_ADDENTERTAINERFLOURISHBUFF__,RPC_STARTDANCING__INT_,RPC_STARTPLAYINGMUSIC__INT_INSTRUMENT_,RPC_JOINBAND__,RPC_STARTENTERTAINING__,RPC_FINALIZE__,RPC_HEALWOUNDS__CREATUREOBJECT_FLOAT_FLOAT_,RPC_ISINENTERTAININGBUILDING__CREATUREOBJECT_,RPC_DOFLOURISH__INT_BOOL_,RPC_CANHEALBATTLEFATIGUE__,RPC_CANGIVEENTERTAINBUFF__,RPC_ADDFLOURISHXP__INT_,RPC_ADDHEALINGXP__INT_,RPC_ADDHEALINGXPGROUP__INT_,RPC_INITIALIZESESSION__,RPC_CANCELSESSION__,RPC_CLEARSESSION__,RPC_STOPPLAYING__,RPC_STOPMUSIC__BOOL_BOOL_BOOL_,RPC_CLEAROUTRO__BOOL_BOOL_,RPC_STOPDANCING__,RPC_ACTIVATEACTION__,RPC_STARTTICKTASK__,RPC_GETENTERTAINERBUFFSTRENGTH__CREATUREOBJECT_INT_,RPC_GETENTERTAINERBUFFDURATION__CREATUREOBJECT_INT_,RPC_GETENTERTAINERBUFFSTARTTIME__CREATUREOBJECT_INT_,RPC_SENDENTERTAININGUPDATE__CREATUREOBJECT_INT_BOOL_,RPC_SENDENTERTAINMENTUPDATE__CREATUREOBJECT_LONG_STRING_,RPC_ACTIVATEENTERTAINERBUFF__CREATUREOBJECT_INT_,RPC_GETPERFORMANCENAME__,RPC_ADDPATRON__CREATUREOBJECT_,RPC_REMOVEPATRON__CREATUREOBJECT_,RPC_ISDANCING__,RPC_ISPLAYINGMUSIC__,RPC_ISACCEPTINGBANDFLOURISHES__,RPC_SETACCEPTINGBANDFLOURISHES__BOOL_,RPC_DOPERFORMEFFECT__INT_INT_,RPC_UPDATEENTERTAINERMISSIONSTATUS__BOOL_INT_,RPC_ISINDENYSERVICELIST__CREATUREOBJECT_,RPC_ADDTODENYSERVICELIST__CREATUREOBJECT_,RPC_REMOVEFROMDENYSERVICELIST__CREATUREOBJECT_,RPC_INCREASEENTERTAINERBUFF__CREATUREOBJECT_,RPC_AWARDENTERTAINEREXPERIENCE__,RPC_GETAUDIENCESIZE__,RPC_GETBANDAUDIENCESIZE__,RPC_INCREMENTAPPLAUSECOUNT__,RPC_GETAPPLAUSECOUNT__,RPC_GETPERFORMANCEINDEX__,RPC_ISPERFORMINGOUTRO__,RPC_SETPERFORMINGOUTRO__BOOL_};

EntertainingSession::EntertainingSession(CreatureObject* ent) : Facade(DummyConstructorParameter::instance()) {
	EntertainingSessionImplementation* _implementation = new EntertainingSessionImplementation(ent);
	_impl = _implementation;
	_impl->_setStub(this);
	_setClassName("EntertainingSession");
}

EntertainingSession::EntertainingSession(DummyConstructorParameter* param) : Facade(param) {
	_setClassName("EntertainingSession");
}

EntertainingSession::~EntertainingSession() {
}



void EntertainingSession::doEntertainerPatronEffects() {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DOENTERTAINERPATRONEFFECTS__);

		method.executeWithVoidReturn();
	} else {
		_implementation->doEntertainerPatronEffects();
	}
}

void EntertainingSession::doPerformanceAction() {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DOPERFORMANCEACTION__);

		method.executeWithVoidReturn();
	} else {
		_implementation->doPerformanceAction();
	}
}

void EntertainingSession::addEntertainerFlourishBuff() {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDENTERTAINERFLOURISHBUFF__);

		method.executeWithVoidReturn();
	} else {
		_implementation->addEntertainerFlourishBuff();
	}
}

void EntertainingSession::startDancing(int perfIndex) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_STARTDANCING__INT_);
		method.addSignedIntParameter(perfIndex);

		method.executeWithVoidReturn();
	} else {
		_implementation->startDancing(perfIndex);
	}
}

void EntertainingSession::startPlayingMusic(int perfIndex, Instrument* instrument) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_STARTPLAYINGMUSIC__INT_INSTRUMENT_);
		method.addSignedIntParameter(perfIndex);
		method.addObjectParameter(instrument);

		method.executeWithVoidReturn();
	} else {
		_implementation->startPlayingMusic(perfIndex, instrument);
	}
}

void EntertainingSession::joinBand() {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_JOINBAND__);

		method.executeWithVoidReturn();
	} else {
		_implementation->joinBand();
	}
}

void EntertainingSession::startEntertaining() {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_STARTENTERTAINING__);

		method.executeWithVoidReturn();
	} else {
		_implementation->startEntertaining();
	}
}

void EntertainingSession::healWounds(CreatureObject* creature, float woundHeal, float shockHeal) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HEALWOUNDS__CREATUREOBJECT_FLOAT_FLOAT_);
		method.addObjectParameter(creature);
		method.addFloatParameter(woundHeal);
		method.addFloatParameter(shockHeal);

		method.executeWithVoidReturn();
	} else {
		_implementation->healWounds(creature, woundHeal, shockHeal);
	}
}

bool EntertainingSession::isInEntertainingBuilding(CreatureObject* creature) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISINENTERTAININGBUILDING__CREATUREOBJECT_);
		method.addObjectParameter(creature);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isInEntertainingBuilding(creature);
	}
}

void EntertainingSession::doFlourish(int flourishNumber, bool grantXp) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DOFLOURISH__INT_BOOL_);
		method.addSignedIntParameter(flourishNumber);
		method.addBooleanParameter(grantXp);

		method.executeWithVoidReturn();
	} else {
		_implementation->doFlourish(flourishNumber, grantXp);
	}
}

bool EntertainingSession::canHealBattleFatigue() {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CANHEALBATTLEFATIGUE__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->canHealBattleFatigue();
	}
}

bool EntertainingSession::canGiveEntertainBuff() {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CANGIVEENTERTAINBUFF__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->canGiveEntertainBuff();
	}
}

void EntertainingSession::addFlourishXp(int xp) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDFLOURISHXP__INT_);
		method.addSignedIntParameter(xp);

		method.executeWithVoidReturn();
	} else {
		_implementation->addFlourishXp(xp);
	}
}

void EntertainingSession::addHealingXp(int xp) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDHEALINGXP__INT_);
		method.addSignedIntParameter(xp);

		method.executeWithVoidReturn();
	} else {
		_implementation->addHealingXp(xp);
	}
}

void EntertainingSession::addHealingXpGroup(int xp) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDHEALINGXPGROUP__INT_);
		method.addSignedIntParameter(xp);

		method.executeWithVoidReturn();
	} else {
		_implementation->addHealingXpGroup(xp);
	}
}

int EntertainingSession::initializeSession() {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INITIALIZESESSION__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->initializeSession();
	}
}

int EntertainingSession::cancelSession() {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CANCELSESSION__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->cancelSession();
	}
}

int EntertainingSession::clearSession() {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARSESSION__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->clearSession();
	}
}

void EntertainingSession::stopPlaying() {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_STOPPLAYING__);

		method.executeWithVoidReturn();
	} else {
		_implementation->stopPlaying();
	}
}

void EntertainingSession::stopMusic(bool skipOutro, bool bandStop, bool isBandLeader) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_STOPMUSIC__BOOL_BOOL_BOOL_);
		method.addBooleanParameter(skipOutro);
		method.addBooleanParameter(bandStop);
		method.addBooleanParameter(isBandLeader);

		method.executeWithVoidReturn();
	} else {
		_implementation->stopMusic(skipOutro, bandStop, isBandLeader);
	}
}

void EntertainingSession::clearOutro(bool bandStop, bool isBandLeader) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEAROUTRO__BOOL_BOOL_);
		method.addBooleanParameter(bandStop);
		method.addBooleanParameter(isBandLeader);

		method.executeWithVoidReturn();
	} else {
		_implementation->clearOutro(bandStop, isBandLeader);
	}
}

void EntertainingSession::stopDancing() {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_STOPDANCING__);

		method.executeWithVoidReturn();
	} else {
		_implementation->stopDancing();
	}
}

void EntertainingSession::activateAction() {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ACTIVATEACTION__);

		method.executeWithVoidReturn();
	} else {
		_implementation->activateAction();
	}
}

void EntertainingSession::startTickTask() {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_STARTTICKTASK__);

		method.executeWithVoidReturn();
	} else {
		_implementation->startTickTask();
	}
}

void EntertainingSession::addEntertainerBuffDuration(CreatureObject* creature, int performanceType, float duration) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->addEntertainerBuffDuration(creature, performanceType, duration);
	}
}

void EntertainingSession::addEntertainerBuffStrength(CreatureObject* creature, int performanceType, float strength) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->addEntertainerBuffStrength(creature, performanceType, strength);
	}
}

void EntertainingSession::setEntertainerBuffDuration(CreatureObject* creature, int performanceType, float duration) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->setEntertainerBuffDuration(creature, performanceType, duration);
	}
}

void EntertainingSession::setEntertainerBuffStrength(CreatureObject* creature, int performanceType, float strength) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->setEntertainerBuffStrength(creature, performanceType, strength);
	}
}

int EntertainingSession::getEntertainerBuffStrength(CreatureObject* creature, int performanceType) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETENTERTAINERBUFFSTRENGTH__CREATUREOBJECT_INT_);
		method.addObjectParameter(creature);
		method.addSignedIntParameter(performanceType);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getEntertainerBuffStrength(creature, performanceType);
	}
}

int EntertainingSession::getEntertainerBuffDuration(CreatureObject* creature, int performanceType) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETENTERTAINERBUFFDURATION__CREATUREOBJECT_INT_);
		method.addObjectParameter(creature);
		method.addSignedIntParameter(performanceType);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getEntertainerBuffDuration(creature, performanceType);
	}
}

int EntertainingSession::getEntertainerBuffStartTime(CreatureObject* creature, int performanceType) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETENTERTAINERBUFFSTARTTIME__CREATUREOBJECT_INT_);
		method.addObjectParameter(creature);
		method.addSignedIntParameter(performanceType);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getEntertainerBuffStartTime(creature, performanceType);
	}
}

void EntertainingSession::sendEntertainingUpdate(CreatureObject* creature, int performanceType, bool startPerformance) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDENTERTAININGUPDATE__CREATUREOBJECT_INT_BOOL_);
		method.addObjectParameter(creature);
		method.addSignedIntParameter(performanceType);
		method.addBooleanParameter(startPerformance);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendEntertainingUpdate(creature, performanceType, startPerformance);
	}
}

void EntertainingSession::sendEntertainmentUpdate(CreatureObject* creature, unsigned long long entid, const String& mood) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDENTERTAINMENTUPDATE__CREATUREOBJECT_LONG_STRING_);
		method.addObjectParameter(creature);
		method.addUnsignedLongParameter(entid);
		method.addAsciiParameter(mood);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendEntertainmentUpdate(creature, entid, mood);
	}
}

void EntertainingSession::activateEntertainerBuff(CreatureObject* creature, int performanceType) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ACTIVATEENTERTAINERBUFF__CREATUREOBJECT_INT_);
		method.addObjectParameter(creature);
		method.addSignedIntParameter(performanceType);

		method.executeWithVoidReturn();
	} else {
		_implementation->activateEntertainerBuff(creature, performanceType);
	}
}

String EntertainingSession::getPerformanceName() {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETPERFORMANCENAME__);

		String _return_getPerformanceName;
		method.executeWithAsciiReturn(_return_getPerformanceName);
		return _return_getPerformanceName;
	} else {
		return _implementation->getPerformanceName();
	}
}

void EntertainingSession::addPatron(CreatureObject* creature) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDPATRON__CREATUREOBJECT_);
		method.addObjectParameter(creature);

		method.executeWithVoidReturn();
	} else {
		_implementation->addPatron(creature);
	}
}

void EntertainingSession::removePatron(CreatureObject* creature) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEPATRON__CREATUREOBJECT_);
		method.addObjectParameter(creature);

		method.executeWithVoidReturn();
	} else {
		_implementation->removePatron(creature);
	}
}

bool EntertainingSession::isDancing() {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISDANCING__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isDancing();
	}
}

bool EntertainingSession::isPlayingMusic() {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISPLAYINGMUSIC__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isPlayingMusic();
	}
}

bool EntertainingSession::isAcceptingBandFlourishes() {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISACCEPTINGBANDFLOURISHES__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isAcceptingBandFlourishes();
	}
}

void EntertainingSession::setAcceptingBandFlourishes(bool val) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETACCEPTINGBANDFLOURISHES__BOOL_);
		method.addBooleanParameter(val);

		method.executeWithVoidReturn();
	} else {
		_implementation->setAcceptingBandFlourishes(val);
	}
}

void EntertainingSession::doPerformEffect(int effectId, int effectLevel) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DOPERFORMEFFECT__INT_INT_);
		method.addSignedIntParameter(effectId);
		method.addSignedIntParameter(effectLevel);

		method.executeWithVoidReturn();
	} else {
		_implementation->doPerformEffect(effectId, effectLevel);
	}
}

void EntertainingSession::updateEntertainerMissionStatus(bool entertaining, const int missionType) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATEENTERTAINERMISSIONSTATUS__BOOL_INT_);
		method.addBooleanParameter(entertaining);
		method.addSignedIntParameter(missionType);

		method.executeWithVoidReturn();
	} else {
		_implementation->updateEntertainerMissionStatus(entertaining, missionType);
	}
}

bool EntertainingSession::isInDenyServiceList(CreatureObject* target) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISINDENYSERVICELIST__CREATUREOBJECT_);
		method.addObjectParameter(target);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isInDenyServiceList(target);
	}
}

void EntertainingSession::addToDenyServiceList(CreatureObject* target) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDTODENYSERVICELIST__CREATUREOBJECT_);
		method.addObjectParameter(target);

		method.executeWithVoidReturn();
	} else {
		_implementation->addToDenyServiceList(target);
	}
}

void EntertainingSession::removeFromDenyServiceList(CreatureObject* target) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEFROMDENYSERVICELIST__CREATUREOBJECT_);
		method.addObjectParameter(target);

		method.executeWithVoidReturn();
	} else {
		_implementation->removeFromDenyServiceList(target);
	}
}

void EntertainingSession::increaseEntertainerBuff(CreatureObject* patron) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INCREASEENTERTAINERBUFF__CREATUREOBJECT_);
		method.addObjectParameter(patron);

		method.executeWithVoidReturn();
	} else {
		_implementation->increaseEntertainerBuff(patron);
	}
}

void EntertainingSession::awardEntertainerExperience() {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_AWARDENTERTAINEREXPERIENCE__);

		method.executeWithVoidReturn();
	} else {
		_implementation->awardEntertainerExperience();
	}
}

SortedVector<ManagedReference<CreatureObject* > > EntertainingSession::getPatrons() {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getPatrons();
	}
}

int EntertainingSession::getAudienceSize() {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETAUDIENCESIZE__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getAudienceSize();
	}
}

int EntertainingSession::getBandAudienceSize() {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETBANDAUDIENCESIZE__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getBandAudienceSize();
	}
}

void EntertainingSession::incrementApplauseCount() {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INCREMENTAPPLAUSECOUNT__);

		method.executeWithVoidReturn();
	} else {
		_implementation->incrementApplauseCount();
	}
}

int EntertainingSession::getApplauseCount() {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETAPPLAUSECOUNT__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getApplauseCount();
	}
}

int EntertainingSession::getPerformanceIndex() {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETPERFORMANCEINDEX__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getPerformanceIndex();
	}
}

bool EntertainingSession::isPerformingOutro() {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISPERFORMINGOUTRO__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isPerformingOutro();
	}
}

void EntertainingSession::setPerformingOutro(bool val) {
	EntertainingSessionImplementation* _implementation = static_cast<EntertainingSessionImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETPERFORMINGOUTRO__BOOL_);
		method.addBooleanParameter(val);

		method.executeWithVoidReturn();
	} else {
		_implementation->setPerformingOutro(val);
	}
}

DistributedObjectServant* EntertainingSession::_getImplementation() {

	 if (!_updated) _updated = true;
	return _impl;
}

DistributedObjectServant* EntertainingSession::_getImplementationForRead() const {
	return _impl;
}

void EntertainingSession::_setImplementation(DistributedObjectServant* servant) {
	_impl = servant;
}

/*
 *	EntertainingSessionImplementation
 */

EntertainingSessionImplementation::EntertainingSessionImplementation(DummyConstructorParameter* param) : FacadeImplementation(param) {
	_initializeImplementation();
}


EntertainingSessionImplementation::~EntertainingSessionImplementation() {
	EntertainingSessionImplementation::finalize();
}


void EntertainingSessionImplementation::_initializeImplementation() {
	_setClassHelper(EntertainingSessionHelper::instance());

	_this = NULL;

	_serializationHelperMethod();
}

void EntertainingSessionImplementation::_setStub(DistributedObjectStub* stub) {
	_this = static_cast<EntertainingSession*>(stub);
	FacadeImplementation::_setStub(stub);
}

DistributedObjectStub* EntertainingSessionImplementation::_getStub() {
	return _this.get();
}

EntertainingSessionImplementation::operator const EntertainingSession*() {
	return _this.get();
}

void EntertainingSessionImplementation::lock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->lock(doLock);
}

void EntertainingSessionImplementation::lock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->lock(obj);
}

void EntertainingSessionImplementation::rlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->rlock(doLock);
}

void EntertainingSessionImplementation::wlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->wlock(doLock);
}

void EntertainingSessionImplementation::wlock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->wlock(obj);
}

void EntertainingSessionImplementation::unlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->unlock(doLock);
}

void EntertainingSessionImplementation::runlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->runlock(doLock);
}

void EntertainingSessionImplementation::_serializationHelperMethod() {
	FacadeImplementation::_serializationHelperMethod();

	_setClassName("EntertainingSession");

}

void EntertainingSessionImplementation::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(EntertainingSessionImplementation::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

	initializeTransientMembers();
}

bool EntertainingSessionImplementation::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (FacadeImplementation::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0x98639124: //EntertainingSession.entertainer
		TypeInfo<ManagedWeakReference<CreatureObject* > >::parseFromBinaryStream(&entertainer, stream);
		return true;

	case 0x561d7ab2: //EntertainingSession.observer
		TypeInfo<ManagedReference<EntertainingObserver* > >::parseFromBinaryStream(&observer, stream);
		return true;

	case 0xf5544b5b: //EntertainingSession.patronDataMap
		TypeInfo<EntertainingDataMap >::parseFromBinaryStream(&patronDataMap, stream);
		return true;

	case 0x9eb87f03: //EntertainingSession.denyServiceList
		TypeInfo<SortedVector<ManagedReference<CreatureObject* > > >::parseFromBinaryStream(&denyServiceList, stream);
		return true;

	case 0x6c72eb58: //EntertainingSession.nextTick
		TypeInfo<Time >::parseFromBinaryStream(&nextTick, stream);
		return true;

	case 0x12f69543: //EntertainingSession.performanceIndex
		TypeInfo<int >::parseFromBinaryStream(&performanceIndex, stream);
		return true;

	case 0xa0634a3f: //EntertainingSession.flourishXp
		TypeInfo<int >::parseFromBinaryStream(&flourishXp, stream);
		return true;

	case 0x734606a4: //EntertainingSession.oldFlourishXp
		TypeInfo<int >::parseFromBinaryStream(&oldFlourishXp, stream);
		return true;

	case 0xdbc38993: //EntertainingSession.healingXp
		TypeInfo<int >::parseFromBinaryStream(&healingXp, stream);
		return true;

	case 0x84fb2b6: //EntertainingSession.flourishCount
		TypeInfo<int >::parseFromBinaryStream(&flourishCount, stream);
		return true;

	case 0x5e9f0efe: //EntertainingSession.applauseCount
		TypeInfo<int >::parseFromBinaryStream(&applauseCount, stream);
		return true;

	case 0xe2f4031e: //EntertainingSession.acceptingBandFlourishes
		TypeInfo<bool >::parseFromBinaryStream(&acceptingBandFlourishes, stream);
		return true;

	case 0x1b52c69b: //EntertainingSession.performingOutro
		TypeInfo<bool >::parseFromBinaryStream(&performingOutro, stream);
		return true;

	}

	return false;
}

void EntertainingSessionImplementation::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = EntertainingSessionImplementation::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int EntertainingSessionImplementation::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = FacadeImplementation::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	_nameHashCode = 0x98639124; //EntertainingSession.entertainer
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedWeakReference<CreatureObject* > >::toBinaryStream(&entertainer, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x561d7ab2; //EntertainingSession.observer
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedReference<EntertainingObserver* > >::toBinaryStream(&observer, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xf5544b5b; //EntertainingSession.patronDataMap
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<EntertainingDataMap >::toBinaryStream(&patronDataMap, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x9eb87f03; //EntertainingSession.denyServiceList
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<SortedVector<ManagedReference<CreatureObject* > > >::toBinaryStream(&denyServiceList, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x6c72eb58; //EntertainingSession.nextTick
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Time >::toBinaryStream(&nextTick, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x12f69543; //EntertainingSession.performanceIndex
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&performanceIndex, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xa0634a3f; //EntertainingSession.flourishXp
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&flourishXp, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x734606a4; //EntertainingSession.oldFlourishXp
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&oldFlourishXp, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xdbc38993; //EntertainingSession.healingXp
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&healingXp, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x84fb2b6; //EntertainingSession.flourishCount
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&flourishCount, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x5e9f0efe; //EntertainingSession.applauseCount
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&applauseCount, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xe2f4031e; //EntertainingSession.acceptingBandFlourishes
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&acceptingBandFlourishes, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x1b52c69b; //EntertainingSession.performingOutro
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&performingOutro, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;


	return _count;
}

EntertainingSessionImplementation::EntertainingSessionImplementation(CreatureObject* ent) {
	_initializeImplementation();
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		entertainer = ent;
	entertainer = ent;
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		flourishXp = 0;
	flourishXp = 0;
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		oldFlourishXp = 0;
	oldFlourishXp = 0;
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		healingXp = 0;
	healingXp = 0;
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		flourishCount = 0;
	flourishCount = 0;
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		applauseCount = 0;
	applauseCount = 0;
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		performanceIndex = 0;
	performanceIndex = 0;
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		observer = null;
	observer = NULL;
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		acceptingBandFlourishes = true;
	acceptingBandFlourishes = true;
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		performingOutro = false;
	performingOutro = false;
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		Logger.setLoggingName("EntertainingSession");
	Logger::setLoggingName("EntertainingSession");
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		Logger.setLogging(false);
	Logger::setLogging(false);
}

void EntertainingSessionImplementation::finalize() {
}

void EntertainingSessionImplementation::addFlourishXp(int xp) {
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		flourishXp = flourishXp + xp;
	flourishXp = flourishXp + xp;
}

void EntertainingSessionImplementation::addHealingXp(int xp) {
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		healingXp = healingXp + xp;
	healingXp = healingXp + xp;
}

int EntertainingSessionImplementation::initializeSession() {
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		return 0;
	return 0;
}

int EntertainingSessionImplementation::cancelSession() {
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		}
	if (isPlayingMusic()){
	// server/zone/objects/player/sessions/EntertainingSession.idl():  			stopMusic(true);
	stopMusic(true);
}

	else {
	// server/zone/objects/player/sessions/EntertainingSession.idl():  			stopDancing();
	stopDancing();
}
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		return 0;
	return 0;
}

int EntertainingSessionImplementation::clearSession() {
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		return 0;
	return 0;
}

bool EntertainingSessionImplementation::isAcceptingBandFlourishes() {
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		return acceptingBandFlourishes;
	return acceptingBandFlourishes;
}

void EntertainingSessionImplementation::setAcceptingBandFlourishes(bool val) {
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		acceptingBandFlourishes = val;
	acceptingBandFlourishes = val;
}

bool EntertainingSessionImplementation::isInDenyServiceList(CreatureObject* target) {
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		return denyServiceList.contains(target);
	return (&denyServiceList)->contains(target);
}

void EntertainingSessionImplementation::addToDenyServiceList(CreatureObject* target) {
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		denyServiceList.put(target);
	(&denyServiceList)->put(target);
}

void EntertainingSessionImplementation::removeFromDenyServiceList(CreatureObject* target) {
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		denyServiceList.drop(target);
	(&denyServiceList)->drop(target);
}

int EntertainingSessionImplementation::getAudienceSize() {
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		return patronDataMap.size();
	return (&patronDataMap)->size();
}

void EntertainingSessionImplementation::incrementApplauseCount() {
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		applauseCount++;
	applauseCount ++;
}

int EntertainingSessionImplementation::getApplauseCount() {
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		return applauseCount;
	return applauseCount;
}

int EntertainingSessionImplementation::getPerformanceIndex() {
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		return performanceIndex;
	return performanceIndex;
}

bool EntertainingSessionImplementation::isPerformingOutro() {
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		return performingOutro;
	return performingOutro;
}

void EntertainingSessionImplementation::setPerformingOutro(bool val) {
	// server/zone/objects/player/sessions/EntertainingSession.idl():  		performingOutro = val;
	performingOutro = val;
}

/*
 *	EntertainingSessionAdapter
 */


#include "engine/orb/messages/InvokeMethodMessage.h"


EntertainingSessionAdapter::EntertainingSessionAdapter(EntertainingSession* obj) : FacadeAdapter(obj) {
}

void EntertainingSessionAdapter::invokeMethod(uint32 methid, DistributedMethod* inv) {
	DOBMessage* resp = inv->getInvocationMessage();

	switch (methid) {
	case RPC_DOENTERTAINERPATRONEFFECTS__:
		{
			
			doEntertainerPatronEffects();
			
		}
		break;
	case RPC_DOPERFORMANCEACTION__:
		{
			
			doPerformanceAction();
			
		}
		break;
	case RPC_ADDENTERTAINERFLOURISHBUFF__:
		{
			
			addEntertainerFlourishBuff();
			
		}
		break;
	case RPC_STARTDANCING__INT_:
		{
			int perfIndex = inv->getSignedIntParameter();
			
			startDancing(perfIndex);
			
		}
		break;
	case RPC_STARTPLAYINGMUSIC__INT_INSTRUMENT_:
		{
			int perfIndex = inv->getSignedIntParameter();
			Instrument* instrument = static_cast<Instrument*>(inv->getObjectParameter());
			
			startPlayingMusic(perfIndex, instrument);
			
		}
		break;
	case RPC_JOINBAND__:
		{
			
			joinBand();
			
		}
		break;
	case RPC_STARTENTERTAINING__:
		{
			
			startEntertaining();
			
		}
		break;
	case RPC_FINALIZE__:
		{
			
			finalize();
			
		}
		break;
	case RPC_HEALWOUNDS__CREATUREOBJECT_FLOAT_FLOAT_:
		{
			CreatureObject* creature = static_cast<CreatureObject*>(inv->getObjectParameter());
			float woundHeal = inv->getFloatParameter();
			float shockHeal = inv->getFloatParameter();
			
			healWounds(creature, woundHeal, shockHeal);
			
		}
		break;
	case RPC_ISINENTERTAININGBUILDING__CREATUREOBJECT_:
		{
			CreatureObject* creature = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			bool _m_res = isInEntertainingBuilding(creature);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_DOFLOURISH__INT_BOOL_:
		{
			int flourishNumber = inv->getSignedIntParameter();
			bool grantXp = inv->getBooleanParameter();
			
			doFlourish(flourishNumber, grantXp);
			
		}
		break;
	case RPC_CANHEALBATTLEFATIGUE__:
		{
			
			bool _m_res = canHealBattleFatigue();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_CANGIVEENTERTAINBUFF__:
		{
			
			bool _m_res = canGiveEntertainBuff();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ADDFLOURISHXP__INT_:
		{
			int xp = inv->getSignedIntParameter();
			
			addFlourishXp(xp);
			
		}
		break;
	case RPC_ADDHEALINGXP__INT_:
		{
			int xp = inv->getSignedIntParameter();
			
			addHealingXp(xp);
			
		}
		break;
	case RPC_ADDHEALINGXPGROUP__INT_:
		{
			int xp = inv->getSignedIntParameter();
			
			addHealingXpGroup(xp);
			
		}
		break;
	case RPC_INITIALIZESESSION__:
		{
			
			int _m_res = initializeSession();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_CANCELSESSION__:
		{
			
			int _m_res = cancelSession();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_CLEARSESSION__:
		{
			
			int _m_res = clearSession();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_STOPPLAYING__:
		{
			
			stopPlaying();
			
		}
		break;
	case RPC_STOPMUSIC__BOOL_BOOL_BOOL_:
		{
			bool skipOutro = inv->getBooleanParameter();
			bool bandStop = inv->getBooleanParameter();
			bool isBandLeader = inv->getBooleanParameter();
			
			stopMusic(skipOutro, bandStop, isBandLeader);
			
		}
		break;
	case RPC_CLEAROUTRO__BOOL_BOOL_:
		{
			bool bandStop = inv->getBooleanParameter();
			bool isBandLeader = inv->getBooleanParameter();
			
			clearOutro(bandStop, isBandLeader);
			
		}
		break;
	case RPC_STOPDANCING__:
		{
			
			stopDancing();
			
		}
		break;
	case RPC_ACTIVATEACTION__:
		{
			
			activateAction();
			
		}
		break;
	case RPC_STARTTICKTASK__:
		{
			
			startTickTask();
			
		}
		break;
	case RPC_GETENTERTAINERBUFFSTRENGTH__CREATUREOBJECT_INT_:
		{
			CreatureObject* creature = static_cast<CreatureObject*>(inv->getObjectParameter());
			int performanceType = inv->getSignedIntParameter();
			
			int _m_res = getEntertainerBuffStrength(creature, performanceType);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETENTERTAINERBUFFDURATION__CREATUREOBJECT_INT_:
		{
			CreatureObject* creature = static_cast<CreatureObject*>(inv->getObjectParameter());
			int performanceType = inv->getSignedIntParameter();
			
			int _m_res = getEntertainerBuffDuration(creature, performanceType);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETENTERTAINERBUFFSTARTTIME__CREATUREOBJECT_INT_:
		{
			CreatureObject* creature = static_cast<CreatureObject*>(inv->getObjectParameter());
			int performanceType = inv->getSignedIntParameter();
			
			int _m_res = getEntertainerBuffStartTime(creature, performanceType);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_SENDENTERTAININGUPDATE__CREATUREOBJECT_INT_BOOL_:
		{
			CreatureObject* creature = static_cast<CreatureObject*>(inv->getObjectParameter());
			int performanceType = inv->getSignedIntParameter();
			bool startPerformance = inv->getBooleanParameter();
			
			sendEntertainingUpdate(creature, performanceType, startPerformance);
			
		}
		break;
	case RPC_SENDENTERTAINMENTUPDATE__CREATUREOBJECT_LONG_STRING_:
		{
			CreatureObject* creature = static_cast<CreatureObject*>(inv->getObjectParameter());
			unsigned long long entid = inv->getUnsignedLongParameter();
			 String mood; inv->getAsciiParameter(mood);
			
			sendEntertainmentUpdate(creature, entid, mood);
			
		}
		break;
	case RPC_ACTIVATEENTERTAINERBUFF__CREATUREOBJECT_INT_:
		{
			CreatureObject* creature = static_cast<CreatureObject*>(inv->getObjectParameter());
			int performanceType = inv->getSignedIntParameter();
			
			activateEntertainerBuff(creature, performanceType);
			
		}
		break;
	case RPC_GETPERFORMANCENAME__:
		{
			
			String _m_res = getPerformanceName();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_ADDPATRON__CREATUREOBJECT_:
		{
			CreatureObject* creature = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			addPatron(creature);
			
		}
		break;
	case RPC_REMOVEPATRON__CREATUREOBJECT_:
		{
			CreatureObject* creature = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			removePatron(creature);
			
		}
		break;
	case RPC_ISDANCING__:
		{
			
			bool _m_res = isDancing();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISPLAYINGMUSIC__:
		{
			
			bool _m_res = isPlayingMusic();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISACCEPTINGBANDFLOURISHES__:
		{
			
			bool _m_res = isAcceptingBandFlourishes();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETACCEPTINGBANDFLOURISHES__BOOL_:
		{
			bool val = inv->getBooleanParameter();
			
			setAcceptingBandFlourishes(val);
			
		}
		break;
	case RPC_DOPERFORMEFFECT__INT_INT_:
		{
			int effectId = inv->getSignedIntParameter();
			int effectLevel = inv->getSignedIntParameter();
			
			doPerformEffect(effectId, effectLevel);
			
		}
		break;
	case RPC_UPDATEENTERTAINERMISSIONSTATUS__BOOL_INT_:
		{
			bool entertaining = inv->getBooleanParameter();
			 int missionType = inv->getSignedIntParameter();
			
			updateEntertainerMissionStatus(entertaining, missionType);
			
		}
		break;
	case RPC_ISINDENYSERVICELIST__CREATUREOBJECT_:
		{
			CreatureObject* target = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			bool _m_res = isInDenyServiceList(target);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ADDTODENYSERVICELIST__CREATUREOBJECT_:
		{
			CreatureObject* target = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			addToDenyServiceList(target);
			
		}
		break;
	case RPC_REMOVEFROMDENYSERVICELIST__CREATUREOBJECT_:
		{
			CreatureObject* target = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			removeFromDenyServiceList(target);
			
		}
		break;
	case RPC_INCREASEENTERTAINERBUFF__CREATUREOBJECT_:
		{
			CreatureObject* patron = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			increaseEntertainerBuff(patron);
			
		}
		break;
	case RPC_AWARDENTERTAINEREXPERIENCE__:
		{
			
			awardEntertainerExperience();
			
		}
		break;
	case RPC_GETAUDIENCESIZE__:
		{
			
			int _m_res = getAudienceSize();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETBANDAUDIENCESIZE__:
		{
			
			int _m_res = getBandAudienceSize();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_INCREMENTAPPLAUSECOUNT__:
		{
			
			incrementApplauseCount();
			
		}
		break;
	case RPC_GETAPPLAUSECOUNT__:
		{
			
			int _m_res = getApplauseCount();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETPERFORMANCEINDEX__:
		{
			
			int _m_res = getPerformanceIndex();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_ISPERFORMINGOUTRO__:
		{
			
			bool _m_res = isPerformingOutro();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETPERFORMINGOUTRO__BOOL_:
		{
			bool val = inv->getBooleanParameter();
			
			setPerformingOutro(val);
			
		}
		break;
	default:
		FacadeAdapter::invokeMethod(methid, inv);
	}
}

void EntertainingSessionAdapter::doEntertainerPatronEffects() {
	(static_cast<EntertainingSession*>(stub))->doEntertainerPatronEffects();
}

void EntertainingSessionAdapter::doPerformanceAction() {
	(static_cast<EntertainingSession*>(stub))->doPerformanceAction();
}

void EntertainingSessionAdapter::addEntertainerFlourishBuff() {
	(static_cast<EntertainingSession*>(stub))->addEntertainerFlourishBuff();
}

void EntertainingSessionAdapter::startDancing(int perfIndex) {
	(static_cast<EntertainingSession*>(stub))->startDancing(perfIndex);
}

void EntertainingSessionAdapter::startPlayingMusic(int perfIndex, Instrument* instrument) {
	(static_cast<EntertainingSession*>(stub))->startPlayingMusic(perfIndex, instrument);
}

void EntertainingSessionAdapter::joinBand() {
	(static_cast<EntertainingSession*>(stub))->joinBand();
}

void EntertainingSessionAdapter::startEntertaining() {
	(static_cast<EntertainingSession*>(stub))->startEntertaining();
}

void EntertainingSessionAdapter::finalize() {
	(static_cast<EntertainingSession*>(stub))->finalize();
}

void EntertainingSessionAdapter::healWounds(CreatureObject* creature, float woundHeal, float shockHeal) {
	(static_cast<EntertainingSession*>(stub))->healWounds(creature, woundHeal, shockHeal);
}

bool EntertainingSessionAdapter::isInEntertainingBuilding(CreatureObject* creature) {
	return (static_cast<EntertainingSession*>(stub))->isInEntertainingBuilding(creature);
}

void EntertainingSessionAdapter::doFlourish(int flourishNumber, bool grantXp) {
	(static_cast<EntertainingSession*>(stub))->doFlourish(flourishNumber, grantXp);
}

bool EntertainingSessionAdapter::canHealBattleFatigue() {
	return (static_cast<EntertainingSession*>(stub))->canHealBattleFatigue();
}

bool EntertainingSessionAdapter::canGiveEntertainBuff() {
	return (static_cast<EntertainingSession*>(stub))->canGiveEntertainBuff();
}

void EntertainingSessionAdapter::addFlourishXp(int xp) {
	(static_cast<EntertainingSession*>(stub))->addFlourishXp(xp);
}

void EntertainingSessionAdapter::addHealingXp(int xp) {
	(static_cast<EntertainingSession*>(stub))->addHealingXp(xp);
}

void EntertainingSessionAdapter::addHealingXpGroup(int xp) {
	(static_cast<EntertainingSession*>(stub))->addHealingXpGroup(xp);
}

int EntertainingSessionAdapter::initializeSession() {
	return (static_cast<EntertainingSession*>(stub))->initializeSession();
}

int EntertainingSessionAdapter::cancelSession() {
	return (static_cast<EntertainingSession*>(stub))->cancelSession();
}

int EntertainingSessionAdapter::clearSession() {
	return (static_cast<EntertainingSession*>(stub))->clearSession();
}

void EntertainingSessionAdapter::stopPlaying() {
	(static_cast<EntertainingSession*>(stub))->stopPlaying();
}

void EntertainingSessionAdapter::stopMusic(bool skipOutro, bool bandStop, bool isBandLeader) {
	(static_cast<EntertainingSession*>(stub))->stopMusic(skipOutro, bandStop, isBandLeader);
}

void EntertainingSessionAdapter::clearOutro(bool bandStop, bool isBandLeader) {
	(static_cast<EntertainingSession*>(stub))->clearOutro(bandStop, isBandLeader);
}

void EntertainingSessionAdapter::stopDancing() {
	(static_cast<EntertainingSession*>(stub))->stopDancing();
}

void EntertainingSessionAdapter::activateAction() {
	(static_cast<EntertainingSession*>(stub))->activateAction();
}

void EntertainingSessionAdapter::startTickTask() {
	(static_cast<EntertainingSession*>(stub))->startTickTask();
}

int EntertainingSessionAdapter::getEntertainerBuffStrength(CreatureObject* creature, int performanceType) {
	return (static_cast<EntertainingSession*>(stub))->getEntertainerBuffStrength(creature, performanceType);
}

int EntertainingSessionAdapter::getEntertainerBuffDuration(CreatureObject* creature, int performanceType) {
	return (static_cast<EntertainingSession*>(stub))->getEntertainerBuffDuration(creature, performanceType);
}

int EntertainingSessionAdapter::getEntertainerBuffStartTime(CreatureObject* creature, int performanceType) {
	return (static_cast<EntertainingSession*>(stub))->getEntertainerBuffStartTime(creature, performanceType);
}

void EntertainingSessionAdapter::sendEntertainingUpdate(CreatureObject* creature, int performanceType, bool startPerformance) {
	(static_cast<EntertainingSession*>(stub))->sendEntertainingUpdate(creature, performanceType, startPerformance);
}

void EntertainingSessionAdapter::sendEntertainmentUpdate(CreatureObject* creature, unsigned long long entid, const String& mood) {
	(static_cast<EntertainingSession*>(stub))->sendEntertainmentUpdate(creature, entid, mood);
}

void EntertainingSessionAdapter::activateEntertainerBuff(CreatureObject* creature, int performanceType) {
	(static_cast<EntertainingSession*>(stub))->activateEntertainerBuff(creature, performanceType);
}

String EntertainingSessionAdapter::getPerformanceName() {
	return (static_cast<EntertainingSession*>(stub))->getPerformanceName();
}

void EntertainingSessionAdapter::addPatron(CreatureObject* creature) {
	(static_cast<EntertainingSession*>(stub))->addPatron(creature);
}

void EntertainingSessionAdapter::removePatron(CreatureObject* creature) {
	(static_cast<EntertainingSession*>(stub))->removePatron(creature);
}

bool EntertainingSessionAdapter::isDancing() {
	return (static_cast<EntertainingSession*>(stub))->isDancing();
}

bool EntertainingSessionAdapter::isPlayingMusic() {
	return (static_cast<EntertainingSession*>(stub))->isPlayingMusic();
}

bool EntertainingSessionAdapter::isAcceptingBandFlourishes() {
	return (static_cast<EntertainingSession*>(stub))->isAcceptingBandFlourishes();
}

void EntertainingSessionAdapter::setAcceptingBandFlourishes(bool val) {
	(static_cast<EntertainingSession*>(stub))->setAcceptingBandFlourishes(val);
}

void EntertainingSessionAdapter::doPerformEffect(int effectId, int effectLevel) {
	(static_cast<EntertainingSession*>(stub))->doPerformEffect(effectId, effectLevel);
}

void EntertainingSessionAdapter::updateEntertainerMissionStatus(bool entertaining, const int missionType) {
	(static_cast<EntertainingSession*>(stub))->updateEntertainerMissionStatus(entertaining, missionType);
}

bool EntertainingSessionAdapter::isInDenyServiceList(CreatureObject* target) {
	return (static_cast<EntertainingSession*>(stub))->isInDenyServiceList(target);
}

void EntertainingSessionAdapter::addToDenyServiceList(CreatureObject* target) {
	(static_cast<EntertainingSession*>(stub))->addToDenyServiceList(target);
}

void EntertainingSessionAdapter::removeFromDenyServiceList(CreatureObject* target) {
	(static_cast<EntertainingSession*>(stub))->removeFromDenyServiceList(target);
}

void EntertainingSessionAdapter::increaseEntertainerBuff(CreatureObject* patron) {
	(static_cast<EntertainingSession*>(stub))->increaseEntertainerBuff(patron);
}

void EntertainingSessionAdapter::awardEntertainerExperience() {
	(static_cast<EntertainingSession*>(stub))->awardEntertainerExperience();
}

int EntertainingSessionAdapter::getAudienceSize() {
	return (static_cast<EntertainingSession*>(stub))->getAudienceSize();
}

int EntertainingSessionAdapter::getBandAudienceSize() {
	return (static_cast<EntertainingSession*>(stub))->getBandAudienceSize();
}

void EntertainingSessionAdapter::incrementApplauseCount() {
	(static_cast<EntertainingSession*>(stub))->incrementApplauseCount();
}

int EntertainingSessionAdapter::getApplauseCount() {
	return (static_cast<EntertainingSession*>(stub))->getApplauseCount();
}

int EntertainingSessionAdapter::getPerformanceIndex() {
	return (static_cast<EntertainingSession*>(stub))->getPerformanceIndex();
}

bool EntertainingSessionAdapter::isPerformingOutro() {
	return (static_cast<EntertainingSession*>(stub))->isPerformingOutro();
}

void EntertainingSessionAdapter::setPerformingOutro(bool val) {
	(static_cast<EntertainingSession*>(stub))->setPerformingOutro(val);
}

/*
 *	EntertainingSessionHelper
 */

EntertainingSessionHelper* EntertainingSessionHelper::staticInitializer = EntertainingSessionHelper::instance();

EntertainingSessionHelper::EntertainingSessionHelper() {
	className = "EntertainingSession";

	Core::getObjectBroker()->registerClass(className, this);
}

void EntertainingSessionHelper::finalizeHelper() {
	EntertainingSessionHelper::finalize();
}

DistributedObject* EntertainingSessionHelper::instantiateObject() {
	return new EntertainingSession(DummyConstructorParameter::instance());
}

DistributedObjectServant* EntertainingSessionHelper::instantiateServant() {
	return new EntertainingSessionImplementation(DummyConstructorParameter::instance());
}

DistributedObjectPOD* EntertainingSessionHelper::instantiatePOD() {
	return new EntertainingSessionPOD();
}

DistributedObjectAdapter* EntertainingSessionHelper::createAdapter(DistributedObjectStub* obj) {
	DistributedObjectAdapter* adapter = new EntertainingSessionAdapter(static_cast<EntertainingSession*>(obj));

	obj->_setClassName(className);
	obj->_setClassHelper(this);

	adapter->setStub(obj);

	return adapter;
}

/*
 *	EntertainingSessionPOD
 */

EntertainingSessionPOD::~EntertainingSessionPOD() {
	finalize();
}

EntertainingSessionPOD::EntertainingSessionPOD(void) {
	_className = "EntertainingSession";
}


void EntertainingSessionPOD::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = EntertainingSessionPOD::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int EntertainingSessionPOD::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = FacadePOD::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	if (entertainer) {
	_nameHashCode = 0x98639124; //EntertainingSession.entertainer
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedWeakReference<CreatureObjectPOD* > >::toBinaryStream(&entertainer.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (observer) {
	_nameHashCode = 0x561d7ab2; //EntertainingSession.observer
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ManagedReference<EntertainingObserverPOD* > >::toBinaryStream(&observer.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (patronDataMap) {
	_nameHashCode = 0xf5544b5b; //EntertainingSession.patronDataMap
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<EntertainingDataMap >::toBinaryStream(&patronDataMap.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (denyServiceList) {
	_nameHashCode = 0x9eb87f03; //EntertainingSession.denyServiceList
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<SortedVector<ManagedReference<CreatureObjectPOD* > > >::toBinaryStream(&denyServiceList.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (nextTick) {
	_nameHashCode = 0x6c72eb58; //EntertainingSession.nextTick
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Time >::toBinaryStream(&nextTick.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (performanceIndex) {
	_nameHashCode = 0x12f69543; //EntertainingSession.performanceIndex
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&performanceIndex.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (flourishXp) {
	_nameHashCode = 0xa0634a3f; //EntertainingSession.flourishXp
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&flourishXp.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (oldFlourishXp) {
	_nameHashCode = 0x734606a4; //EntertainingSession.oldFlourishXp
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&oldFlourishXp.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (healingXp) {
	_nameHashCode = 0xdbc38993; //EntertainingSession.healingXp
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&healingXp.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (flourishCount) {
	_nameHashCode = 0x84fb2b6; //EntertainingSession.flourishCount
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&flourishCount.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (applauseCount) {
	_nameHashCode = 0x5e9f0efe; //EntertainingSession.applauseCount
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&applauseCount.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (acceptingBandFlourishes) {
	_nameHashCode = 0xe2f4031e; //EntertainingSession.acceptingBandFlourishes
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&acceptingBandFlourishes.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (performingOutro) {
	_nameHashCode = 0x1b52c69b; //EntertainingSession.performingOutro
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&performingOutro.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}


	return _count;
}

bool EntertainingSessionPOD::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (FacadePOD::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0x98639124: //EntertainingSession.entertainer
		{
			ManagedWeakReference<CreatureObjectPOD* > _mnentertainer;
			TypeInfo<ManagedWeakReference<CreatureObjectPOD* > >::parseFromBinaryStream(&_mnentertainer, stream);
			entertainer = std::move(_mnentertainer);
		}
		return true;

	case 0x561d7ab2: //EntertainingSession.observer
		{
			ManagedReference<EntertainingObserverPOD* > _mnobserver;
			TypeInfo<ManagedReference<EntertainingObserverPOD* > >::parseFromBinaryStream(&_mnobserver, stream);
			observer = std::move(_mnobserver);
		}
		return true;

	case 0xf5544b5b: //EntertainingSession.patronDataMap
		{
			EntertainingDataMap _mnpatronDataMap;
			TypeInfo<EntertainingDataMap >::parseFromBinaryStream(&_mnpatronDataMap, stream);
			patronDataMap = std::move(_mnpatronDataMap);
		}
		return true;

	case 0x9eb87f03: //EntertainingSession.denyServiceList
		{
			SortedVector<ManagedReference<CreatureObjectPOD* > > _mndenyServiceList;
			TypeInfo<SortedVector<ManagedReference<CreatureObjectPOD* > > >::parseFromBinaryStream(&_mndenyServiceList, stream);
			denyServiceList = std::move(_mndenyServiceList);
		}
		return true;

	case 0x6c72eb58: //EntertainingSession.nextTick
		{
			Time _mnnextTick;
			TypeInfo<Time >::parseFromBinaryStream(&_mnnextTick, stream);
			nextTick = std::move(_mnnextTick);
		}
		return true;

	case 0x12f69543: //EntertainingSession.performanceIndex
		{
			int _mnperformanceIndex;
			TypeInfo<int >::parseFromBinaryStream(&_mnperformanceIndex, stream);
			performanceIndex = std::move(_mnperformanceIndex);
		}
		return true;

	case 0xa0634a3f: //EntertainingSession.flourishXp
		{
			int _mnflourishXp;
			TypeInfo<int >::parseFromBinaryStream(&_mnflourishXp, stream);
			flourishXp = std::move(_mnflourishXp);
		}
		return true;

	case 0x734606a4: //EntertainingSession.oldFlourishXp
		{
			int _mnoldFlourishXp;
			TypeInfo<int >::parseFromBinaryStream(&_mnoldFlourishXp, stream);
			oldFlourishXp = std::move(_mnoldFlourishXp);
		}
		return true;

	case 0xdbc38993: //EntertainingSession.healingXp
		{
			int _mnhealingXp;
			TypeInfo<int >::parseFromBinaryStream(&_mnhealingXp, stream);
			healingXp = std::move(_mnhealingXp);
		}
		return true;

	case 0x84fb2b6: //EntertainingSession.flourishCount
		{
			int _mnflourishCount;
			TypeInfo<int >::parseFromBinaryStream(&_mnflourishCount, stream);
			flourishCount = std::move(_mnflourishCount);
		}
		return true;

	case 0x5e9f0efe: //EntertainingSession.applauseCount
		{
			int _mnapplauseCount;
			TypeInfo<int >::parseFromBinaryStream(&_mnapplauseCount, stream);
			applauseCount = std::move(_mnapplauseCount);
		}
		return true;

	case 0xe2f4031e: //EntertainingSession.acceptingBandFlourishes
		{
			bool _mnacceptingBandFlourishes;
			TypeInfo<bool >::parseFromBinaryStream(&_mnacceptingBandFlourishes, stream);
			acceptingBandFlourishes = std::move(_mnacceptingBandFlourishes);
		}
		return true;

	case 0x1b52c69b: //EntertainingSession.performingOutro
		{
			bool _mnperformingOutro;
			TypeInfo<bool >::parseFromBinaryStream(&_mnperformingOutro, stream);
			performingOutro = std::move(_mnperformingOutro);
		}
		return true;

	}

	return false;
}

void EntertainingSessionPOD::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(EntertainingSessionPOD::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

}

void EntertainingSessionPOD::writeObjectCompact(ObjectOutputStream* stream) {
	FacadePOD::writeObjectCompact(stream);

	TypeInfo<ManagedWeakReference<CreatureObjectPOD* > >::toBinaryStream(&entertainer.value(), stream);

	TypeInfo<ManagedReference<EntertainingObserverPOD* > >::toBinaryStream(&observer.value(), stream);

	TypeInfo<EntertainingDataMap >::toBinaryStream(&patronDataMap.value(), stream);

	TypeInfo<SortedVector<ManagedReference<CreatureObjectPOD* > > >::toBinaryStream(&denyServiceList.value(), stream);

	TypeInfo<Time >::toBinaryStream(&nextTick.value(), stream);

	TypeInfo<int >::toBinaryStream(&performanceIndex.value(), stream);

	TypeInfo<int >::toBinaryStream(&flourishXp.value(), stream);

	TypeInfo<int >::toBinaryStream(&oldFlourishXp.value(), stream);

	TypeInfo<int >::toBinaryStream(&healingXp.value(), stream);

	TypeInfo<int >::toBinaryStream(&flourishCount.value(), stream);

	TypeInfo<int >::toBinaryStream(&applauseCount.value(), stream);

	TypeInfo<bool >::toBinaryStream(&acceptingBandFlourishes.value(), stream);

	TypeInfo<bool >::toBinaryStream(&performingOutro.value(), stream);


}

