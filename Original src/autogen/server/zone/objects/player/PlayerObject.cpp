/*
 *	autogen/server/zone/objects/player/PlayerObject.cpp generated by engine3 IDL compiler 0.70
 */

#include "PlayerObject.h"

#include "server/zone/objects/building/BuildingObject.h"

#include "server/zone/objects/creature/CreatureObject.h"

#include "server/zone/objects/player/events/PlayerDisconnectEvent.h"

#include "server/zone/objects/player/events/PlayerRecoveryEvent.h"

#include "server/zone/objects/player/events/ForceRegenerationEvent.h"

#include "server/zone/objects/player/events/PvpTefRemovalTask.h"

#include "server/zone/objects/scene/SceneObject.h"

#include "server/zone/objects/structure/StructureObject.h"

#include "server/zone/objects/waypoint/WaypointObject.h"

#include "server/zone/ZoneClientSession.h"

#include "server/login/account/Account.h"

/*
 *	PlayerObjectStub
 */

unsigned const long long PlayerObject::PVP_RESET_TIME = 259200000;

enum {RPC_FINALIZE__ = 594400956,RPC_SETLOGLEVEL__INT_,RPC_GETLOGLEVEL__,RPC_GETCOUNTMAXCOV__,RPC_SETCOUNTMAXCOV__INT_,RPC_SETCLIENTPATHWAYPOINT__SCENEOBJECT_,RPC_INITIALIZEACCOUNT__,RPC_NOTIFYLOADFROMDATABASE__,RPC_UNLOAD__,RPC_CALCULATEBHREWARD__,RPC_INITIALIZETRANSIENTMEMBERS__,RPC_SENDBASELINESTO__SCENEOBJECT_,RPC_ADDOWNEDSTRUCTURE__STRUCTUREOBJECT_,RPC_REMOVEOWNEDSTRUCTURE__STRUCTUREOBJECT_,RPC_GETACCEPTEDTOSVERSION__,RPC_SETACCEPTEDTOSVERSION__INT_,RPC_CHECKANDSHOWTOS__,RPC_CREATEHELPERDROID__,RPC_GETTOTALOWNEDSTRUCTURECOUNT__,RPC_ISOWNEDSTRUCTURE__STRUCTUREOBJECT_,RPC_GETOWNEDSTRUCTURE__INT_,RPC_GETLOTSREMAINING__,RPC_HASLOTSREMAINING__INT_,RPC_NOTIFYSCENEREADY__,RPC_CHECKPENDINGMESSAGES__,RPC_HASCAPPEDEXPERIENCE__STRING_,RPC_ADDWAYPOINT__WAYPOINTOBJECT_BOOL_BOOL_,RPC_SETWAYPOINT__WAYPOINTOBJECT_BOOL_,RPC_REMOVEWAYPOINT__LONG_BOOL_BOOL_,RPC_UPDATEWAYPOINT__LONG_,RPC_REMOVEWAYPOINTBYSPECIALTYPE__INT_BOOL_,RPC_GETWAYPOINTBYSPECIALTYPE__INT_,RPC_GETSURVEYWAYPOINT__,RPC_HASWAYPOINT__LONG_,RPC_GETWAYPOINTAT__FLOAT_FLOAT_STRING_,RPC_GETWAYPOINTLISTSIZE__,RPC_GETWAYPOINT__INT_,RPC_SETLANGUAGEID__BYTE_BOOL_,RPC_ADDFRIEND__STRING_BOOL_,RPC_REMOVEFRIEND__STRING_BOOL_,RPC_REMOVEALLREVERSEFRIENDS__STRING_,RPC_ADDIGNORE__STRING_BOOL_,RPC_REMOVEIGNORE__STRING_BOOL_,RPC_SETTITLE__STRING_BOOL_,RPC_SETFOODFILLING__INT_BOOL_,RPC_SETDRINKFILLING__INT_BOOL_,RPC_INCREASEFACTIONSTANDING__STRING_FLOAT_,RPC_GIVECOABONUS__STRING_FLOAT_FLOAT_,RPC_DECREASEFACTIONSTANDING__STRING_FLOAT_,RPC_SETFACTIONSTANDING__STRING_FLOAT_,RPC_GETFACTIONSTANDING__STRING_,RPC_SETSCREENPLAYDATA__STRING_STRING_STRING_,RPC_DELETESCREENPLAYDATA__STRING_STRING_,RPC_GETSCREENPLAYDATA__STRING_STRING_,RPC_CLEARSCREENPLAYDATA__STRING_,RPC_ACTIVATERECOVERY__,RPC_ACTIVATEFORCEPOWERREGEN__,RPC_DORECOVERY__INT_,RPC_DISCONNECT__BOOL_BOOL_,RPC_RELOAD__ZONECLIENTSESSION_,RPC_SETOFFLINE__,RPC_SETLINKDEAD__BOOL_,RPC_SETONLINE__,RPC_SETLOGGINGOUT__,RPC_ACTIVATEJOURNALQUEST__INT_BOOL_,RPC_COMPLETEJOURNALQUEST__INT_BOOL_,RPC_CLEARJOURNALQUEST__INT_BOOL_,RPC_ACTIVATEJOURNALQUESTTASK__INT_INT_BOOL_,RPC_COMPLETEJOURNALQUESTTASK__INT_INT_BOOL_,RPC_CLEARJOURNALQUESTTASK__INT_INT_BOOL_,RPC_ISJOURNALQUESTACTIVE__INT_,RPC_ISJOURNALQUESTCOMPLETE__INT_,RPC_ISJOURNALQUESTTASKACTIVE__INT_INT_,RPC_ISJOURNALQUESTTASKCOMPLETE__INT_INT_,RPC_SENDBADGESRESPONSETO__CREATUREOBJECT_,RPC_LOGOUT__BOOL_,RPC_SETJEDISTATE__INT_BOOL_,RPC_SETACTIVEQUESTSBIT__INT_BYTE_BOOL_,RPC_CLEARACTIVEQUESTSBIT__INT_BOOL_,RPC_CANACTIVATEQUEST__INT_,RPC_ACTIVATEQUEST__INT_,RPC_HASACTIVEQUESTBITSET__INT_,RPC_HASCOMPLETEDQUESTSBITSET__INT_,RPC_SETCOMPLETEDQUESTSBIT__INT_BYTE_BOOL_,RPC_CLEARCOMPLETEDQUESTSBIT__INT_BOOL_,RPC_COMPLETEQUEST__INT_,RPC_HASQUESTDATA__INT_,RPC_SETLASTNPCCONVSTR__STRING_,RPC_SETLASTNPCCONVMESSSTR__STRING_,RPC_GETLASTNPCCONVSTR__,RPC_GETLASTNPCCONVMESSSTR__,RPC_GETLASTNPCCONVOPTION__INT_,RPC_ADDLASTNPCCONVOPTIONS__STRING_,RPC_COUNTLASTNPCCONVOPTIONS__,RPC_CLEARLASTNPCCONVOPTIONS__,RPC_SETCONVERSATINGCREATURE__CREATUREOBJECT_,RPC_GETCONVERSATINGCREATURE__,RPC_SETTRAINERZONENAME__STRING_,RPC_GETTRAINERZONENAME__,RPC_ADDPERSISTENTMESSAGE__LONG_,RPC_DROPPERSISTENTMESSAGE__LONG_,RPC_UNLOADSPAWNEDCHILDREN__,RPC_ADDTOCONSENTLIST__STRING_,RPC_HASINCONSENTLIST__STRING_,RPC_REMOVEFROMCONSENTLIST__STRING_,RPC_GETCONSENTNAME__INT_,RPC_GETCONSENTLISTSIZE__,RPC_GETREACTIONFINES__,RPC_GETFACTIONRANK__,RPC_SETCOMMANDMESSAGESTRING__INT_STRING_,RPC_REMOVECOMMANDMESSAGESTRING__INT_,RPC_GETDECLAREDRESIDENCE__,RPC_SETDECLAREDRESIDENCE__BUILDINGOBJECT_,RPC_SETCLONINGFACILITY__BUILDINGOBJECT_,RPC_GETCLONINGFACILITY__,RPC_NOTIFYONLINE__,RPC_DODIGEST__INT_,RPC_ISDIGESTING__,RPC_GETSAVEDTERRAINNAME__,RPC_SETSAVEDPARENTID__LONG_,RPC_SETSAVEDTERRAINNAME__STRING_,RPC_SETBIRTHDATE__INT_,RPC_SETFORCEPOWER__INT_BOOL_,RPC_SETFORCEPOWERMAX__INT_BOOL_,RPC_DOFORCEREGEN__,RPC_RECALCULATEFORCEPOWER__,RPC_GETFORCEPOWERREGEN__,RPC_GETSAVEDPARENTID__,RPC_GETNEWSUIBOXID__INT_,RPC_HASSUIBOX__INT_,RPC_GETSUIBOX__INT_,RPC_REMOVESUIBOX__INT_BOOL_,RPC_REMOVESUIBOXTYPE__INT_,RPC_HASSUIBOXWINDOWTYPE__INT_,RPC_CLOSESUIWINDOWTYPE__INT_,RPC_GETSUIBOXFROMWINDOWTYPE__INT_,RPC_ADDSUIBOX__SUIBOX_,RPC_ADDPERMISSIONGROUP__STRING_BOOL_,RPC_REMOVEPERMISSIONGROUP__STRING_BOOL_,RPC_UPDATEINRANGEBUILDINGPERMISSIONS__,RPC_HASPERMISSIONGROUP__STRING_,RPC_ADDINCAPACITATIONTIME__,RPC_GETINCAPACITATIONCOUNTER__,RPC_RESETINCAPACITATIONTIMES__,RPC_ADDTODUELLIST__CREATUREOBJECT_,RPC_REMOVEFROMDUELLIST__CREATUREOBJECT_,RPC_GETDUELLISTOBJECT__INT_,RPC_REQUESTEDDUELTO__CREATUREOBJECT_,RPC_ISDUELLISTEMPTY__,RPC_GETDUELLISTSIZE__,RPC_ADDTOACTIVEPETS__AIAGENT_,RPC_REMOVEFROMACTIVEPETS__AIAGENT_,RPC_GETACTIVEPET__INT_,RPC_HASACTIVEPET__AIAGENT_,RPC_GETACTIVEPETSSIZE__,RPC_GETBIOGRAPHY__,RPC_NOTIFYOFFLINE__,RPC_RESETSESSIONSTATS__BOOL_,RPC_INCREMENTSESSIONMOVEMENT__FLOAT_,RPC_LOGSESSIONSTATS__BOOL_,RPC_SETBADGE__INT_,RPC_REVOKEBADGE__INT_,RPC_AWARDBADGE__INT_,RPC_SETTELEPORTING__BOOL_,RPC_SETONLOADSCREEN__BOOL_,RPC_SETFORCEDTRANSFORM__BOOL_,RPC_GETNUMBADGES__,RPC_GETBADGETYPECOUNT__INT_,RPC_HASFRIEND__STRING_,RPC_GETFRIENDLISTSIZE__,RPC_ISIGNORING__STRING_,RPC_ADDREVERSEFRIEND__STRING_,RPC_REMOVEREVERSEFRIEND__STRING_,RPC_SENDFRIENDLISTS__,RPC_HASABILITY__STRING_,RPC_HASCOMMANDMESSAGESTRING__INT_,RPC_GETTITLE__,RPC_GETADMINLEVEL__,RPC_SETADMINLEVEL__INT_,RPC_GETPRIVILEDGEFLAG__,RPC_SETPRIVILEDGEFLAG__INT_,RPC_SETBIOGRAPHY__UNICODESTRING_,RPC_HASGODMODE__,RPC_ISPRIVILEGED__,RPC_ISSTAFF__,RPC_ISADMIN__,RPC_SETPLAYERBIT__INT_BOOL_,RPC_CLEARPLAYERBIT__INT_BOOL_,RPC_TOGGLECHARACTERBIT__INT_,RPC_ISLFG__,RPC_ISAFK__,RPC_ISANONYMOUS__,RPC_ISROLEPLAYER__,RPC_ISNEWBIEHELPER__,RPC_GETTOTALPLAYEDTIME__,RPC_GETFORCEPOWER__,RPC_GETFORCEPOWERMAX__,RPC_GETSCHEMATIC__INT_,RPC_GETFOODFILLING__,RPC_GETFOODFILLINGMAX__,RPC_GETDRINKFILLING__,RPC_GETDRINKFILLINGMAX__,RPC_GETJEDISTATE__,RPC_GETLANGUAGEID__,RPC_ISTELEPORTING__,RPC_ISONLOADSCREEN__,RPC_ISFORCEDTRANSFORM__,RPC_ADDCHATROOM__INT_,RPC_REMOVECHATROOM__INT_,RPC_ADDOWNEDCHATROOM__INT_,RPC_REMOVEOWNEDCHATROOM__INT_,RPC_GETOWNEDCHATROOMCOUNT__,RPC_SETBANKLOCATION__STRING_,RPC_GETBANKLOCATION__,RPC_GETEXPERIENCE__STRING_,RPC_MAXIMIZEEXPERIENCE__,RPC_ACTIVATEMISSIONS__,RPC_GETCOMMANDMESSAGESTRING__INT_,RPC_HASBADGE__INT_,RPC_CLEARDISCONNECTEVENT__,RPC_ISONLINE__,RPC_ISOFFLINE__,RPC_ISLINKDEAD__,RPC_ISLOGGINGOUT__,RPC_SETSKILLPOINTS__INT_,RPC_ADDSKILLPOINTS__INT_,RPC_GETSKILLPOINTS__,RPC_UPDATELASTVALIDATEDPOSITION__,RPC_GETACCOUNTID__,RPC_GETSERVERMOVEMENTTIMEDELTA__,RPC_SETCLIENTLASTMOVEMENTSTAMP__INT_,RPC_UPDATESERVERLASTMOVEMENTSTAMP__,RPC_SETACCOUNTID__INT_,RPC_GETCLIENTLASTMOVEMENTSTAMP__,RPC_ADDHOLOGRINDPROFESSION__BYTE_,RPC_SETMAXIMUMLOTS__BYTE_,RPC_GETMAXIMUMLOTS__,RPC_GETSTARTERPROFESSION__,RPC_SETSTARTERPROFESSION__STRING_,RPC_GETPERFORMANCEBUFFTARGET__,RPC_SETPERFORMANCEBUFFTARGET__LONG_,RPC_SETDEBUG__BOOL_,RPC_GETDEBUG__,RPC_GETVISIBILITY__,RPC_SETVISIBILITY__FLOAT_,RPC_UPDATELASTCOMBATACTIONTIMESTAMP__BOOL_BOOL_BOOL_,RPC_UPDATELASTBHPVPCOMBATACTIONTIMESTAMP__,RPC_UPDATELASTGCWPVPCOMBATACTIONTIMESTAMP__,RPC_UPDATELASTPVPAREACOMBATACTIONTIMESTAMP__,RPC_HASTEF__,RPC_HASPVPTEF__,RPC_HASGCWTEF__,RPC_HASBHTEF__,RPC_SETCRACKDOWNTEFTOWARDS__INT_BOOL_,RPC_HASCRACKDOWNTEFTOWARDS__INT_,RPC_HASCRACKDOWNTEF__,RPC_SCHEDULEPVPTEFREMOVALTASK__BOOL_BOOL_BOOL_,RPC_SCHEDULEPVPTEFREMOVALTASK__BOOL_,RPC_ISINPVPAREA__BOOL_,RPC_ADDVENDOR__SCENEOBJECT_,RPC_REMOVEVENDOR__SCENEOBJECT_,RPC_GETVENDORCOUNT__,RPC_DESTROYOBJECTFROMDATABASE__BOOL_,RPC_DELETEALLPERSISTENTMESSAGES__,RPC_ISJEDI__,RPC_ISJEDILIGHT__,RPC_ISJEDIDARK__,RPC_ISMUTED__,RPC_SETMUTEDSTATE__BOOL_,RPC_GETMUTEDREASON__,RPC_SETMUTEDREASON__STRING_,RPC_GETINSTALLEDHOLOEMOTE__,RPC_SETINSTALLEDHOLOEMOTE__STRING_,RPC_REMOVEINSTALLEDHOLOEMOTE__,RPC_GETHOLOEMOTEUSECOUNT__,RPC_DECREASEHOLOEMOTEUSECOUNT__,RPC_ISMARRIED__,RPC_GETSPOUSENAME__,RPC_SETSPOUSENAME__STRING_,RPC_REMOVESPOUSE__,RPC_GETACCOUNT__,RPC_GETCHOSENVETERANREWARD__INT_,RPC_HASCHOSENVETERANREWARD__STRING_,RPC_CLEARVETERANREWARD__INT_,RPC_ADDEVENTPERK__SCENEOBJECT_,RPC_REMOVEEVENTPERK__SCENEOBJECT_,RPC_GETEVENTPERKCOUNT__,RPC_GETCHARACTERAGEINDAYS__,RPC_GETBIRTHDATE__,RPC_ADDTOREACTIONFINES__INT_,RPC_SETREACTIONFINES__INT_,RPC_SUBTRACTFROMREACTIONFINES__INT_,RPC_UPDATEREACTIONFINETIMESTAMP__,RPC_UPDATEREACTIONFINEMAILTIMESTAMP__,RPC_GETXPCAP__STRING_,RPC_GETSPENTJEDISKILLPOINTS__,RPC_HASSCHEMATIC__DRAFTSCHEMATIC_,RPC_HASEVENTPERK__STRING_,RPC_DOFIELDFACTIONCHANGE__INT_,RPC_ADDTOVICTIMLIST__INT_,RPC_HASONVICTIMLIST__INT_,RPC_GETPVPRATING__,RPC_SETPVPRATING__INT_,RPC_ISCLONING__,RPC_SETCLONING__BOOL_,RPC_GETPLAYEDMILISECS__,RPC_GETSESSIONMILISECS__,RPC_GETSESSIONTOTALMOVEMENT__,RPC_GETSESSIONTOTALCREDITS__,RPC_GETMILISECSTIMESTRING__LONG_BOOL_,RPC_GETPLAYEDTIMESTRING__BOOL_};

PlayerObject::PlayerObject() : IntangibleObject(DummyConstructorParameter::instance()) {
	PlayerObjectImplementation* _implementation = new PlayerObjectImplementation();
	_impl = _implementation;
	_impl->_setStub(this);
	_setClassName("PlayerObject");
}

PlayerObject::PlayerObject(DummyConstructorParameter* param) : IntangibleObject(param) {
	_setClassName("PlayerObject");
}

PlayerObject::~PlayerObject() {
}



PlayerObject* PlayerObject::__asPlayerObject() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->asPlayerObject();
	}
}

void PlayerObject::setLogLevel(int newLevel) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETLOGLEVEL__INT_);
		method.addSignedIntParameter(newLevel);

		method.executeWithVoidReturn();
	} else {
		_implementation->setLogLevel(newLevel);
	}
}

int PlayerObject::getLogLevel() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETLOGLEVEL__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getLogLevel();
	}
}

int PlayerObject::getCountMaxCov() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCOUNTMAXCOV__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getCountMaxCov();
	}
}

void PlayerObject::setCountMaxCov(int newMaxCov) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCOUNTMAXCOV__INT_);
		method.addSignedIntParameter(newMaxCov);

		method.executeWithVoidReturn();
	} else {
		_implementation->setCountMaxCov(newMaxCov);
	}
}

void PlayerObject::setClientPathWaypoint(SceneObject* obj) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCLIENTPATHWAYPOINT__SCENEOBJECT_);
		method.addObjectParameter(obj);

		method.executeWithVoidReturn();
	} else {
		_implementation->setClientPathWaypoint(obj);
	}
}

void PlayerObject::initializeAccount() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INITIALIZEACCOUNT__);

		method.executeWithVoidReturn();
	} else {
		_implementation->initializeAccount();
	}
}

void PlayerObject::notifyLoadFromDatabase() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYLOADFROMDATABASE__);

		method.executeWithVoidReturn();
	} else {
		_implementation->notifyLoadFromDatabase();
	}
}

void PlayerObject::unload() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UNLOAD__);

		method.executeWithVoidReturn();
	} else {
		_implementation->unload();
	}
}

int PlayerObject::calculateBhReward() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CALCULATEBHREWARD__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->calculateBhReward();
	}
}

void PlayerObject::loadTemplateData(SharedObjectTemplate* templateData) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->loadTemplateData(templateData);
	}
}

void PlayerObject::initializeTransientMembers() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INITIALIZETRANSIENTMEMBERS__);

		method.executeWithVoidReturn();
	} else {
		_implementation->initializeTransientMembers();
	}
}

void PlayerObject::sendBaselinesTo(SceneObject* player) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDBASELINESTO__SCENEOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendBaselinesTo(player);
	}
}

void PlayerObject::sendMessage(BasePacket* msg) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->sendMessage(msg);
	}
}

void PlayerObject::addOwnedStructure(StructureObject* obj) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDOWNEDSTRUCTURE__STRUCTUREOBJECT_);
		method.addObjectParameter(obj);

		method.executeWithVoidReturn();
	} else {
		_implementation->addOwnedStructure(obj);
	}
}

void PlayerObject::removeOwnedStructure(StructureObject* obj) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEOWNEDSTRUCTURE__STRUCTUREOBJECT_);
		method.addObjectParameter(obj);

		method.executeWithVoidReturn();
	} else {
		_implementation->removeOwnedStructure(obj);
	}
}

int PlayerObject::getAcceptedTOSVersion() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETACCEPTEDTOSVERSION__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getAcceptedTOSVersion();
	}
}

void PlayerObject::setAcceptedTOSVersion(int version) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETACCEPTEDTOSVERSION__INT_);
		method.addSignedIntParameter(version);

		method.executeWithVoidReturn();
	} else {
		_implementation->setAcceptedTOSVersion(version);
	}
}

void PlayerObject::checkAndShowTOS() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CHECKANDSHOWTOS__);

		method.executeWithVoidReturn();
	} else {
		_implementation->checkAndShowTOS();
	}
}

void PlayerObject::createHelperDroid() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CREATEHELPERDROID__);

		method.executeWithVoidReturn();
	} else {
		_implementation->createHelperDroid();
	}
}

int PlayerObject::getTotalOwnedStructureCount() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETTOTALOWNEDSTRUCTURECOUNT__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getTotalOwnedStructureCount();
	}
}

bool PlayerObject::isOwnedStructure(StructureObject* obj) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISOWNEDSTRUCTURE__STRUCTUREOBJECT_);
		method.addObjectParameter(obj);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isOwnedStructure(obj);
	}
}

unsigned long long PlayerObject::getOwnedStructure(int i) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETOWNEDSTRUCTURE__INT_);
		method.addSignedIntParameter(i);

		return method.executeWithUnsignedLongReturn();
	} else {
		return _implementation->getOwnedStructure(i);
	}
}

int PlayerObject::getLotsRemaining() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETLOTSREMAINING__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getLotsRemaining();
	}
}

bool PlayerObject::hasLotsRemaining(int lots) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASLOTSREMAINING__INT_);
		method.addSignedIntParameter(lots);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasLotsRemaining(lots);
	}
}

void PlayerObject::notifySceneReady() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYSCENEREADY__);

		method.executeWithVoidReturn();
	} else {
		_implementation->notifySceneReady();
	}
}

void PlayerObject::checkPendingMessages() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CHECKPENDINGMESSAGES__);

		method.executeWithVoidReturn();
	} else {
		_implementation->checkPendingMessages();
	}
}

int PlayerObject::addExperience(TransactionLog& trx, const String& xpType, int xp, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->addExperience(trx, xpType, xp, notifyClient);
	}
}

void PlayerObject::removeExperience(TransactionLog& trx, const String& xpType, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->removeExperience(trx, xpType, notifyClient);
	}
}

bool PlayerObject::hasCappedExperience(const String& xpType) const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASCAPPEDEXPERIENCE__STRING_);
		method.addAsciiParameter(xpType);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasCappedExperience(xpType);
	}
}

void PlayerObject::addWaypoint(WaypointObject* waypoint, bool checkName, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDWAYPOINT__WAYPOINTOBJECT_BOOL_BOOL_);
		method.addObjectParameter(waypoint);
		method.addBooleanParameter(checkName);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->addWaypoint(waypoint, checkName, notifyClient);
	}
}

void PlayerObject::setWaypoint(WaypointObject* waypoint, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETWAYPOINT__WAYPOINTOBJECT_BOOL_);
		method.addObjectParameter(waypoint);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->setWaypoint(waypoint, notifyClient);
	}
}

WaypointObject* PlayerObject::addWaypoint(const String& planet, float positionX, float positionY, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->addWaypoint(planet, positionX, positionY, notifyClient);
	}
}

void PlayerObject::removeWaypoint(unsigned long long waypointID, bool notifyClient, bool destroy) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEWAYPOINT__LONG_BOOL_BOOL_);
		method.addUnsignedLongParameter(waypointID);
		method.addBooleanParameter(notifyClient);
		method.addBooleanParameter(destroy);

		method.executeWithVoidReturn();
	} else {
		_implementation->removeWaypoint(waypointID, notifyClient, destroy);
	}
}

void PlayerObject::updateWaypoint(unsigned long long waypointID) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATEWAYPOINT__LONG_);
		method.addUnsignedLongParameter(waypointID);

		method.executeWithVoidReturn();
	} else {
		_implementation->updateWaypoint(waypointID);
	}
}

void PlayerObject::removeWaypointBySpecialType(int specialTypeID, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEWAYPOINTBYSPECIALTYPE__INT_BOOL_);
		method.addSignedIntParameter(specialTypeID);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->removeWaypointBySpecialType(specialTypeID, notifyClient);
	}
}

WaypointObject* PlayerObject::getWaypointBySpecialType(int specialTypeID) const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETWAYPOINTBYSPECIALTYPE__INT_);
		method.addSignedIntParameter(specialTypeID);

		return static_cast<WaypointObject*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getWaypointBySpecialType(specialTypeID);
	}
}

WaypointObject* PlayerObject::getSurveyWaypoint() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSURVEYWAYPOINT__);

		return static_cast<WaypointObject*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getSurveyWaypoint();
	}
}

bool PlayerObject::hasWaypoint(unsigned long long objectID) const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASWAYPOINT__LONG_);
		method.addUnsignedLongParameter(objectID);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasWaypoint(objectID);
	}
}

WaypointObject* PlayerObject::getWaypointAt(float x, float y, String& planet) const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETWAYPOINTAT__FLOAT_FLOAT_STRING_);
		method.addFloatParameter(x);
		method.addFloatParameter(y);
		method.addAsciiParameter(planet);

		return static_cast<WaypointObject*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getWaypointAt(x, y, planet);
	}
}

void PlayerObject::insertWaypointListToMessage(BaseMessage* msg) const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->insertWaypointListToMessage(msg);
	}
}

int PlayerObject::getWaypointListSize() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETWAYPOINTLISTSIZE__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getWaypointListSize();
	}
}

WaypointObject* PlayerObject::getWaypoint(int index) const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETWAYPOINT__INT_);
		method.addSignedIntParameter(index);

		return static_cast<WaypointObject*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getWaypoint(index);
	}
}

void PlayerObject::addAbilities(Vector<Ability*>& abilities, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->addAbilities(abilities, notifyClient);
	}
}

void PlayerObject::addAbility(Ability* ability, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->addAbility(ability, notifyClient);
	}
}

void PlayerObject::removeAbilities(Vector<Ability*>& abilities, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->removeAbilities(abilities, notifyClient);
	}
}

void PlayerObject::removeAbility(Ability* ability, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->removeAbility(ability, notifyClient);
	}
}

bool PlayerObject::addSchematics(Vector<ManagedReference<DraftSchematic* > >& schematics, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->addSchematics(schematics, notifyClient);
	}
}

void PlayerObject::removeSchematics(Vector<ManagedReference<DraftSchematic* > >& schematics, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->removeSchematics(schematics, notifyClient);
	}
}

bool PlayerObject::addRewardedSchematic(DraftSchematic* schematic, short type, int quantity, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->addRewardedSchematic(schematic, type, quantity, notifyClient);
	}
}

void PlayerObject::removeRewardedSchematic(DraftSchematic* schematic, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->removeRewardedSchematic(schematic, notifyClient);
	}
}

void PlayerObject::decreaseSchematicUseCount(DraftSchematic* schematic) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->decreaseSchematicUseCount(schematic);
	}
}

void PlayerObject::setLanguageID(byte language, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETLANGUAGEID__BYTE_BOOL_);
		method.addByteParameter(language);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->setLanguageID(language, notifyClient);
	}
}

void PlayerObject::addFriend(const String& name, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDFRIEND__STRING_BOOL_);
		method.addAsciiParameter(name);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->addFriend(name, notifyClient);
	}
}

void PlayerObject::removeFriend(const String& name, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEFRIEND__STRING_BOOL_);
		method.addAsciiParameter(name);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->removeFriend(name, notifyClient);
	}
}

void PlayerObject::removeAllReverseFriends(const String& oldName) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEALLREVERSEFRIENDS__STRING_);
		method.addAsciiParameter(oldName);

		method.executeWithVoidReturn();
	} else {
		_implementation->removeAllReverseFriends(oldName);
	}
}

void PlayerObject::addIgnore(const String& name, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDIGNORE__STRING_BOOL_);
		method.addAsciiParameter(name);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->addIgnore(name, notifyClient);
	}
}

void PlayerObject::removeIgnore(const String& name, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEIGNORE__STRING_BOOL_);
		method.addAsciiParameter(name);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->removeIgnore(name, notifyClient);
	}
}

void PlayerObject::setTitle(const String& characterTitle, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETTITLE__STRING_BOOL_);
		method.addAsciiParameter(characterTitle);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->setTitle(characterTitle, notifyClient);
	}
}

void PlayerObject::setFoodFilling(int newValue, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETFOODFILLING__INT_BOOL_);
		method.addSignedIntParameter(newValue);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->setFoodFilling(newValue, notifyClient);
	}
}

void PlayerObject::setDrinkFilling(int newValue, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETDRINKFILLING__INT_BOOL_);
		method.addSignedIntParameter(newValue);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->setDrinkFilling(newValue, notifyClient);
	}
}

void PlayerObject::increaseFactionStanding(const String& factionName, float amount) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INCREASEFACTIONSTANDING__STRING_FLOAT_);
		method.addAsciiParameter(factionName);
		method.addFloatParameter(amount);

		method.executeWithVoidReturn();
	} else {
		_implementation->increaseFactionStanding(factionName, amount);
	}
}

void PlayerObject::giveCoaBonus(const String& factionName, float amount, float currentStanding) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GIVECOABONUS__STRING_FLOAT_FLOAT_);
		method.addAsciiParameter(factionName);
		method.addFloatParameter(amount);
		method.addFloatParameter(currentStanding);

		method.executeWithVoidReturn();
	} else {
		_implementation->giveCoaBonus(factionName, amount, currentStanding);
	}
}

void PlayerObject::decreaseFactionStanding(const String& factionName, float amount) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DECREASEFACTIONSTANDING__STRING_FLOAT_);
		method.addAsciiParameter(factionName);
		method.addFloatParameter(amount);

		method.executeWithVoidReturn();
	} else {
		_implementation->decreaseFactionStanding(factionName, amount);
	}
}

void PlayerObject::setFactionStanding(const String& factionName, float amount) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETFACTIONSTANDING__STRING_FLOAT_);
		method.addAsciiParameter(factionName);
		method.addFloatParameter(amount);

		method.executeWithVoidReturn();
	} else {
		_implementation->setFactionStanding(factionName, amount);
	}
}

float PlayerObject::getFactionStanding(const String& factionName) const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETFACTIONSTANDING__STRING_);
		method.addAsciiParameter(factionName);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getFactionStanding(factionName);
	}
}

void PlayerObject::setScreenPlayData(const String& screenPlay, const String& variable, const String& data) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSCREENPLAYDATA__STRING_STRING_STRING_);
		method.addAsciiParameter(screenPlay);
		method.addAsciiParameter(variable);
		method.addAsciiParameter(data);

		method.executeWithVoidReturn();
	} else {
		_implementation->setScreenPlayData(screenPlay, variable, data);
	}
}

void PlayerObject::deleteScreenPlayData(const String& screenPlay, const String& variable) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DELETESCREENPLAYDATA__STRING_STRING_);
		method.addAsciiParameter(screenPlay);
		method.addAsciiParameter(variable);

		method.executeWithVoidReturn();
	} else {
		_implementation->deleteScreenPlayData(screenPlay, variable);
	}
}

String PlayerObject::getScreenPlayData(const String& screenPlay, const String& variable) const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSCREENPLAYDATA__STRING_STRING_);
		method.addAsciiParameter(screenPlay);
		method.addAsciiParameter(variable);

		String _return_getScreenPlayData;
		method.executeWithAsciiReturn(_return_getScreenPlayData);
		return _return_getScreenPlayData;
	} else {
		return _implementation->getScreenPlayData(screenPlay, variable);
	}
}

void PlayerObject::clearScreenPlayData(const String& screenPlay) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARSCREENPLAYDATA__STRING_);
		method.addAsciiParameter(screenPlay);

		method.executeWithVoidReturn();
	} else {
		_implementation->clearScreenPlayData(screenPlay);
	}
}

void PlayerObject::activateRecovery() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ACTIVATERECOVERY__);

		method.executeWithVoidReturn();
	} else {
		_implementation->activateRecovery();
	}
}

void PlayerObject::activateForcePowerRegen() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ACTIVATEFORCEPOWERREGEN__);

		method.executeWithVoidReturn();
	} else {
		_implementation->activateForcePowerRegen();
	}
}

void PlayerObject::doRecovery(int latency) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DORECOVERY__INT_);
		method.addSignedIntParameter(latency);

		method.executeWithVoidReturn();
	} else {
		_implementation->doRecovery(latency);
	}
}

void PlayerObject::disconnect(bool closeClient, bool doLock) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DISCONNECT__BOOL_BOOL_);
		method.addBooleanParameter(closeClient);
		method.addBooleanParameter(doLock);

		method.executeWithVoidReturn();
	} else {
		_implementation->disconnect(closeClient, doLock);
	}
}

void PlayerObject::reload(ZoneClientSession* client) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_RELOAD__ZONECLIENTSESSION_);
		method.addObjectParameter(client);

		method.executeWithVoidReturn();
	} else {
		_implementation->reload(client);
	}
}

void PlayerObject::setOffline() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETOFFLINE__);

		method.executeWithVoidReturn();
	} else {
		_implementation->setOffline();
	}
}

void PlayerObject::setLinkDead(bool isSafeLogout) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETLINKDEAD__BOOL_);
		method.addBooleanParameter(isSafeLogout);

		method.executeWithVoidReturn();
	} else {
		_implementation->setLinkDead(isSafeLogout);
	}
}

void PlayerObject::setOnline() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETONLINE__);

		method.executeWithVoidReturn();
	} else {
		_implementation->setOnline();
	}
}

void PlayerObject::setLoggingOut() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETLOGGINGOUT__);

		method.executeWithVoidReturn();
	} else {
		_implementation->setLoggingOut();
	}
}

void PlayerObject::activateJournalQuest(unsigned int questCrc, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ACTIVATEJOURNALQUEST__INT_BOOL_);
		method.addUnsignedIntParameter(questCrc);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->activateJournalQuest(questCrc, notifyClient);
	}
}

void PlayerObject::completeJournalQuest(unsigned int questCrc, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_COMPLETEJOURNALQUEST__INT_BOOL_);
		method.addUnsignedIntParameter(questCrc);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->completeJournalQuest(questCrc, notifyClient);
	}
}

void PlayerObject::clearJournalQuest(unsigned int questCrc, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARJOURNALQUEST__INT_BOOL_);
		method.addUnsignedIntParameter(questCrc);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->clearJournalQuest(questCrc, notifyClient);
	}
}

void PlayerObject::activateJournalQuestTask(unsigned int questCrc, int taskNum, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ACTIVATEJOURNALQUESTTASK__INT_INT_BOOL_);
		method.addUnsignedIntParameter(questCrc);
		method.addSignedIntParameter(taskNum);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->activateJournalQuestTask(questCrc, taskNum, notifyClient);
	}
}

void PlayerObject::completeJournalQuestTask(unsigned int questCrc, int taskNum, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_COMPLETEJOURNALQUESTTASK__INT_INT_BOOL_);
		method.addUnsignedIntParameter(questCrc);
		method.addSignedIntParameter(taskNum);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->completeJournalQuestTask(questCrc, taskNum, notifyClient);
	}
}

void PlayerObject::clearJournalQuestTask(unsigned int questCrc, int taskNum, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARJOURNALQUESTTASK__INT_INT_BOOL_);
		method.addUnsignedIntParameter(questCrc);
		method.addSignedIntParameter(taskNum);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->clearJournalQuestTask(questCrc, taskNum, notifyClient);
	}
}

bool PlayerObject::isJournalQuestActive(unsigned int questCrc) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISJOURNALQUESTACTIVE__INT_);
		method.addUnsignedIntParameter(questCrc);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isJournalQuestActive(questCrc);
	}
}

bool PlayerObject::isJournalQuestComplete(unsigned int questCrc) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISJOURNALQUESTCOMPLETE__INT_);
		method.addUnsignedIntParameter(questCrc);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isJournalQuestComplete(questCrc);
	}
}

bool PlayerObject::isJournalQuestTaskActive(unsigned int questCrc, int taskNum) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISJOURNALQUESTTASKACTIVE__INT_INT_);
		method.addUnsignedIntParameter(questCrc);
		method.addSignedIntParameter(taskNum);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isJournalQuestTaskActive(questCrc, taskNum);
	}
}

bool PlayerObject::isJournalQuestTaskComplete(unsigned int questCrc, int taskNum) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISJOURNALQUESTTASKCOMPLETE__INT_INT_);
		method.addUnsignedIntParameter(questCrc);
		method.addSignedIntParameter(taskNum);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isJournalQuestTaskComplete(questCrc, taskNum);
	}
}

void PlayerObject::sendBadgesResponseTo(CreatureObject* player) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDBADGESRESPONSETO__CREATUREOBJECT_);
		method.addObjectParameter(player);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendBadgesResponseTo(player);
	}
}

void PlayerObject::logout(bool doLock) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_LOGOUT__BOOL_);
		method.addBooleanParameter(doLock);

		method.executeWithVoidReturn();
	} else {
		_implementation->logout(doLock);
	}
}

void PlayerObject::setJediState(int state, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETJEDISTATE__INT_BOOL_);
		method.addSignedIntParameter(state);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->setJediState(state, notifyClient);
	}
}

void PlayerObject::setActiveQuestsBit(int bitIndex, byte value, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETACTIVEQUESTSBIT__INT_BYTE_BOOL_);
		method.addSignedIntParameter(bitIndex);
		method.addByteParameter(value);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->setActiveQuestsBit(bitIndex, value, notifyClient);
	}
}

void PlayerObject::clearActiveQuestsBit(int bitIndex, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARACTIVEQUESTSBIT__INT_BOOL_);
		method.addSignedIntParameter(bitIndex);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->clearActiveQuestsBit(bitIndex, notifyClient);
	}
}

bool PlayerObject::canActivateQuest(int questID) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CANACTIVATEQUEST__INT_);
		method.addSignedIntParameter(questID);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->canActivateQuest(questID);
	}
}

void PlayerObject::activateQuest(int questID) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ACTIVATEQUEST__INT_);
		method.addSignedIntParameter(questID);

		method.executeWithVoidReturn();
	} else {
		_implementation->activateQuest(questID);
	}
}

bool PlayerObject::hasActiveQuestBitSet(int bitIndex) const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASACTIVEQUESTBITSET__INT_);
		method.addSignedIntParameter(bitIndex);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasActiveQuestBitSet(bitIndex);
	}
}

bool PlayerObject::hasCompletedQuestsBitSet(int bitIndex) const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASCOMPLETEDQUESTSBITSET__INT_);
		method.addSignedIntParameter(bitIndex);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasCompletedQuestsBitSet(bitIndex);
	}
}

void PlayerObject::setCompletedQuestsBit(int bitIndex, byte value, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCOMPLETEDQUESTSBIT__INT_BYTE_BOOL_);
		method.addSignedIntParameter(bitIndex);
		method.addByteParameter(value);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->setCompletedQuestsBit(bitIndex, value, notifyClient);
	}
}

void PlayerObject::clearCompletedQuestsBit(int bitIndex, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARCOMPLETEDQUESTSBIT__INT_BOOL_);
		method.addSignedIntParameter(bitIndex);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->clearCompletedQuestsBit(bitIndex, notifyClient);
	}
}

void PlayerObject::completeQuest(int questID) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_COMPLETEQUEST__INT_);
		method.addSignedIntParameter(questID);

		method.executeWithVoidReturn();
	} else {
		_implementation->completeQuest(questID);
	}
}

PlayerQuestData PlayerObject::getQuestData(unsigned int questCrc) const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getQuestData(questCrc);
	}
}

bool PlayerObject::hasQuestData(unsigned int questCrc) const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASQUESTDATA__INT_);
		method.addUnsignedIntParameter(questCrc);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasQuestData(questCrc);
	}
}

void PlayerObject::setPlayerQuestData(unsigned int questCrc, PlayerQuestData& data, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->setPlayerQuestData(questCrc, data, notifyClient);
	}
}

void PlayerObject::clearPlayerQuestData(unsigned int questCrc, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->clearPlayerQuestData(questCrc, notifyClient);
	}
}

FactionStandingList* PlayerObject::getFactionStandingList() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getFactionStandingList();
	}
}

void PlayerObject::setLastNpcConvStr(const String& conv) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETLASTNPCCONVSTR__STRING_);
		method.addAsciiParameter(conv);

		method.executeWithVoidReturn();
	} else {
		_implementation->setLastNpcConvStr(conv);
	}
}

void PlayerObject::setLastNpcConvMessStr(const String& mess) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETLASTNPCCONVMESSSTR__STRING_);
		method.addAsciiParameter(mess);

		method.executeWithVoidReturn();
	} else {
		_implementation->setLastNpcConvMessStr(mess);
	}
}

String PlayerObject::getLastNpcConvStr() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETLASTNPCCONVSTR__);

		String _return_getLastNpcConvStr;
		method.executeWithAsciiReturn(_return_getLastNpcConvStr);
		return _return_getLastNpcConvStr;
	} else {
		return _implementation->getLastNpcConvStr();
	}
}

String PlayerObject::getLastNpcConvMessStr() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETLASTNPCCONVMESSSTR__);

		String _return_getLastNpcConvMessStr;
		method.executeWithAsciiReturn(_return_getLastNpcConvMessStr);
		return _return_getLastNpcConvMessStr;
	} else {
		return _implementation->getLastNpcConvMessStr();
	}
}

String PlayerObject::getLastNpcConvOption(int idx) const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETLASTNPCCONVOPTION__INT_);
		method.addSignedIntParameter(idx);

		String _return_getLastNpcConvOption;
		method.executeWithAsciiReturn(_return_getLastNpcConvOption);
		return _return_getLastNpcConvOption;
	} else {
		return _implementation->getLastNpcConvOption(idx);
	}
}

void PlayerObject::addLastNpcConvOptions(const String& option) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDLASTNPCCONVOPTIONS__STRING_);
		method.addAsciiParameter(option);

		method.executeWithVoidReturn();
	} else {
		_implementation->addLastNpcConvOptions(option);
	}
}

int PlayerObject::countLastNpcConvOptions() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_COUNTLASTNPCCONVOPTIONS__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->countLastNpcConvOptions();
	}
}

void PlayerObject::clearLastNpcConvOptions() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARLASTNPCCONVOPTIONS__);

		method.executeWithVoidReturn();
	} else {
		_implementation->clearLastNpcConvOptions();
	}
}

void PlayerObject::setConversatingCreature(CreatureObject* creature) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCONVERSATINGCREATURE__CREATUREOBJECT_);
		method.addObjectParameter(creature);

		method.executeWithVoidReturn();
	} else {
		_implementation->setConversatingCreature(creature);
	}
}

unsigned long long PlayerObject::getConversatingCreature() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCONVERSATINGCREATURE__);

		return method.executeWithUnsignedLongReturn();
	} else {
		return _implementation->getConversatingCreature();
	}
}

void PlayerObject::setTrainerCoordinates(const Vector3& trainer) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->setTrainerCoordinates(trainer);
	}
}

Vector3 PlayerObject::getTrainerCoordinates() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getTrainerCoordinates();
	}
}

void PlayerObject::setTrainerZoneName(String& zoneName) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETTRAINERZONENAME__STRING_);
		method.addAsciiParameter(zoneName);

		method.executeWithVoidReturn();
	} else {
		_implementation->setTrainerZoneName(zoneName);
	}
}

String PlayerObject::getTrainerZoneName() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETTRAINERZONENAME__);

		String _return_getTrainerZoneName;
		method.executeWithAsciiReturn(_return_getTrainerZoneName);
		return _return_getTrainerZoneName;
	} else {
		return _implementation->getTrainerZoneName();
	}
}

SortedVector<unsigned long long>* PlayerObject::getPersistentMessages() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getPersistentMessages();
	}
}

void PlayerObject::addPersistentMessage(unsigned long long id) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDPERSISTENTMESSAGE__LONG_);
		method.addUnsignedLongParameter(id);

		method.executeWithVoidReturn();
	} else {
		_implementation->addPersistentMessage(id);
	}
}

void PlayerObject::dropPersistentMessage(unsigned long long id) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DROPPERSISTENTMESSAGE__LONG_);
		method.addUnsignedLongParameter(id);

		method.executeWithVoidReturn();
	} else {
		_implementation->dropPersistentMessage(id);
	}
}

void PlayerObject::unloadSpawnedChildren() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UNLOADSPAWNEDCHILDREN__);

		method.executeWithVoidReturn();
	} else {
		_implementation->unloadSpawnedChildren();
	}
}

void PlayerObject::addToConsentList(const String& name) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDTOCONSENTLIST__STRING_);
		method.addAsciiParameter(name);

		method.executeWithVoidReturn();
	} else {
		_implementation->addToConsentList(name);
	}
}

bool PlayerObject::hasInConsentList(const String& name) const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASINCONSENTLIST__STRING_);
		method.addAsciiParameter(name);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasInConsentList(name);
	}
}

void PlayerObject::removeFromConsentList(const String& name) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEFROMCONSENTLIST__STRING_);
		method.addAsciiParameter(name);

		method.executeWithVoidReturn();
	} else {
		_implementation->removeFromConsentList(name);
	}
}

String PlayerObject::getConsentName(int i) const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCONSENTNAME__INT_);
		method.addSignedIntParameter(i);

		String _return_getConsentName;
		method.executeWithAsciiReturn(_return_getConsentName);
		return _return_getConsentName;
	} else {
		return _implementation->getConsentName(i);
	}
}

int PlayerObject::getConsentListSize() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCONSENTLISTSIZE__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getConsentListSize();
	}
}

int PlayerObject::getReactionFines() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETREACTIONFINES__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getReactionFines();
	}
}

String PlayerObject::getFactionRank() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETFACTIONRANK__);

		String _return_getFactionRank;
		method.executeWithAsciiReturn(_return_getFactionRank);
		return _return_getFactionRank;
	} else {
		return _implementation->getFactionRank();
	}
}

void PlayerObject::setFactionRank(const String& rank) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->setFactionRank(rank);
	}
}

void PlayerObject::setCommandMessageString(unsigned int actionCRC, String& message) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCOMMANDMESSAGESTRING__INT_STRING_);
		method.addUnsignedIntParameter(actionCRC);
		method.addAsciiParameter(message);

		method.executeWithVoidReturn();
	} else {
		_implementation->setCommandMessageString(actionCRC, message);
	}
}

void PlayerObject::removeCommandMessageString(unsigned int actionCRC) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVECOMMANDMESSAGESTRING__INT_);
		method.addUnsignedIntParameter(actionCRC);

		method.executeWithVoidReturn();
	} else {
		_implementation->removeCommandMessageString(actionCRC);
	}
}

unsigned long long PlayerObject::getDeclaredResidence() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETDECLAREDRESIDENCE__);

		return method.executeWithUnsignedLongReturn();
	} else {
		return _implementation->getDeclaredResidence();
	}
}

void PlayerObject::setDeclaredResidence(BuildingObject* residence) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETDECLAREDRESIDENCE__BUILDINGOBJECT_);
		method.addObjectParameter(residence);

		method.executeWithVoidReturn();
	} else {
		_implementation->setDeclaredResidence(residence);
	}
}

void PlayerObject::setCloningFacility(BuildingObject* cloningfac) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCLONINGFACILITY__BUILDINGOBJECT_);
		method.addObjectParameter(cloningfac);

		method.executeWithVoidReturn();
	} else {
		_implementation->setCloningFacility(cloningfac);
	}
}

unsigned long long PlayerObject::getCloningFacility() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCLONINGFACILITY__);

		return method.executeWithUnsignedLongReturn();
	} else {
		return _implementation->getCloningFacility();
	}
}

void PlayerObject::notifyOnline() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYONLINE__);

		method.executeWithVoidReturn();
	} else {
		_implementation->notifyOnline();
	}
}

void PlayerObject::doDigest(int fillingReduction) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DODIGEST__INT_);
		method.addSignedIntParameter(fillingReduction);

		method.executeWithVoidReturn();
	} else {
		_implementation->doDigest(fillingReduction);
	}
}

bool PlayerObject::isDigesting() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISDIGESTING__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isDigesting();
	}
}

String PlayerObject::getSavedTerrainName() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSAVEDTERRAINNAME__);

		String _return_getSavedTerrainName;
		method.executeWithAsciiReturn(_return_getSavedTerrainName);
		return _return_getSavedTerrainName;
	} else {
		return _implementation->getSavedTerrainName();
	}
}

void PlayerObject::setSavedParentID(unsigned long long id) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSAVEDPARENTID__LONG_);
		method.addUnsignedLongParameter(id);

		method.executeWithVoidReturn();
	} else {
		_implementation->setSavedParentID(id);
	}
}

void PlayerObject::setSavedTerrainName(const String& name) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSAVEDTERRAINNAME__STRING_);
		method.addAsciiParameter(name);

		method.executeWithVoidReturn();
	} else {
		_implementation->setSavedTerrainName(name);
	}
}

void PlayerObject::setBirthDate(int date) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETBIRTHDATE__INT_);
		method.addSignedIntParameter(date);

		method.executeWithVoidReturn();
	} else {
		_implementation->setBirthDate(date);
	}
}

void PlayerObject::setForcePower(int fp, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETFORCEPOWER__INT_BOOL_);
		method.addSignedIntParameter(fp);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->setForcePower(fp, notifyClient);
	}
}

void PlayerObject::setForcePowerMax(int newValue, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETFORCEPOWERMAX__INT_BOOL_);
		method.addSignedIntParameter(newValue);
		method.addBooleanParameter(notifyClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->setForcePowerMax(newValue, notifyClient);
	}
}

void PlayerObject::doForceRegen() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DOFORCEREGEN__);

		method.executeWithVoidReturn();
	} else {
		_implementation->doForceRegen();
	}
}

void PlayerObject::recalculateForcePower() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_RECALCULATEFORCEPOWER__);

		method.executeWithVoidReturn();
	} else {
		_implementation->recalculateForcePower();
	}
}

int PlayerObject::getForcePowerRegen() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETFORCEPOWERREGEN__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getForcePowerRegen();
	}
}

unsigned long long PlayerObject::getSavedParentID() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSAVEDPARENTID__);

		return method.executeWithUnsignedLongReturn();
	} else {
		return _implementation->getSavedParentID();
	}
}

unsigned int PlayerObject::getNewSuiBoxID(unsigned int type) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETNEWSUIBOXID__INT_);
		method.addUnsignedIntParameter(type);

		return method.executeWithUnsignedIntReturn();
	} else {
		return _implementation->getNewSuiBoxID(type);
	}
}

bool PlayerObject::hasSuiBox(unsigned int boxID) const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASSUIBOX__INT_);
		method.addUnsignedIntParameter(boxID);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasSuiBox(boxID);
	}
}

Reference<SuiBox* > PlayerObject::getSuiBox(unsigned int boxID) const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSUIBOX__INT_);
		method.addUnsignedIntParameter(boxID);

		return static_cast<SuiBox*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getSuiBox(boxID);
	}
}

void PlayerObject::removeSuiBox(unsigned int boxID, bool closeWindowToClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVESUIBOX__INT_BOOL_);
		method.addUnsignedIntParameter(boxID);
		method.addBooleanParameter(closeWindowToClient);

		method.executeWithVoidReturn();
	} else {
		_implementation->removeSuiBox(boxID, closeWindowToClient);
	}
}

void PlayerObject::removeSuiBoxType(unsigned int windowType) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVESUIBOXTYPE__INT_);
		method.addUnsignedIntParameter(windowType);

		method.executeWithVoidReturn();
	} else {
		_implementation->removeSuiBoxType(windowType);
	}
}

bool PlayerObject::hasSuiBoxWindowType(unsigned int windowType) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASSUIBOXWINDOWTYPE__INT_);
		method.addUnsignedIntParameter(windowType);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasSuiBoxWindowType(windowType);
	}
}

void PlayerObject::closeSuiWindowType(unsigned int windowType) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLOSESUIWINDOWTYPE__INT_);
		method.addUnsignedIntParameter(windowType);

		method.executeWithVoidReturn();
	} else {
		_implementation->closeSuiWindowType(windowType);
	}
}

Reference<SuiBox* > PlayerObject::getSuiBoxFromWindowType(unsigned int windowType) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSUIBOXFROMWINDOWTYPE__INT_);
		method.addUnsignedIntParameter(windowType);

		return static_cast<SuiBox*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getSuiBoxFromWindowType(windowType);
	}
}

void PlayerObject::addSuiBox(SuiBox* sui) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDSUIBOX__SUIBOX_);
		method.addObjectParameter(sui);

		method.executeWithVoidReturn();
	} else {
		_implementation->addSuiBox(sui);
	}
}

void PlayerObject::addPermissionGroup(const String& group, bool updatePermissions) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDPERMISSIONGROUP__STRING_BOOL_);
		method.addAsciiParameter(group);
		method.addBooleanParameter(updatePermissions);

		method.executeWithVoidReturn();
	} else {
		_implementation->addPermissionGroup(group, updatePermissions);
	}
}

void PlayerObject::removePermissionGroup(const String& group, bool updatePermissions) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEPERMISSIONGROUP__STRING_BOOL_);
		method.addAsciiParameter(group);
		method.addBooleanParameter(updatePermissions);

		method.executeWithVoidReturn();
	} else {
		_implementation->removePermissionGroup(group, updatePermissions);
	}
}

void PlayerObject::updateInRangeBuildingPermissions() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATEINRANGEBUILDINGPERMISSIONS__);

		method.executeWithVoidReturn();
	} else {
		_implementation->updateInRangeBuildingPermissions();
	}
}

bool PlayerObject::hasPermissionGroup(const String& group) const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASPERMISSIONGROUP__STRING_);
		method.addAsciiParameter(group);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasPermissionGroup(group);
	}
}

SortedVector<String>* PlayerObject::getPermissionGroups() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getPermissionGroups();
	}
}

void PlayerObject::addIncapacitationTime() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDINCAPACITATIONTIME__);

		method.executeWithVoidReturn();
	} else {
		_implementation->addIncapacitationTime();
	}
}

byte PlayerObject::getIncapacitationCounter() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETINCAPACITATIONCOUNTER__);

		return method.executeWithByteReturn();
	} else {
		return _implementation->getIncapacitationCounter();
	}
}

void PlayerObject::resetIncapacitationTimes() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_RESETINCAPACITATIONTIMES__);

		method.executeWithVoidReturn();
	} else {
		_implementation->resetIncapacitationTimes();
	}
}

void PlayerObject::addToDuelList(CreatureObject* targetPlayer) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDTODUELLIST__CREATUREOBJECT_);
		method.addObjectParameter(targetPlayer);

		method.executeWithVoidReturn();
	} else {
		_implementation->addToDuelList(targetPlayer);
	}
}

void PlayerObject::removeFromDuelList(CreatureObject* targetPlayer) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEFROMDUELLIST__CREATUREOBJECT_);
		method.addObjectParameter(targetPlayer);

		method.executeWithVoidReturn();
	} else {
		_implementation->removeFromDuelList(targetPlayer);
	}
}

Reference<CreatureObject* > PlayerObject::getDuelListObject(int index) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETDUELLISTOBJECT__INT_);
		method.addSignedIntParameter(index);

		return static_cast<CreatureObject*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getDuelListObject(index);
	}
}

bool PlayerObject::requestedDuelTo(CreatureObject* targetPlayer) const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REQUESTEDDUELTO__CREATUREOBJECT_);
		method.addObjectParameter(targetPlayer);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->requestedDuelTo(targetPlayer);
	}
}

bool PlayerObject::isDuelListEmpty() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISDUELLISTEMPTY__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isDuelListEmpty();
	}
}

int PlayerObject::getDuelListSize() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETDUELLISTSIZE__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getDuelListSize();
	}
}

void PlayerObject::addToActivePets(AiAgent* pet) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDTOACTIVEPETS__AIAGENT_);
		method.addObjectParameter(pet);

		method.executeWithVoidReturn();
	} else {
		_implementation->addToActivePets(pet);
	}
}

void PlayerObject::removeFromActivePets(AiAgent* pet) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEFROMACTIVEPETS__AIAGENT_);
		method.addObjectParameter(pet);

		method.executeWithVoidReturn();
	} else {
		_implementation->removeFromActivePets(pet);
	}
}

AiAgent* PlayerObject::getActivePet(int index) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETACTIVEPET__INT_);
		method.addSignedIntParameter(index);

		return static_cast<AiAgent*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getActivePet(index);
	}
}

bool PlayerObject::hasActivePet(AiAgent* pet) const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASACTIVEPET__AIAGENT_);
		method.addObjectParameter(pet);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasActivePet(pet);
	}
}

int PlayerObject::getActivePetsSize() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETACTIVEPETSSIZE__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getActivePetsSize();
	}
}

UnicodeString PlayerObject::getBiography() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETBIOGRAPHY__);

		UnicodeString _return_getBiography;
		method.executeWithUnicodeReturn(_return_getBiography);
		return _return_getBiography;
	} else {
		return _implementation->getBiography();
	}
}

void PlayerObject::notifyOffline() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_NOTIFYOFFLINE__);

		method.executeWithVoidReturn();
	} else {
		_implementation->notifyOffline();
	}
}

void PlayerObject::resetSessionStats(bool isSessionStart) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_RESETSESSIONSTATS__BOOL_);
		method.addBooleanParameter(isSessionStart);

		method.executeWithVoidReturn();
	} else {
		_implementation->resetSessionStats(isSessionStart);
	}
}

void PlayerObject::incrementSessionMovement(float moveDelta) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_INCREMENTSESSIONMOVEMENT__FLOAT_);
		method.addFloatParameter(moveDelta);

		method.executeWithVoidReturn();
	} else {
		_implementation->incrementSessionMovement(moveDelta);
	}
}

void PlayerObject::logSessionStats(bool isSessionEnd) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_LOGSESSIONSTATS__BOOL_);
		method.addBooleanParameter(isSessionEnd);

		method.executeWithVoidReturn();
	} else {
		_implementation->logSessionStats(isSessionEnd);
	}
}

void PlayerObject::setBadge(unsigned int badge) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETBADGE__INT_);
		method.addUnsignedIntParameter(badge);

		method.executeWithVoidReturn();
	} else {
		_implementation->setBadge(badge);
	}
}

void PlayerObject::revokeBadge(unsigned int badge) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REVOKEBADGE__INT_);
		method.addUnsignedIntParameter(badge);

		method.executeWithVoidReturn();
	} else {
		_implementation->revokeBadge(badge);
	}
}

void PlayerObject::awardBadge(unsigned int badge) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_AWARDBADGE__INT_);
		method.addUnsignedIntParameter(badge);

		method.executeWithVoidReturn();
	} else {
		_implementation->awardBadge(badge);
	}
}

void PlayerObject::setTeleporting(bool val) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETTELEPORTING__BOOL_);
		method.addBooleanParameter(val);

		method.executeWithVoidReturn();
	} else {
		_implementation->setTeleporting(val);
	}
}

void PlayerObject::setOnLoadScreen(bool val) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETONLOADSCREEN__BOOL_);
		method.addBooleanParameter(val);

		method.executeWithVoidReturn();
	} else {
		_implementation->setOnLoadScreen(val);
	}
}

void PlayerObject::setForcedTransform(bool val) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETFORCEDTRANSFORM__BOOL_);
		method.addBooleanParameter(val);

		method.executeWithVoidReturn();
	} else {
		_implementation->setForcedTransform(val);
	}
}

int PlayerObject::getNumBadges() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETNUMBADGES__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getNumBadges();
	}
}

int PlayerObject::getBadgeTypeCount(unsigned int type) const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETBADGETYPECOUNT__INT_);
		method.addUnsignedIntParameter(type);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getBadgeTypeCount(type);
	}
}

bool PlayerObject::hasFriend(const String& name) const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASFRIEND__STRING_);
		method.addAsciiParameter(name);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasFriend(name);
	}
}

int PlayerObject::getFriendListSize() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETFRIENDLISTSIZE__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getFriendListSize();
	}
}

bool PlayerObject::isIgnoring(const String& name) const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISIGNORING__STRING_);
		method.addAsciiParameter(name);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isIgnoring(name);
	}
}

void PlayerObject::addReverseFriend(const String& name) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDREVERSEFRIEND__STRING_);
		method.addAsciiParameter(name);

		method.executeWithVoidReturn();
	} else {
		_implementation->addReverseFriend(name);
	}
}

void PlayerObject::removeReverseFriend(const String& name) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEREVERSEFRIEND__STRING_);
		method.addAsciiParameter(name);

		method.executeWithVoidReturn();
	} else {
		_implementation->removeReverseFriend(name);
	}
}

void PlayerObject::sendFriendLists() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SENDFRIENDLISTS__);

		method.executeWithVoidReturn();
	} else {
		_implementation->sendFriendLists();
	}
}

bool PlayerObject::hasAbility(const String& ability) const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASABILITY__STRING_);
		method.addAsciiParameter(ability);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasAbility(ability);
	}
}

bool PlayerObject::hasCommandMessageString(unsigned int actionCRC) const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASCOMMANDMESSAGESTRING__INT_);
		method.addUnsignedIntParameter(actionCRC);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasCommandMessageString(actionCRC);
	}
}

const PlayerBitmasks* PlayerObject::getPlayerBitmasks() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getPlayerBitmasks();
	}
}

String PlayerObject::getTitle() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETTITLE__);

		String _return_getTitle;
		method.executeWithAsciiReturn(_return_getTitle);
		return _return_getTitle;
	} else {
		return _implementation->getTitle();
	}
}

unsigned int PlayerObject::getAdminLevel() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETADMINLEVEL__);

		return method.executeWithUnsignedIntReturn();
	} else {
		return _implementation->getAdminLevel();
	}
}

void PlayerObject::setAdminLevel(unsigned int adminlvl) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETADMINLEVEL__INT_);
		method.addUnsignedIntParameter(adminlvl);

		method.executeWithVoidReturn();
	} else {
		_implementation->setAdminLevel(adminlvl);
	}
}

int PlayerObject::getPriviledgeFlag() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETPRIVILEDGEFLAG__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getPriviledgeFlag();
	}
}

void PlayerObject::setPriviledgeFlag(int flag) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETPRIVILEDGEFLAG__INT_);
		method.addSignedIntParameter(flag);

		method.executeWithVoidReturn();
	} else {
		_implementation->setPriviledgeFlag(flag);
	}
}

void PlayerObject::setBiography(const UnicodeString& bio) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETBIOGRAPHY__UNICODESTRING_);
		method.addUnicodeParameter(bio);

		method.executeWithVoidReturn();
	} else {
		_implementation->setBiography(bio);
	}
}

bool PlayerObject::hasGodMode() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASGODMODE__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasGodMode();
	}
}

bool PlayerObject::isPrivileged() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISPRIVILEGED__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isPrivileged();
	}
}

bool PlayerObject::isStaff() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISSTAFF__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isStaff();
	}
}

bool PlayerObject::isAdmin() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISADMIN__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isAdmin();
	}
}

bool PlayerObject::setPlayerBit(unsigned int bit, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETPLAYERBIT__INT_BOOL_);
		method.addUnsignedIntParameter(bit);
		method.addBooleanParameter(notifyClient);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->setPlayerBit(bit, notifyClient);
	}
}

bool PlayerObject::clearPlayerBit(unsigned int bit, bool notifyClient) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARPLAYERBIT__INT_BOOL_);
		method.addUnsignedIntParameter(bit);
		method.addBooleanParameter(notifyClient);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->clearPlayerBit(bit, notifyClient);
	}
}

void PlayerObject::toggleCharacterBit(unsigned int bit) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_TOGGLECHARACTERBIT__INT_);
		method.addUnsignedIntParameter(bit);

		method.executeWithVoidReturn();
	} else {
		_implementation->toggleCharacterBit(bit);
	}
}

bool PlayerObject::isLFG() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISLFG__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isLFG();
	}
}

bool PlayerObject::isAFK() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISAFK__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isAFK();
	}
}

bool PlayerObject::isAnonymous() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISANONYMOUS__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isAnonymous();
	}
}

bool PlayerObject::isRoleplayer() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISROLEPLAYER__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isRoleplayer();
	}
}

bool PlayerObject::isNewbieHelper() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISNEWBIEHELPER__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isNewbieHelper();
	}
}

const VectorMap<String, int>* PlayerObject::getXpTypeCapList() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getXpTypeCapList();
	}
}

VectorMap<String, int>* PlayerObject::getXpTypeCapList() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getXpTypeCapList();
	}
}

const DeltaVectorMap<String, int>* PlayerObject::getExperienceList() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getExperienceList();
	}
}

DeltaVectorMap<String, int>* PlayerObject::getExperienceList() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getExperienceList();
	}
}

const DeltaVectorMap<uint32, PlayerQuestData >* PlayerObject::getPlayerQuestsData() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getPlayerQuestsData();
	}
}

const DeltaBitArray* PlayerObject::getActiveQuests() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getActiveQuests();
	}
}

const DeltaBitArray* PlayerObject::getCompletedQuests() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getCompletedQuests();
	}
}

int PlayerObject::getTotalPlayedTime() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETTOTALPLAYEDTIME__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getTotalPlayedTime();
	}
}

int PlayerObject::getForcePower() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETFORCEPOWER__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getForcePower();
	}
}

int PlayerObject::getForcePowerMax() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETFORCEPOWERMAX__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getForcePowerMax();
	}
}

const AbilityList* PlayerObject::getAbilityList() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getAbilityList();
	}
}

FrsData* PlayerObject::getFrsData() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getFrsData();
	}
}

const SchematicList* PlayerObject::getSchematics() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getSchematics();
	}
}

SchematicList* PlayerObject::getSchematics() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getSchematics();
	}
}

DraftSchematic* PlayerObject::getSchematic(int i) const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSCHEMATIC__INT_);
		method.addSignedIntParameter(i);

		return static_cast<DraftSchematic*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getSchematic(i);
	}
}

Vector<ManagedReference<DraftSchematic* > > PlayerObject::filterSchematicList(CreatureObject* player, Vector<unsigned int>* enabledTabs, int complexityLevel) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->filterSchematicList(player, enabledTabs, complexityLevel);
	}
}

int PlayerObject::getFoodFilling() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETFOODFILLING__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getFoodFilling();
	}
}

int PlayerObject::getFoodFillingMax() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETFOODFILLINGMAX__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getFoodFillingMax();
	}
}

int PlayerObject::getDrinkFilling() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETDRINKFILLING__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getDrinkFilling();
	}
}

int PlayerObject::getDrinkFillingMax() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETDRINKFILLINGMAX__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getDrinkFillingMax();
	}
}

int PlayerObject::getJediState() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETJEDISTATE__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getJediState();
	}
}

byte PlayerObject::getLanguageID() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETLANGUAGEID__);

		return method.executeWithByteReturn();
	} else {
		return _implementation->getLanguageID();
	}
}

const DeltaVector<String>* PlayerObject::getFriendList() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getFriendList();
	}
}

bool PlayerObject::isTeleporting() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISTELEPORTING__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isTeleporting();
	}
}

bool PlayerObject::isOnLoadScreen() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISONLOADSCREEN__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isOnLoadScreen();
	}
}

bool PlayerObject::isForcedTransform() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISFORCEDTRANSFORM__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isForcedTransform();
	}
}

void PlayerObject::addChatRoom(unsigned int roomID) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDCHATROOM__INT_);
		method.addUnsignedIntParameter(roomID);

		method.executeWithVoidReturn();
	} else {
		_implementation->addChatRoom(roomID);
	}
}

void PlayerObject::removeChatRoom(unsigned int roomID) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVECHATROOM__INT_);
		method.addUnsignedIntParameter(roomID);

		method.executeWithVoidReturn();
	} else {
		_implementation->removeChatRoom(roomID);
	}
}

void PlayerObject::addOwnedChatRoom(unsigned int roomID) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDOWNEDCHATROOM__INT_);
		method.addUnsignedIntParameter(roomID);

		method.executeWithVoidReturn();
	} else {
		_implementation->addOwnedChatRoom(roomID);
	}
}

void PlayerObject::removeOwnedChatRoom(unsigned int roomID) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEOWNEDCHATROOM__INT_);
		method.addUnsignedIntParameter(roomID);

		method.executeWithVoidReturn();
	} else {
		_implementation->removeOwnedChatRoom(roomID);
	}
}

int PlayerObject::getOwnedChatRoomCount() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETOWNEDCHATROOMCOUNT__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getOwnedChatRoomCount();
	}
}

void PlayerObject::setBankLocation(const String& location) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETBANKLOCATION__STRING_);
		method.addAsciiParameter(location);

		method.executeWithVoidReturn();
	} else {
		_implementation->setBankLocation(location);
	}
}

String PlayerObject::getBankLocation() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETBANKLOCATION__);

		String _return_getBankLocation;
		method.executeWithAsciiReturn(_return_getBankLocation);
		return _return_getBankLocation;
	} else {
		return _implementation->getBankLocation();
	}
}

const DeltaVector<String>* PlayerObject::getIgnoreList() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getIgnoreList();
	}
}

int PlayerObject::getExperience(const String& xp) const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETEXPERIENCE__STRING_);
		method.addAsciiParameter(xp);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getExperience(xp);
	}
}

void PlayerObject::maximizeExperience() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_MAXIMIZEEXPERIENCE__);

		method.executeWithVoidReturn();
	} else {
		_implementation->maximizeExperience();
	}
}

void PlayerObject::activateMissions() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ACTIVATEMISSIONS__);

		method.executeWithVoidReturn();
	} else {
		_implementation->activateMissions();
	}
}

String PlayerObject::getCommandMessageString(unsigned int actionCRC) const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCOMMANDMESSAGESTRING__INT_);
		method.addUnsignedIntParameter(actionCRC);

		String _return_getCommandMessageString;
		method.executeWithAsciiReturn(_return_getCommandMessageString);
		return _return_getCommandMessageString;
	} else {
		return _implementation->getCommandMessageString(actionCRC);
	}
}

bool PlayerObject::hasBadge(unsigned int badge) const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASBADGE__INT_);
		method.addUnsignedIntParameter(badge);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasBadge(badge);
	}
}

void PlayerObject::clearDisconnectEvent() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARDISCONNECTEVENT__);

		method.executeWithVoidReturn();
	} else {
		_implementation->clearDisconnectEvent();
	}
}

bool PlayerObject::isOnline() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISONLINE__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isOnline();
	}
}

bool PlayerObject::isOffline() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISOFFLINE__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isOffline();
	}
}

bool PlayerObject::isLinkDead() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISLINKDEAD__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isLinkDead();
	}
}

bool PlayerObject::isLoggingOut() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISLOGGINGOUT__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isLoggingOut();
	}
}

Time* PlayerObject::getLastLogout() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getLastLogout();
	}
}

int PlayerObject::getDaysSinceLastLogout() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getDaysSinceLastLogout();
	}
}

void PlayerObject::setSkillPoints(int points) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSKILLPOINTS__INT_);
		method.addSignedIntParameter(points);

		method.executeWithVoidReturn();
	} else {
		_implementation->setSkillPoints(points);
	}
}

void PlayerObject::addSkillPoints(int points) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDSKILLPOINTS__INT_);
		method.addSignedIntParameter(points);

		method.executeWithVoidReturn();
	} else {
		_implementation->addSkillPoints(points);
	}
}

int PlayerObject::getSkillPoints() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSKILLPOINTS__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getSkillPoints();
	}
}

void PlayerObject::setLastLogoutWorldPosition(const Vector3& position) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		_implementation->setLastLogoutWorldPosition(position);
	}
}

Vector3 PlayerObject::getLastLogoutWorldPosition() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getLastLogoutWorldPosition();
	}
}

ValidatedPosition* PlayerObject::getLastValidatedPosition() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getLastValidatedPosition();
	}
}

const ValidatedPosition* PlayerObject::getLastValidatedPosition() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getLastValidatedPosition();
	}
}

void PlayerObject::updateLastValidatedPosition() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATELASTVALIDATEDPOSITION__);

		method.executeWithVoidReturn();
	} else {
		_implementation->updateLastValidatedPosition();
	}
}

unsigned int PlayerObject::getAccountID() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETACCOUNTID__);

		return method.executeWithUnsignedIntReturn();
	} else {
		return _implementation->getAccountID();
	}
}

GalaxyAccountInfo* PlayerObject::getGalaxyAccountInfo() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getGalaxyAccountInfo();
	}
}

unsigned long long PlayerObject::getServerMovementTimeDelta() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSERVERMOVEMENTTIMEDELTA__);

		return method.executeWithUnsignedLongReturn();
	} else {
		return _implementation->getServerMovementTimeDelta();
	}
}

Time* PlayerObject::getServerMovementTimeStamp() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getServerMovementTimeStamp();
	}
}

void PlayerObject::setClientLastMovementStamp(unsigned int stamp) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCLIENTLASTMOVEMENTSTAMP__INT_);
		method.addUnsignedIntParameter(stamp);

		method.executeWithVoidReturn();
	} else {
		_implementation->setClientLastMovementStamp(stamp);
	}
}

void PlayerObject::updateServerLastMovementStamp() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATESERVERLASTMOVEMENTSTAMP__);

		method.executeWithVoidReturn();
	} else {
		_implementation->updateServerLastMovementStamp();
	}
}

void PlayerObject::setAccountID(unsigned int id) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETACCOUNTID__INT_);
		method.addUnsignedIntParameter(id);

		method.executeWithVoidReturn();
	} else {
		_implementation->setAccountID(id);
	}
}

unsigned int PlayerObject::getClientLastMovementStamp() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCLIENTLASTMOVEMENTSTAMP__);

		return method.executeWithUnsignedIntReturn();
	} else {
		return _implementation->getClientLastMovementStamp();
	}
}

void PlayerObject::addHologrindProfession(byte prof) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDHOLOGRINDPROFESSION__BYTE_);
		method.addByteParameter(prof);

		method.executeWithVoidReturn();
	} else {
		_implementation->addHologrindProfession(prof);
	}
}

const Vector<byte>* PlayerObject::getHologrindProfessions() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getHologrindProfessions();
	}
}

void PlayerObject::setMaximumLots(byte lots) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETMAXIMUMLOTS__BYTE_);
		method.addByteParameter(lots);

		method.executeWithVoidReturn();
	} else {
		_implementation->setMaximumLots(lots);
	}
}

byte PlayerObject::getMaximumLots() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMAXIMUMLOTS__);

		return method.executeWithByteReturn();
	} else {
		return _implementation->getMaximumLots();
	}
}

String PlayerObject::getStarterProfession() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSTARTERPROFESSION__);

		String _return_getStarterProfession;
		method.executeWithAsciiReturn(_return_getStarterProfession);
		return _return_getStarterProfession;
	} else {
		return _implementation->getStarterProfession();
	}
}

void PlayerObject::setStarterProfession(String& profession) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSTARTERPROFESSION__STRING_);
		method.addAsciiParameter(profession);

		method.executeWithVoidReturn();
	} else {
		_implementation->setStarterProfession(profession);
	}
}

unsigned long long PlayerObject::getPerformanceBuffTarget() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETPERFORMANCEBUFFTARGET__);

		return method.executeWithUnsignedLongReturn();
	} else {
		return _implementation->getPerformanceBuffTarget();
	}
}

void PlayerObject::setPerformanceBuffTarget(unsigned long long target) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETPERFORMANCEBUFFTARGET__LONG_);
		method.addUnsignedLongParameter(target);

		method.executeWithVoidReturn();
	} else {
		_implementation->setPerformanceBuffTarget(target);
	}
}

void PlayerObject::setDebug(bool value) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETDEBUG__BOOL_);
		method.addBooleanParameter(value);

		method.executeWithVoidReturn();
	} else {
		_implementation->setDebug(value);
	}
}

bool PlayerObject::getDebug() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETDEBUG__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->getDebug();
	}
}

float PlayerObject::getVisibility() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETVISIBILITY__);

		return method.executeWithFloatReturn();
	} else {
		return _implementation->getVisibility();
	}
}

void PlayerObject::setVisibility(float value) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETVISIBILITY__FLOAT_);
		method.addFloatParameter(value);

		method.executeWithVoidReturn();
	} else {
		_implementation->setVisibility(value);
	}
}

Time PlayerObject::getLastVisibilityUpdateTimestamp() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getLastVisibilityUpdateTimestamp();
	}
}

Time PlayerObject::getLastBhPvpCombatActionTimestamp() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getLastBhPvpCombatActionTimestamp();
	}
}

Time PlayerObject::getLastGcwPvpCombatActionTimestamp() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getLastGcwPvpCombatActionTimestamp();
	}
}

Time PlayerObject::getLastGcwCrackdownCombatActionTimestamp() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getLastGcwCrackdownCombatActionTimestamp();
	}
}

Time PlayerObject::getLastPvpAreaCombatActionTimestamp() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getLastPvpAreaCombatActionTimestamp();
	}
}

void PlayerObject::updateLastCombatActionTimestamp(bool updateGcwCrackdownAction, bool updateGcwAction, bool updateBhAction) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATELASTCOMBATACTIONTIMESTAMP__BOOL_BOOL_BOOL_);
		method.addBooleanParameter(updateGcwCrackdownAction);
		method.addBooleanParameter(updateGcwAction);
		method.addBooleanParameter(updateBhAction);

		method.executeWithVoidReturn();
	} else {
		_implementation->updateLastCombatActionTimestamp(updateGcwCrackdownAction, updateGcwAction, updateBhAction);
	}
}

void PlayerObject::updateLastBhPvpCombatActionTimestamp() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATELASTBHPVPCOMBATACTIONTIMESTAMP__);

		method.executeWithVoidReturn();
	} else {
		_implementation->updateLastBhPvpCombatActionTimestamp();
	}
}

void PlayerObject::updateLastGcwPvpCombatActionTimestamp() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATELASTGCWPVPCOMBATACTIONTIMESTAMP__);

		method.executeWithVoidReturn();
	} else {
		_implementation->updateLastGcwPvpCombatActionTimestamp();
	}
}

void PlayerObject::updateLastPvpAreaCombatActionTimestamp() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATELASTPVPAREACOMBATACTIONTIMESTAMP__);

		method.executeWithVoidReturn();
	} else {
		_implementation->updateLastPvpAreaCombatActionTimestamp();
	}
}

bool PlayerObject::hasTef() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASTEF__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasTef();
	}
}

bool PlayerObject::hasPvpTef() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASPVPTEF__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasPvpTef();
	}
}

bool PlayerObject::hasGcwTef() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASGCWTEF__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasGcwTef();
	}
}

bool PlayerObject::hasBhTef() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASBHTEF__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasBhTef();
	}
}

void PlayerObject::setCrackdownTefTowards(unsigned int factionCrc, bool scheduleTefRemovalTask) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCRACKDOWNTEFTOWARDS__INT_BOOL_);
		method.addUnsignedIntParameter(factionCrc);
		method.addBooleanParameter(scheduleTefRemovalTask);

		method.executeWithVoidReturn();
	} else {
		_implementation->setCrackdownTefTowards(factionCrc, scheduleTefRemovalTask);
	}
}

bool PlayerObject::hasCrackdownTefTowards(unsigned int factionCrc) const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASCRACKDOWNTEFTOWARDS__INT_);
		method.addUnsignedIntParameter(factionCrc);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasCrackdownTefTowards(factionCrc);
	}
}

bool PlayerObject::hasCrackdownTef() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASCRACKDOWNTEF__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasCrackdownTef();
	}
}

void PlayerObject::schedulePvpTefRemovalTask(bool removeCrackdownGcwTefNow, bool removeGcwTefNow, bool removeBhTefNow) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SCHEDULEPVPTEFREMOVALTASK__BOOL_BOOL_BOOL_);
		method.addBooleanParameter(removeCrackdownGcwTefNow);
		method.addBooleanParameter(removeGcwTefNow);
		method.addBooleanParameter(removeBhTefNow);

		method.executeWithVoidReturn();
	} else {
		_implementation->schedulePvpTefRemovalTask(removeCrackdownGcwTefNow, removeGcwTefNow, removeBhTefNow);
	}
}

void PlayerObject::schedulePvpTefRemovalTask(bool removeNow) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SCHEDULEPVPTEFREMOVALTASK__BOOL_);
		method.addBooleanParameter(removeNow);

		method.executeWithVoidReturn();
	} else {
		_implementation->schedulePvpTefRemovalTask(removeNow);
	}
}

bool PlayerObject::isInPvpArea(bool checkTime) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISINPVPAREA__BOOL_);
		method.addBooleanParameter(checkTime);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isInPvpArea(checkTime);
	}
}

void PlayerObject::addVendor(SceneObject* vendor) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDVENDOR__SCENEOBJECT_);
		method.addObjectParameter(vendor);

		method.executeWithVoidReturn();
	} else {
		_implementation->addVendor(vendor);
	}
}

void PlayerObject::removeVendor(SceneObject* vendor) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEVENDOR__SCENEOBJECT_);
		method.addObjectParameter(vendor);

		method.executeWithVoidReturn();
	} else {
		_implementation->removeVendor(vendor);
	}
}

int PlayerObject::getVendorCount() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETVENDORCOUNT__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getVendorCount();
	}
}

const SortedVector<unsigned long long>* PlayerObject::getOwnedVendors() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getOwnedVendors();
	}
}

void PlayerObject::destroyObjectFromDatabase(bool destroyContainedObjects) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DESTROYOBJECTFROMDATABASE__BOOL_);
		method.addBooleanParameter(destroyContainedObjects);

		method.executeWithVoidReturn();
	} else {
		_implementation->destroyObjectFromDatabase(destroyContainedObjects);
	}
}

void PlayerObject::deleteAllPersistentMessages() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DELETEALLPERSISTENTMESSAGES__);

		method.executeWithVoidReturn();
	} else {
		_implementation->deleteAllPersistentMessages();
	}
}

bool PlayerObject::isJedi() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISJEDI__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isJedi();
	}
}

bool PlayerObject::isJediLight() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISJEDILIGHT__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isJediLight();
	}
}

bool PlayerObject::isJediDark() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISJEDIDARK__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isJediDark();
	}
}

bool PlayerObject::isMuted() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISMUTED__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isMuted();
	}
}

void PlayerObject::setMutedState(bool mute) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETMUTEDSTATE__BOOL_);
		method.addBooleanParameter(mute);

		method.executeWithVoidReturn();
	} else {
		_implementation->setMutedState(mute);
	}
}

String PlayerObject::getMutedReason() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMUTEDREASON__);

		String _return_getMutedReason;
		method.executeWithAsciiReturn(_return_getMutedReason);
		return _return_getMutedReason;
	} else {
		return _implementation->getMutedReason();
	}
}

void PlayerObject::setMutedReason(String& reason) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETMUTEDREASON__STRING_);
		method.addAsciiParameter(reason);

		method.executeWithVoidReturn();
	} else {
		_implementation->setMutedReason(reason);
	}
}

String PlayerObject::getInstalledHoloEmote() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETINSTALLEDHOLOEMOTE__);

		String _return_getInstalledHoloEmote;
		method.executeWithAsciiReturn(_return_getInstalledHoloEmote);
		return _return_getInstalledHoloEmote;
	} else {
		return _implementation->getInstalledHoloEmote();
	}
}

void PlayerObject::setInstalledHoloEmote(String& holoEmote) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETINSTALLEDHOLOEMOTE__STRING_);
		method.addAsciiParameter(holoEmote);

		method.executeWithVoidReturn();
	} else {
		_implementation->setInstalledHoloEmote(holoEmote);
	}
}

void PlayerObject::removeInstalledHoloEmote() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEINSTALLEDHOLOEMOTE__);

		method.executeWithVoidReturn();
	} else {
		_implementation->removeInstalledHoloEmote();
	}
}

int PlayerObject::getHoloEmoteUseCount() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETHOLOEMOTEUSECOUNT__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getHoloEmoteUseCount();
	}
}

void PlayerObject::decreaseHoloEmoteUseCount() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DECREASEHOLOEMOTEUSECOUNT__);

		method.executeWithVoidReturn();
	} else {
		_implementation->decreaseHoloEmoteUseCount();
	}
}

bool PlayerObject::isMarried() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISMARRIED__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isMarried();
	}
}

String PlayerObject::getSpouseName() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSPOUSENAME__);

		String _return_getSpouseName;
		method.executeWithAsciiReturn(_return_getSpouseName);
		return _return_getSpouseName;
	} else {
		return _implementation->getSpouseName();
	}
}

void PlayerObject::setSpouseName(String& firstName) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETSPOUSENAME__STRING_);
		method.addAsciiParameter(firstName);

		method.executeWithVoidReturn();
	} else {
		_implementation->setSpouseName(firstName);
	}
}

void PlayerObject::removeSpouse() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVESPOUSE__);

		method.executeWithVoidReturn();
	} else {
		_implementation->removeSpouse();
	}
}

Account* PlayerObject::getAccount() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETACCOUNT__);

		return static_cast<Account*>(method.executeWithObjectReturn());
	} else {
		return _implementation->getAccount();
	}
}

String PlayerObject::getChosenVeteranReward(unsigned int milestone) const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCHOSENVETERANREWARD__INT_);
		method.addUnsignedIntParameter(milestone);

		String _return_getChosenVeteranReward;
		method.executeWithAsciiReturn(_return_getChosenVeteranReward);
		return _return_getChosenVeteranReward;
	} else {
		return _implementation->getChosenVeteranReward(milestone);
	}
}

bool PlayerObject::hasChosenVeteranReward(const String& rewardTemplate) const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASCHOSENVETERANREWARD__STRING_);
		method.addAsciiParameter(rewardTemplate);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasChosenVeteranReward(rewardTemplate);
	}
}

void PlayerObject::clearVeteranReward(unsigned int milestone) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_CLEARVETERANREWARD__INT_);
		method.addUnsignedIntParameter(milestone);

		method.executeWithVoidReturn();
	} else {
		_implementation->clearVeteranReward(milestone);
	}
}

void PlayerObject::addEventPerk(SceneObject* deed) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDEVENTPERK__SCENEOBJECT_);
		method.addObjectParameter(deed);

		method.executeWithVoidReturn();
	} else {
		_implementation->addEventPerk(deed);
	}
}

void PlayerObject::removeEventPerk(SceneObject* deed) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_REMOVEEVENTPERK__SCENEOBJECT_);
		method.addObjectParameter(deed);

		method.executeWithVoidReturn();
	} else {
		_implementation->removeEventPerk(deed);
	}
}

int PlayerObject::getEventPerkCount() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETEVENTPERKCOUNT__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getEventPerkCount();
	}
}

int PlayerObject::getCharacterAgeInDays() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETCHARACTERAGEINDAYS__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getCharacterAgeInDays();
	}
}

int PlayerObject::getBirthDate() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETBIRTHDATE__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getBirthDate();
	}
}

void PlayerObject::addToReactionFines(int fine) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDTOREACTIONFINES__INT_);
		method.addSignedIntParameter(fine);

		method.executeWithVoidReturn();
	} else {
		_implementation->addToReactionFines(fine);
	}
}

void PlayerObject::setReactionFines(int amount) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETREACTIONFINES__INT_);
		method.addSignedIntParameter(amount);

		method.executeWithVoidReturn();
	} else {
		_implementation->setReactionFines(amount);
	}
}

void PlayerObject::subtractFromReactionFines(int amount) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SUBTRACTFROMREACTIONFINES__INT_);
		method.addSignedIntParameter(amount);

		method.executeWithVoidReturn();
	} else {
		_implementation->subtractFromReactionFines(amount);
	}
}

void PlayerObject::updateReactionFineTimestamp() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATEREACTIONFINETIMESTAMP__);

		method.executeWithVoidReturn();
	} else {
		_implementation->updateReactionFineTimestamp();
	}
}

void PlayerObject::updateReactionFineMailTimestamp() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_UPDATEREACTIONFINEMAILTIMESTAMP__);

		method.executeWithVoidReturn();
	} else {
		_implementation->updateReactionFineMailTimestamp();
	}
}

Time* PlayerObject::getReactionFineTimestamp() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getReactionFineTimestamp();
	}
}

Time* PlayerObject::getReactionFineMailTimestamp() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		throw ObjectNotLocalException(this);

	} else {
		return _implementation->getReactionFineMailTimestamp();
	}
}

int PlayerObject::getXpCap(const String& type) const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETXPCAP__STRING_);
		method.addAsciiParameter(type);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getXpCap(type);
	}
}

int PlayerObject::getSpentJediSkillPoints() {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSPENTJEDISKILLPOINTS__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getSpentJediSkillPoints();
	}
}

bool PlayerObject::hasSchematic(DraftSchematic* schematic) const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASSCHEMATIC__DRAFTSCHEMATIC_);
		method.addObjectParameter(schematic);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasSchematic(schematic);
	}
}

bool PlayerObject::hasEventPerk(const String& templatePath) const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASEVENTPERK__STRING_);
		method.addAsciiParameter(templatePath);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasEventPerk(templatePath);
	}
}

void PlayerObject::doFieldFactionChange(int newStatus) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_DOFIELDFACTIONCHANGE__INT_);
		method.addSignedIntParameter(newStatus);

		method.executeWithVoidReturn();
	} else {
		_implementation->doFieldFactionChange(newStatus);
	}
}

void PlayerObject::addToVictimList(unsigned int playerID) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ADDTOVICTIMLIST__INT_);
		method.addUnsignedIntParameter(playerID);

		method.executeWithVoidReturn();
	} else {
		_implementation->addToVictimList(playerID);
	}
}

bool PlayerObject::hasOnVictimList(unsigned int playerID) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_HASONVICTIMLIST__INT_);
		method.addUnsignedIntParameter(playerID);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->hasOnVictimList(playerID);
	}
}

int PlayerObject::getPvpRating() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETPVPRATING__);

		return method.executeWithSignedIntReturn();
	} else {
		return _implementation->getPvpRating();
	}
}

void PlayerObject::setPvpRating(int rating) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETPVPRATING__INT_);
		method.addSignedIntParameter(rating);

		method.executeWithVoidReturn();
	} else {
		_implementation->setPvpRating(rating);
	}
}

bool PlayerObject::isCloning() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_ISCLONING__);

		return method.executeWithBooleanReturn();
	} else {
		return _implementation->isCloning();
	}
}

void PlayerObject::setCloning(bool val) {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementation());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_SETCLONING__BOOL_);
		method.addBooleanParameter(val);

		method.executeWithVoidReturn();
	} else {
		_implementation->setCloning(val);
	}
}

unsigned long long PlayerObject::getPlayedMiliSecs() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETPLAYEDMILISECS__);

		return method.executeWithUnsignedLongReturn();
	} else {
		return _implementation->getPlayedMiliSecs();
	}
}

unsigned long long PlayerObject::getSessionMiliSecs() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSESSIONMILISECS__);

		return method.executeWithUnsignedLongReturn();
	} else {
		return _implementation->getSessionMiliSecs();
	}
}

unsigned long long PlayerObject::getSessionTotalMovement() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSESSIONTOTALMOVEMENT__);

		return method.executeWithUnsignedLongReturn();
	} else {
		return _implementation->getSessionTotalMovement();
	}
}

long long PlayerObject::getSessionTotalCredits() const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETSESSIONTOTALCREDITS__);

		return method.executeWithSignedLongReturn();
	} else {
		return _implementation->getSessionTotalCredits();
	}
}

String PlayerObject::getMiliSecsTimeString(unsigned long long miliSecs, bool verbose) const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETMILISECSTIMESTRING__LONG_BOOL_);
		method.addUnsignedLongParameter(miliSecs);
		method.addBooleanParameter(verbose);

		String _return_getMiliSecsTimeString;
		method.executeWithAsciiReturn(_return_getMiliSecsTimeString);
		return _return_getMiliSecsTimeString;
	} else {
		return _implementation->getMiliSecsTimeString(miliSecs, verbose);
	}
}

String PlayerObject::getPlayedTimeString(bool verbose) const {
	PlayerObjectImplementation* _implementation = static_cast<PlayerObjectImplementation*>(_getImplementationForRead());
	if (unlikely(_implementation == NULL)) {
		if (!deployed)
			throw ObjectNotDeployedException(this);

		DistributedMethod method(this, RPC_GETPLAYEDTIMESTRING__BOOL_);
		method.addBooleanParameter(verbose);

		String _return_getPlayedTimeString;
		method.executeWithAsciiReturn(_return_getPlayedTimeString);
		return _return_getPlayedTimeString;
	} else {
		return _implementation->getPlayedTimeString(verbose);
	}
}

DistributedObjectServant* PlayerObject::_getImplementation() {

	 if (!_updated) _updated = true;
	return _impl;
}

DistributedObjectServant* PlayerObject::_getImplementationForRead() const {
	return _impl;
}

void PlayerObject::_setImplementation(DistributedObjectServant* servant) {
	_impl = servant;
}

/*
 *	PlayerObjectImplementation
 */

unsigned const long long PlayerObjectImplementation::PVP_RESET_TIME = 259200000;

PlayerObjectImplementation::PlayerObjectImplementation(DummyConstructorParameter* param) : IntangibleObjectImplementation(param) {
	_initializeImplementation();
}


PlayerObjectImplementation::~PlayerObjectImplementation() {
	PlayerObjectImplementation::finalize();
}


void PlayerObjectImplementation::_initializeImplementation() {
	_setClassHelper(PlayerObjectHelper::instance());

	_this = NULL;

	_serializationHelperMethod();
}

void PlayerObjectImplementation::_setStub(DistributedObjectStub* stub) {
	_this = static_cast<PlayerObject*>(stub);
	IntangibleObjectImplementation::_setStub(stub);
}

DistributedObjectStub* PlayerObjectImplementation::_getStub() {
	return _this.get();
}

PlayerObjectImplementation::operator const PlayerObject*() {
	return _this.get();
}

void PlayerObjectImplementation::lock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->lock(doLock);
}

void PlayerObjectImplementation::lock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->lock(obj);
}

void PlayerObjectImplementation::rlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->rlock(doLock);
}

void PlayerObjectImplementation::wlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->wlock(doLock);
}

void PlayerObjectImplementation::wlock(ManagedObject* obj) {
	_this.getReferenceUnsafeStaticCast()->wlock(obj);
}

void PlayerObjectImplementation::unlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->unlock(doLock);
}

void PlayerObjectImplementation::runlock(bool doLock) {
	_this.getReferenceUnsafeStaticCast()->runlock(doLock);
}

void PlayerObjectImplementation::_serializationHelperMethod() {
	IntangibleObjectImplementation::_serializationHelperMethod();

	_setClassName("PlayerObject");

}

void PlayerObjectImplementation::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(PlayerObjectImplementation::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

	initializeTransientMembers();
}

bool PlayerObjectImplementation::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (IntangibleObjectImplementation::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0x63ca6d5f: //PlayerObject.playerLogLevel
		TypeInfo<int >::parseFromBinaryStream(&playerLogLevel, stream);
		return true;

	case 0x3cc091f4: //PlayerObject.playerBitmask
		TypeInfo<PlayerBitmasks >::parseFromBinaryStream(&playerBitmask, stream);
		return true;

	case 0x3f59dd69: //PlayerObject.title
		TypeInfo<String >::parseFromBinaryStream(&title, stream);
		return true;

	case 0x80839c38: //PlayerObject.savedTerrainName
		TypeInfo<String >::parseFromBinaryStream(&savedTerrainName, stream);
		return true;

	case 0x185d8184: //PlayerObject.savedParentID
		TypeInfo<unsigned long long >::parseFromBinaryStream(&savedParentID, stream);
		return true;

	case 0xbf409c6b: //PlayerObject.badges
		TypeInfo<Badges >::parseFromBinaryStream(&badges, stream);
		return true;

	case 0x5747cad2: //PlayerObject.birthDate
		TypeInfo<int >::parseFromBinaryStream(&birthDate, stream);
		return true;

	case 0x6f0f168c: //PlayerObject.forcePower
		TypeInfo<int >::parseFromBinaryStream(&forcePower, stream);
		return true;

	case 0x626f8b12: //PlayerObject.forcePowerMax
		TypeInfo<int >::parseFromBinaryStream(&forcePowerMax, stream);
		return true;

	case 0xd9b9f82b: //PlayerObject.foodFilling
		TypeInfo<int >::parseFromBinaryStream(&foodFilling, stream);
		return true;

	case 0xa5fa3768: //PlayerObject.foodFillingMax
		TypeInfo<int >::parseFromBinaryStream(&foodFillingMax, stream);
		return true;

	case 0xe620a523: //PlayerObject.drinkFilling
		TypeInfo<int >::parseFromBinaryStream(&drinkFilling, stream);
		return true;

	case 0x37da084: //PlayerObject.drinkFillingMax
		TypeInfo<int >::parseFromBinaryStream(&drinkFillingMax, stream);
		return true;

	case 0xe59e7515: //PlayerObject.reactionFines
		TypeInfo<int >::parseFromBinaryStream(&reactionFines, stream);
		return true;

	case 0x911499de: //PlayerObject.reactionFineTimestamp
		TypeInfo<Time >::parseFromBinaryStream(&reactionFineTimestamp, stream);
		return true;

	case 0x89dba2ac: //PlayerObject.reactionFineMailTimestamp
		TypeInfo<Time >::parseFromBinaryStream(&reactionFineMailTimestamp, stream);
		return true;

	case 0x68888ebc: //PlayerObject.starterProfession
		TypeInfo<String >::parseFromBinaryStream(&starterProfession, stream);
		return true;

	case 0xf7e4755e: //PlayerObject.bankLocation
		TypeInfo<String >::parseFromBinaryStream(&bankLocation, stream);
		return true;

	case 0x7a19894f: //PlayerObject.teleporting
		TypeInfo<bool >::parseFromBinaryStream(&teleporting, stream);
		return true;

	case 0xcf0cd987: //PlayerObject.onLoadScreen
		TypeInfo<bool >::parseFromBinaryStream(&onLoadScreen, stream);
		return true;

	case 0xdf6adf19: //PlayerObject.forcedTransform
		TypeInfo<bool >::parseFromBinaryStream(&forcedTransform, stream);
		return true;

	case 0x9af4d57b: //PlayerObject.muted
		TypeInfo<bool >::parseFromBinaryStream(&muted, stream);
		return true;

	case 0x2ba211bc: //PlayerObject.mutedReason
		TypeInfo<String >::parseFromBinaryStream(&mutedReason, stream);
		return true;

	case 0x28863ed2: //PlayerObject.tosVersionAccepted
		TypeInfo<int >::parseFromBinaryStream(&tosVersionAccepted, stream);
		return true;

	case 0x9151f1d3: //PlayerObject.ownedStructures
		TypeInfo<SortedVector<unsigned long long> >::parseFromBinaryStream(&ownedStructures, stream);
		return true;

	case 0x3f521607: //PlayerObject.ownedVendors
		TypeInfo<SortedVector<unsigned long long> >::parseFromBinaryStream(&ownedVendors, stream);
		return true;

	case 0x9c2c0c3f: //PlayerObject.maximumLots
		TypeInfo<byte >::parseFromBinaryStream(&maximumLots, stream);
		return true;

	case 0x39b2b254: //PlayerObject.jediState
		TypeInfo<int >::parseFromBinaryStream(&jediState, stream);
		return true;

	case 0x4d1afa57: //PlayerObject.adminLevel
		TypeInfo<unsigned int >::parseFromBinaryStream(&adminLevel, stream);
		return true;

	case 0xdfba5208: //PlayerObject.priviledgeFlag
		TypeInfo<int >::parseFromBinaryStream(&priviledgeFlag, stream);
		return true;

	case 0x45728d15: //PlayerObject.languageID
		TypeInfo<byte >::parseFromBinaryStream(&languageID, stream);
		return true;

	case 0x3737ff5f: //PlayerObject.xpTypeCapList
		TypeInfo<VectorMap<String, int> >::parseFromBinaryStream(&xpTypeCapList, stream);
		return true;

	case 0x890785df: //PlayerObject.commandMessageStrings
		TypeInfo<VectorMap<unsigned int, String> >::parseFromBinaryStream(&commandMessageStrings, stream);
		return true;

	case 0x33656264: //PlayerObject.experienceList
		TypeInfo<DeltaVectorMap<String, int> >::parseFromBinaryStream(&experienceList, stream);
		return true;

	case 0xbcd9bd05: //PlayerObject.frsData
		TypeInfo<FrsData >::parseFromBinaryStream(&frsData, stream);
		return true;

	case 0xbd209913: //PlayerObject.waypointList
		TypeInfo<WaypointList >::parseFromBinaryStream(&waypointList, stream);
		return true;

	case 0x56e55cb2: //PlayerObject.abilityList
		TypeInfo<AbilityList >::parseFromBinaryStream(&abilityList, stream);
		return true;

	case 0xdab57393: //PlayerObject.friendList
		TypeInfo<FriendList >::parseFromBinaryStream(&friendList, stream);
		return true;

	case 0x4d1f2cfe: //PlayerObject.ignoreList
		TypeInfo<IgnoreList >::parseFromBinaryStream(&ignoreList, stream);
		return true;

	case 0x2ebfed5f: //PlayerObject.factionStandingList
		TypeInfo<FactionStandingList >::parseFromBinaryStream(&factionStandingList, stream);
		return true;

	case 0x42645912: //PlayerObject.schematicList
		TypeInfo<SchematicList >::parseFromBinaryStream(&schematicList, stream);
		return true;

	case 0xb0e1799d: //PlayerObject.incapacitationTimes
		TypeInfo<Vector<unsigned int> >::parseFromBinaryStream(&incapacitationTimes, stream);
		return true;

	case 0xbdbf961a: //PlayerObject.suiBoxNextID
		TypeInfo<unsigned int >::parseFromBinaryStream(&suiBoxNextID, stream);
		return true;

	case 0xe7ec84f4: //PlayerObject.suiBoxes
		TypeInfo<VectorMap<unsigned int, ManagedReference<SuiBox* > > >::parseFromBinaryStream(&suiBoxes, stream);
		return true;

	case 0xfddc58de: //PlayerObject.chatRooms
		TypeInfo<SortedVector<unsigned int> >::parseFromBinaryStream(&chatRooms, stream);
		return true;

	case 0x71d62de1: //PlayerObject.ownedChatRooms
		TypeInfo<SortedVector<unsigned int> >::parseFromBinaryStream(&ownedChatRooms, stream);
		return true;

	case 0xf2a6da3a: //PlayerObject.victimList
		TypeInfo<Vector<unsigned long long> >::parseFromBinaryStream(&victimList, stream);
		return true;

	case 0xa70ae1f1: //PlayerObject.declaredResidence
		TypeInfo<unsigned long long >::parseFromBinaryStream(&declaredResidence, stream);
		return true;

	case 0xb31847ad: //PlayerObject.cloningFacility
		TypeInfo<unsigned long long >::parseFromBinaryStream(&cloningFacility, stream);
		return true;

	case 0xefbabd05: //PlayerObject.isPlayerCloning
		TypeInfo<bool >::parseFromBinaryStream(&isPlayerCloning, stream);
		return true;

	case 0x1c4c135a: //PlayerObject.persistentMessages
		TypeInfo<SortedVector<unsigned long long> >::parseFromBinaryStream(&persistentMessages, stream);
		return true;

	case 0x8fdcc5fd: //PlayerObject.biography
		TypeInfo<UnicodeString >::parseFromBinaryStream(&biography, stream);
		return true;

	case 0x2e39a2da: //PlayerObject.consentList
		TypeInfo<SortedVector<String> >::parseFromBinaryStream(&consentList, stream);
		return true;

	case 0x20094ebc: //PlayerObject.lastNpcConvoMessage
		TypeInfo<String >::parseFromBinaryStream(&lastNpcConvoMessage, stream);
		return true;

	case 0x56616dc4: //PlayerObject.lastNpcConvo
		TypeInfo<String >::parseFromBinaryStream(&lastNpcConvo, stream);
		return true;

	case 0x32b94133: //PlayerObject.lastNpcConvoOptions
		TypeInfo<Vector<String> >::parseFromBinaryStream(&lastNpcConvoOptions, stream);
		return true;

	case 0x5cd36e0f: //PlayerObject.conversatingCreature
		TypeInfo<unsigned long long >::parseFromBinaryStream(&conversatingCreature, stream);
		return true;

	case 0x755815b3: //PlayerObject.trainerCoordinates
		TypeInfo<Vector3 >::parseFromBinaryStream(&trainerCoordinates, stream);
		return true;

	case 0xa3160433: //PlayerObject.lastLogoutWorldPosition
		TypeInfo<Vector3 >::parseFromBinaryStream(&lastLogoutWorldPosition, stream);
		return true;

	case 0x891a3d47: //PlayerObject.trainerZoneName
		TypeInfo<String >::parseFromBinaryStream(&trainerZoneName, stream);
		return true;

	case 0x7645c7d6: //PlayerObject.logoutTimeStamp
		TypeInfo<Time >::parseFromBinaryStream(&logoutTimeStamp, stream);
		return true;

	case 0x377a6e51: //PlayerObject.onlineStatus
		TypeInfo<int >::parseFromBinaryStream(&onlineStatus, stream);
		return true;

	case 0xb10c8ae0: //PlayerObject.skillPoints
		TypeInfo<int >::parseFromBinaryStream(&skillPoints, stream);
		return true;

	case 0xd49b8d6a: //PlayerObject.pvpRating
		TypeInfo<int >::parseFromBinaryStream(&pvpRating, stream);
		return true;

	case 0xd26b2054: //PlayerObject.lastPvpRatingUpdate
		TypeInfo<Time >::parseFromBinaryStream(&lastPvpRatingUpdate, stream);
		return true;

	case 0x908bba87: //PlayerObject.hologrindProfessions
		TypeInfo<Vector<byte> >::parseFromBinaryStream(&hologrindProfessions, stream);
		return true;

	case 0x3166ef65: //PlayerObject.clientLastMovementStamp
		TypeInfo<unsigned int >::parseFromBinaryStream(&clientLastMovementStamp, stream);
		return true;

	case 0x62284a10: //PlayerObject.serverLastMovementStamp
		TypeInfo<Time >::parseFromBinaryStream(&serverLastMovementStamp, stream);
		return true;

	case 0x3b3fbd40: //PlayerObject.lastValidatedPosition
		TypeInfo<ValidatedPosition >::parseFromBinaryStream(&lastValidatedPosition, stream);
		return true;

	case 0x639a0c4f: //PlayerObject.accountID
		TypeInfo<unsigned int >::parseFromBinaryStream(&accountID, stream);
		return true;

	case 0x70fbb795: //PlayerObject.screenPlayData
		TypeInfo<VectorMap<String, String> >::parseFromBinaryStream(&screenPlayData, stream);
		return true;

	case 0x42257652: //PlayerObject.permissionGroups
		TypeInfo<SortedVector<String> >::parseFromBinaryStream(&permissionGroups, stream);
		return true;

	case 0xc7d518a7: //PlayerObject.performanceBuffTarget
		TypeInfo<unsigned long long >::parseFromBinaryStream(&performanceBuffTarget, stream);
		return true;

	case 0xf80402e3: //PlayerObject.debugOutput
		TypeInfo<bool >::parseFromBinaryStream(&debugOutput, stream);
		return true;

	case 0x84d965aa: //PlayerObject.visibility
		TypeInfo<float >::parseFromBinaryStream(&visibility, stream);
		return true;

	case 0xf2ff7f01: //PlayerObject.lastVisibilityUpdateTimestamp
		TypeInfo<Time >::parseFromBinaryStream(&lastVisibilityUpdateTimestamp, stream);
		return true;

	case 0xdd80d638: //PlayerObject.lastBhPvpCombatActionTimestamp
		TypeInfo<Time >::parseFromBinaryStream(&lastBhPvpCombatActionTimestamp, stream);
		return true;

	case 0x12de4676: //PlayerObject.lastGcwPvpCombatActionTimestamp
		TypeInfo<Time >::parseFromBinaryStream(&lastGcwPvpCombatActionTimestamp, stream);
		return true;

	case 0x615d7df2: //PlayerObject.lastCrackdownGcwCombatActionTimestamp
		TypeInfo<Time >::parseFromBinaryStream(&lastCrackdownGcwCombatActionTimestamp, stream);
		return true;

	case 0xa6906852: //PlayerObject.lastPvpAreaCombatActionTimestamp
		TypeInfo<Time >::parseFromBinaryStream(&lastPvpAreaCombatActionTimestamp, stream);
		return true;

	case 0x2dda2fc3: //PlayerObject.crackdownFactionTefCrc
		TypeInfo<unsigned int >::parseFromBinaryStream(&crackdownFactionTefCrc, stream);
		return true;

	case 0x23960f0c: //PlayerObject.lastDigestion
		TypeInfo<Time >::parseFromBinaryStream(&lastDigestion, stream);
		return true;

	case 0xc87e4cfc: //PlayerObject.activePets
		TypeInfo<SortedVector<ManagedReference<AiAgent* > > >::parseFromBinaryStream(&activePets, stream);
		return true;

	case 0x4ce8be67: //PlayerObject.activeQuests
		TypeInfo<DeltaBitArray >::parseFromBinaryStream(&activeQuests, stream);
		return true;

	case 0xa1791985: //PlayerObject.completedQuests
		TypeInfo<DeltaBitArray >::parseFromBinaryStream(&completedQuests, stream);
		return true;

	case 0x842b7659: //PlayerObject.installedHoloEmote
		TypeInfo<String >::parseFromBinaryStream(&installedHoloEmote, stream);
		return true;

	case 0x9b5705cd: //PlayerObject.holoEmoteUseCount
		TypeInfo<int >::parseFromBinaryStream(&holoEmoteUseCount, stream);
		return true;

	case 0x7114f851: //PlayerObject.spouseName
		TypeInfo<String >::parseFromBinaryStream(&spouseName, stream);
		return true;

	case 0x7e9115c8: //PlayerObject.chosenVeteranRewards
		TypeInfo<VectorMap<unsigned int, String> >::parseFromBinaryStream(&chosenVeteranRewards, stream);
		return true;

	case 0xd35e75cf: //PlayerObject.currentEventPerks
		TypeInfo<SortedVector<unsigned long long> >::parseFromBinaryStream(&currentEventPerks, stream);
		return true;

	case 0x52db715b: //PlayerObject.playerQuestsData
		TypeInfo<DeltaVectorMap<uint32, PlayerQuestData > >::parseFromBinaryStream(&playerQuestsData, stream);
		return true;

	case 0x7bed3550: //PlayerObject.miliSecsPlayed
		TypeInfo<unsigned long long >::parseFromBinaryStream(&miliSecsPlayed, stream);
		return true;

	case 0xb1bbc5bb: //PlayerObject.miliSecsSession
		TypeInfo<unsigned long long >::parseFromBinaryStream(&miliSecsSession, stream);
		return true;

	case 0x469b6d7e: //PlayerObject.sessionStatsMiliSecs
		TypeInfo<unsigned long long >::parseFromBinaryStream(&sessionStatsMiliSecs, stream);
		return true;

	}

	return false;
}

void PlayerObjectImplementation::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = PlayerObjectImplementation::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int PlayerObjectImplementation::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = IntangibleObjectImplementation::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	_nameHashCode = 0x63ca6d5f; //PlayerObject.playerLogLevel
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&playerLogLevel, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x3cc091f4; //PlayerObject.playerBitmask
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<PlayerBitmasks >::toBinaryStream(&playerBitmask, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x3f59dd69; //PlayerObject.title
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&title, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x80839c38; //PlayerObject.savedTerrainName
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&savedTerrainName, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x185d8184; //PlayerObject.savedParentID
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&savedParentID, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xbf409c6b; //PlayerObject.badges
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Badges >::toBinaryStream(&badges, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x5747cad2; //PlayerObject.birthDate
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&birthDate, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x6f0f168c; //PlayerObject.forcePower
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&forcePower, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x626f8b12; //PlayerObject.forcePowerMax
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&forcePowerMax, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xd9b9f82b; //PlayerObject.foodFilling
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&foodFilling, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xa5fa3768; //PlayerObject.foodFillingMax
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&foodFillingMax, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xe620a523; //PlayerObject.drinkFilling
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&drinkFilling, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x37da084; //PlayerObject.drinkFillingMax
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&drinkFillingMax, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xe59e7515; //PlayerObject.reactionFines
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&reactionFines, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x911499de; //PlayerObject.reactionFineTimestamp
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Time >::toBinaryStream(&reactionFineTimestamp, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x89dba2ac; //PlayerObject.reactionFineMailTimestamp
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Time >::toBinaryStream(&reactionFineMailTimestamp, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x68888ebc; //PlayerObject.starterProfession
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&starterProfession, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xf7e4755e; //PlayerObject.bankLocation
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&bankLocation, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x7a19894f; //PlayerObject.teleporting
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&teleporting, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xcf0cd987; //PlayerObject.onLoadScreen
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&onLoadScreen, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xdf6adf19; //PlayerObject.forcedTransform
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&forcedTransform, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x9af4d57b; //PlayerObject.muted
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&muted, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x2ba211bc; //PlayerObject.mutedReason
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&mutedReason, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x28863ed2; //PlayerObject.tosVersionAccepted
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&tosVersionAccepted, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x9151f1d3; //PlayerObject.ownedStructures
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<SortedVector<unsigned long long> >::toBinaryStream(&ownedStructures, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x3f521607; //PlayerObject.ownedVendors
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<SortedVector<unsigned long long> >::toBinaryStream(&ownedVendors, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x9c2c0c3f; //PlayerObject.maximumLots
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<byte >::toBinaryStream(&maximumLots, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x39b2b254; //PlayerObject.jediState
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&jediState, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x4d1afa57; //PlayerObject.adminLevel
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned int >::toBinaryStream(&adminLevel, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xdfba5208; //PlayerObject.priviledgeFlag
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&priviledgeFlag, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x45728d15; //PlayerObject.languageID
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<byte >::toBinaryStream(&languageID, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x3737ff5f; //PlayerObject.xpTypeCapList
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<VectorMap<String, int> >::toBinaryStream(&xpTypeCapList, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x890785df; //PlayerObject.commandMessageStrings
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<VectorMap<unsigned int, String> >::toBinaryStream(&commandMessageStrings, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x33656264; //PlayerObject.experienceList
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<DeltaVectorMap<String, int> >::toBinaryStream(&experienceList, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xbcd9bd05; //PlayerObject.frsData
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<FrsData >::toBinaryStream(&frsData, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xbd209913; //PlayerObject.waypointList
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<WaypointList >::toBinaryStream(&waypointList, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x56e55cb2; //PlayerObject.abilityList
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<AbilityList >::toBinaryStream(&abilityList, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xdab57393; //PlayerObject.friendList
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<FriendList >::toBinaryStream(&friendList, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x4d1f2cfe; //PlayerObject.ignoreList
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<IgnoreList >::toBinaryStream(&ignoreList, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x2ebfed5f; //PlayerObject.factionStandingList
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<FactionStandingList >::toBinaryStream(&factionStandingList, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x42645912; //PlayerObject.schematicList
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<SchematicList >::toBinaryStream(&schematicList, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xb0e1799d; //PlayerObject.incapacitationTimes
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector<unsigned int> >::toBinaryStream(&incapacitationTimes, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xbdbf961a; //PlayerObject.suiBoxNextID
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned int >::toBinaryStream(&suiBoxNextID, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xe7ec84f4; //PlayerObject.suiBoxes
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<VectorMap<unsigned int, ManagedReference<SuiBox* > > >::toBinaryStream(&suiBoxes, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xfddc58de; //PlayerObject.chatRooms
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<SortedVector<unsigned int> >::toBinaryStream(&chatRooms, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x71d62de1; //PlayerObject.ownedChatRooms
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<SortedVector<unsigned int> >::toBinaryStream(&ownedChatRooms, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xf2a6da3a; //PlayerObject.victimList
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector<unsigned long long> >::toBinaryStream(&victimList, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xa70ae1f1; //PlayerObject.declaredResidence
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&declaredResidence, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xb31847ad; //PlayerObject.cloningFacility
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&cloningFacility, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xefbabd05; //PlayerObject.isPlayerCloning
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&isPlayerCloning, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x1c4c135a; //PlayerObject.persistentMessages
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<SortedVector<unsigned long long> >::toBinaryStream(&persistentMessages, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x8fdcc5fd; //PlayerObject.biography
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<UnicodeString >::toBinaryStream(&biography, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x2e39a2da; //PlayerObject.consentList
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<SortedVector<String> >::toBinaryStream(&consentList, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x20094ebc; //PlayerObject.lastNpcConvoMessage
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&lastNpcConvoMessage, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x56616dc4; //PlayerObject.lastNpcConvo
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&lastNpcConvo, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x32b94133; //PlayerObject.lastNpcConvoOptions
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector<String> >::toBinaryStream(&lastNpcConvoOptions, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x5cd36e0f; //PlayerObject.conversatingCreature
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&conversatingCreature, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x755815b3; //PlayerObject.trainerCoordinates
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector3 >::toBinaryStream(&trainerCoordinates, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xa3160433; //PlayerObject.lastLogoutWorldPosition
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector3 >::toBinaryStream(&lastLogoutWorldPosition, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x891a3d47; //PlayerObject.trainerZoneName
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&trainerZoneName, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x7645c7d6; //PlayerObject.logoutTimeStamp
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Time >::toBinaryStream(&logoutTimeStamp, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x377a6e51; //PlayerObject.onlineStatus
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&onlineStatus, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xb10c8ae0; //PlayerObject.skillPoints
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&skillPoints, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xd49b8d6a; //PlayerObject.pvpRating
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&pvpRating, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xd26b2054; //PlayerObject.lastPvpRatingUpdate
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Time >::toBinaryStream(&lastPvpRatingUpdate, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x908bba87; //PlayerObject.hologrindProfessions
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector<byte> >::toBinaryStream(&hologrindProfessions, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x3166ef65; //PlayerObject.clientLastMovementStamp
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned int >::toBinaryStream(&clientLastMovementStamp, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x62284a10; //PlayerObject.serverLastMovementStamp
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Time >::toBinaryStream(&serverLastMovementStamp, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x3b3fbd40; //PlayerObject.lastValidatedPosition
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ValidatedPosition >::toBinaryStream(&lastValidatedPosition, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x639a0c4f; //PlayerObject.accountID
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned int >::toBinaryStream(&accountID, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x70fbb795; //PlayerObject.screenPlayData
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<VectorMap<String, String> >::toBinaryStream(&screenPlayData, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x42257652; //PlayerObject.permissionGroups
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<SortedVector<String> >::toBinaryStream(&permissionGroups, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xc7d518a7; //PlayerObject.performanceBuffTarget
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&performanceBuffTarget, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xf80402e3; //PlayerObject.debugOutput
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&debugOutput, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x84d965aa; //PlayerObject.visibility
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&visibility, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xf2ff7f01; //PlayerObject.lastVisibilityUpdateTimestamp
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Time >::toBinaryStream(&lastVisibilityUpdateTimestamp, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xdd80d638; //PlayerObject.lastBhPvpCombatActionTimestamp
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Time >::toBinaryStream(&lastBhPvpCombatActionTimestamp, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x12de4676; //PlayerObject.lastGcwPvpCombatActionTimestamp
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Time >::toBinaryStream(&lastGcwPvpCombatActionTimestamp, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x615d7df2; //PlayerObject.lastCrackdownGcwCombatActionTimestamp
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Time >::toBinaryStream(&lastCrackdownGcwCombatActionTimestamp, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xa6906852; //PlayerObject.lastPvpAreaCombatActionTimestamp
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Time >::toBinaryStream(&lastPvpAreaCombatActionTimestamp, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x2dda2fc3; //PlayerObject.crackdownFactionTefCrc
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned int >::toBinaryStream(&crackdownFactionTefCrc, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x23960f0c; //PlayerObject.lastDigestion
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Time >::toBinaryStream(&lastDigestion, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xc87e4cfc; //PlayerObject.activePets
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<SortedVector<ManagedReference<AiAgent* > > >::toBinaryStream(&activePets, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x4ce8be67; //PlayerObject.activeQuests
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<DeltaBitArray >::toBinaryStream(&activeQuests, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xa1791985; //PlayerObject.completedQuests
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<DeltaBitArray >::toBinaryStream(&completedQuests, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x842b7659; //PlayerObject.installedHoloEmote
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&installedHoloEmote, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x9b5705cd; //PlayerObject.holoEmoteUseCount
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&holoEmoteUseCount, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x7114f851; //PlayerObject.spouseName
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&spouseName, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x7e9115c8; //PlayerObject.chosenVeteranRewards
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<VectorMap<unsigned int, String> >::toBinaryStream(&chosenVeteranRewards, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xd35e75cf; //PlayerObject.currentEventPerks
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<SortedVector<unsigned long long> >::toBinaryStream(&currentEventPerks, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x52db715b; //PlayerObject.playerQuestsData
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<DeltaVectorMap<uint32, PlayerQuestData > >::toBinaryStream(&playerQuestsData, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x7bed3550; //PlayerObject.miliSecsPlayed
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&miliSecsPlayed, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0xb1bbc5bb; //PlayerObject.miliSecsSession
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&miliSecsSession, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;

	_nameHashCode = 0x469b6d7e; //PlayerObject.sessionStatsMiliSecs
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&sessionStatsMiliSecs, stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;


	return _count;
}

void PlayerObjectImplementation::writeJSON(nlohmann::json& j) {
	IntangibleObjectImplementation::writeJSON(j);

	nlohmann::json thisObject = nlohmann::json::object();
	thisObject["playerLogLevel"] = playerLogLevel;

	thisObject["playerBitmask"] = playerBitmask;

	thisObject["title"] = title;

	thisObject["savedTerrainName"] = savedTerrainName;

	thisObject["savedParentID"] = savedParentID;

	thisObject["badges"] = badges;

	thisObject["birthDate"] = birthDate;

	thisObject["forcePower"] = forcePower;

	thisObject["forcePowerMax"] = forcePowerMax;

	thisObject["foodFilling"] = foodFilling;

	thisObject["foodFillingMax"] = foodFillingMax;

	thisObject["drinkFilling"] = drinkFilling;

	thisObject["drinkFillingMax"] = drinkFillingMax;

	thisObject["reactionFines"] = reactionFines;

	thisObject["reactionFineTimestamp"] = reactionFineTimestamp;

	thisObject["reactionFineMailTimestamp"] = reactionFineMailTimestamp;

	thisObject["starterProfession"] = starterProfession;

	thisObject["bankLocation"] = bankLocation;

	thisObject["teleporting"] = teleporting;

	thisObject["onLoadScreen"] = onLoadScreen;

	thisObject["forcedTransform"] = forcedTransform;

	thisObject["muted"] = muted;

	thisObject["mutedReason"] = mutedReason;

	thisObject["tosVersionAccepted"] = tosVersionAccepted;

	thisObject["ownedStructures"] = ownedStructures;

	thisObject["ownedVendors"] = ownedVendors;

	thisObject["maximumLots"] = maximumLots;

	thisObject["jediState"] = jediState;

	thisObject["adminLevel"] = adminLevel;

	thisObject["priviledgeFlag"] = priviledgeFlag;

	thisObject["languageID"] = languageID;

	thisObject["xpTypeCapList"] = xpTypeCapList;

	thisObject["commandMessageStrings"] = commandMessageStrings;

	thisObject["experienceList"] = experienceList;

	thisObject["frsData"] = frsData;

	thisObject["waypointList"] = waypointList;

	thisObject["abilityList"] = abilityList;

	thisObject["friendList"] = friendList;

	thisObject["ignoreList"] = ignoreList;

	thisObject["factionStandingList"] = factionStandingList;

	thisObject["schematicList"] = schematicList;

	thisObject["incapacitationTimes"] = incapacitationTimes;

	thisObject["suiBoxNextID"] = suiBoxNextID;

	thisObject["suiBoxes"] = suiBoxes;

	thisObject["chatRooms"] = chatRooms;

	thisObject["ownedChatRooms"] = ownedChatRooms;

	thisObject["victimList"] = victimList;

	thisObject["declaredResidence"] = declaredResidence;

	thisObject["cloningFacility"] = cloningFacility;

	thisObject["isPlayerCloning"] = isPlayerCloning;

	thisObject["persistentMessages"] = persistentMessages;

	thisObject["biography"] = biography;

	thisObject["consentList"] = consentList;

	thisObject["lastNpcConvoMessage"] = lastNpcConvoMessage;

	thisObject["lastNpcConvo"] = lastNpcConvo;

	thisObject["lastNpcConvoOptions"] = lastNpcConvoOptions;

	thisObject["conversatingCreature"] = conversatingCreature;

	thisObject["trainerCoordinates"] = trainerCoordinates;

	thisObject["lastLogoutWorldPosition"] = lastLogoutWorldPosition;

	thisObject["trainerZoneName"] = trainerZoneName;

	thisObject["logoutTimeStamp"] = logoutTimeStamp;

	thisObject["onlineStatus"] = onlineStatus;

	thisObject["skillPoints"] = skillPoints;

	thisObject["pvpRating"] = pvpRating;

	thisObject["lastPvpRatingUpdate"] = lastPvpRatingUpdate;

	thisObject["hologrindProfessions"] = hologrindProfessions;

	thisObject["clientLastMovementStamp"] = clientLastMovementStamp;

	thisObject["serverLastMovementStamp"] = serverLastMovementStamp;

	thisObject["lastValidatedPosition"] = lastValidatedPosition;

	thisObject["accountID"] = accountID;

	thisObject["screenPlayData"] = screenPlayData;

	thisObject["permissionGroups"] = permissionGroups;

	thisObject["performanceBuffTarget"] = performanceBuffTarget;

	thisObject["debugOutput"] = debugOutput;

	thisObject["visibility"] = visibility;

	thisObject["lastVisibilityUpdateTimestamp"] = lastVisibilityUpdateTimestamp;

	thisObject["lastBhPvpCombatActionTimestamp"] = lastBhPvpCombatActionTimestamp;

	thisObject["lastGcwPvpCombatActionTimestamp"] = lastGcwPvpCombatActionTimestamp;

	thisObject["lastCrackdownGcwCombatActionTimestamp"] = lastCrackdownGcwCombatActionTimestamp;

	thisObject["lastPvpAreaCombatActionTimestamp"] = lastPvpAreaCombatActionTimestamp;

	thisObject["crackdownFactionTefCrc"] = crackdownFactionTefCrc;

	thisObject["lastDigestion"] = lastDigestion;

	thisObject["activePets"] = activePets;

	thisObject["activeQuests"] = activeQuests;

	thisObject["completedQuests"] = completedQuests;

	thisObject["installedHoloEmote"] = installedHoloEmote;

	thisObject["holoEmoteUseCount"] = holoEmoteUseCount;

	thisObject["spouseName"] = spouseName;

	thisObject["chosenVeteranRewards"] = chosenVeteranRewards;

	thisObject["currentEventPerks"] = currentEventPerks;

	thisObject["playerQuestsData"] = playerQuestsData;

	thisObject["miliSecsPlayed"] = miliSecsPlayed;

	thisObject["miliSecsSession"] = miliSecsSession;

	thisObject["sessionStatsMiliSecs"] = sessionStatsMiliSecs;

	j["PlayerObject"] = thisObject;
}

PlayerObjectImplementation::PlayerObjectImplementation() {
	_initializeImplementation();
	// server/zone/objects/player/PlayerObject.idl():  		playerLogLevel = 4;
	playerLogLevel = 4;
	// server/zone/objects/player/PlayerObject.idl():  		commandMessageStrings.setNoDuplicateInsertPlan();
	(&commandMessageStrings)->setNoDuplicateInsertPlan();
	// server/zone/objects/player/PlayerObject.idl():  		bankLocation = "";
	bankLocation = "";
	// server/zone/objects/player/PlayerObject.idl():  		teleporting = false;
	teleporting = false;
	// server/zone/objects/player/PlayerObject.idl():  		onLoadScreen = false;
	onLoadScreen = false;
	// server/zone/objects/player/PlayerObject.idl():  		forcedTransform = false;
	forcedTransform = false;
	// server/zone/objects/player/PlayerObject.idl():  		muted = false;
	muted = false;
	// server/zone/objects/player/PlayerObject.idl():  		mutedReason = "";
	mutedReason = "";
	// server/zone/objects/player/PlayerObject.idl():  		debugOutput = false;
	debugOutput = false;
	// server/zone/objects/player/PlayerObject.idl():  		suiBoxNextID = 0;
	suiBoxNextID = 0;
	// server/zone/objects/player/PlayerObject.idl():  		savedParentID = 0;
	savedParentID = 0;
	// server/zone/objects/player/PlayerObject.idl():  		declaredResidence = 0;
	declaredResidence = 0;
	// server/zone/objects/player/PlayerObject.idl():  		cloningFacility = 0;
	cloningFacility = 0;
	// server/zone/objects/player/PlayerObject.idl():  		isPlayerCloning = false;
	isPlayerCloning = false;
	// server/zone/objects/player/PlayerObject.idl():  		skillPoints = 0;
	skillPoints = 0;
	// server/zone/objects/player/PlayerObject.idl():  		conversatingCreature = 0;
	conversatingCreature = 0;
	// server/zone/objects/player/PlayerObject.idl():  		birthDate = 0;
	birthDate = 0;
	// server/zone/objects/player/PlayerObject.idl():  		forcePower = 0;
	forcePower = 0;
	// server/zone/objects/player/PlayerObject.idl():  		forcePowerMax = 0;
	forcePowerMax = 0;
	// server/zone/objects/player/PlayerObject.idl():  		jediState = 0;
	jediState = 0;
	// server/zone/objects/player/PlayerObject.idl():  		pvpRating = 1200;
	pvpRating = 1200;
	// server/zone/objects/player/PlayerObject.idl():  		trainerZoneName = "";
	trainerZoneName = "";
	// server/zone/objects/player/PlayerObject.idl():  		duelList.setNoDuplicateInsertPlan();
	(&duelList)->setNoDuplicateInsertPlan();
	// server/zone/objects/player/PlayerObject.idl():  		persistentMessages.setNoDuplicateInsertPlan();
	(&persistentMessages)->setNoDuplicateInsertPlan();
	// server/zone/objects/player/PlayerObject.idl():  		consentList.setNoDuplicateInsertPlan();
	(&consentList)->setNoDuplicateInsertPlan();
	// server/zone/objects/player/PlayerObject.idl():  		activePets.setNoDuplicateInsertPlan();
	(&activePets)->setNoDuplicateInsertPlan();
	// server/zone/objects/player/PlayerObject.idl():  		chosenVeteranRewards.setNoDuplicateInsertPlan();
	(&chosenVeteranRewards)->setNoDuplicateInsertPlan();
	// server/zone/objects/player/PlayerObject.idl():  		accountID = 0;
	accountID = 0;
	// server/zone/objects/player/PlayerObject.idl():  		clientLastMovementStamp = 0;
	clientLastMovementStamp = 0;
	// server/zone/objects/player/PlayerObject.idl():  		maximumLots = 10;
	maximumLots = 10;
	// server/zone/objects/player/PlayerObject.idl():  		adminLevel = 0;
	adminLevel = 0;
	// server/zone/objects/player/PlayerObject.idl():  		priviledgeFlag = 0;
	priviledgeFlag = 0;
	// server/zone/objects/player/PlayerObject.idl():  		languageID = 0;
	languageID = 0;
	// server/zone/objects/player/PlayerObject.idl():  		onlineStatus = OFFLINE;
	onlineStatus = OFFLINE;
	// server/zone/objects/player/PlayerObject.idl():  		performanceBuffTarget = 0;
	performanceBuffTarget = 0;
	// server/zone/objects/player/PlayerObject.idl():  		visibility = 0;
	visibility = 0;
	// server/zone/objects/player/PlayerObject.idl():  		lastVisibilityUpdateTimestamp.updateToCurrentTime();
	(&lastVisibilityUpdateTimestamp)->updateToCurrentTime();
	// server/zone/objects/player/PlayerObject.idl():  		lastBhPvpCombatActionTimestamp.updateToCurrentTime();
	(&lastBhPvpCombatActionTimestamp)->updateToCurrentTime();
	// server/zone/objects/player/PlayerObject.idl():  		lastGcwPvpCombatActionTimestamp.updateToCurrentTime();
	(&lastGcwPvpCombatActionTimestamp)->updateToCurrentTime();
	// server/zone/objects/player/PlayerObject.idl():  		lastCrackdownGcwCombatActionTimestamp.updateToCurrentTime();
	(&lastCrackdownGcwCombatActionTimestamp)->updateToCurrentTime();
	// server/zone/objects/player/PlayerObject.idl():  		lastPvpAreaCombatActionTimestamp.updateToCurrentTime();
	(&lastPvpAreaCombatActionTimestamp)->updateToCurrentTime();
	// server/zone/objects/player/PlayerObject.idl():  		crackdownFactionTefCrc = 0;
	crackdownFactionTefCrc = 0;
	// server/zone/objects/player/PlayerObject.idl():  		lastDigestion.updateToCurrentTime();
	(&lastDigestion)->updateToCurrentTime();
	// server/zone/objects/player/PlayerObject.idl():  		installedHoloEmote = "";
	installedHoloEmote = "";
	// server/zone/objects/player/PlayerObject.idl():  		holoEmoteUseCount = 0;
	holoEmoteUseCount = 0;
	// server/zone/objects/player/PlayerObject.idl():  		spouseName = "";
	spouseName = "";
	// server/zone/objects/player/PlayerObject.idl():  		foodFilling = 0;
	foodFilling = 0;
	// server/zone/objects/player/PlayerObject.idl():  		foodFillingMax = 0;
	foodFillingMax = 0;
	// server/zone/objects/player/PlayerObject.idl():  		drinkFilling = 0;
	drinkFilling = 0;
	// server/zone/objects/player/PlayerObject.idl():  		drinkFillingMax = 0;
	drinkFillingMax = 0;
	// server/zone/objects/player/PlayerObject.idl():  		reactionFines = 0;
	reactionFines = 0;
	// server/zone/objects/player/PlayerObject.idl():  		lastPvpRatingUpdate.updateToCurrentTime();
	(&lastPvpRatingUpdate)->updateToCurrentTime();
	// server/zone/objects/player/PlayerObject.idl():  		tosVersionAccepted = 0;
	tosVersionAccepted = 0;
	// server/zone/objects/player/PlayerObject.idl():  		miliSecsPlayed = 0;
	miliSecsPlayed = 0;
	// server/zone/objects/player/PlayerObject.idl():  		Logger.setLoggingName("PlayerObjectBase");
	Logger::setLoggingName("PlayerObjectBase");
}

void PlayerObjectImplementation::finalize() {
}

void PlayerObjectImplementation::setLogLevel(int newLevel) {
	// server/zone/objects/player/PlayerObject.idl():  		playerLogLevel = newLevel;
	playerLogLevel = newLevel;
}

int PlayerObjectImplementation::getLogLevel() const{
	// server/zone/objects/player/PlayerObject.idl():  		return playerLogLevel;
	return playerLogLevel;
}

int PlayerObjectImplementation::getCountMaxCov() const{
	// server/zone/objects/player/PlayerObject.idl():  		return countMaxCov;
	return countMaxCov;
}

void PlayerObjectImplementation::setCountMaxCov(int newMaxCov) {
	// server/zone/objects/player/PlayerObject.idl():  		countMaxCov = newMaxCov;
	countMaxCov = newMaxCov;
}

void PlayerObjectImplementation::setClientPathWaypoint(SceneObject* obj) {
	// server/zone/objects/player/PlayerObject.idl():  		currentClientPathWaypoint = obj;
	currentClientPathWaypoint = obj;
}

void PlayerObjectImplementation::addOwnedStructure(StructureObject* obj) {
	Locker _locker(_this.getReferenceUnsafeStaticCast());
	// server/zone/objects/player/PlayerObject.idl():  		ownedStructures.
	if (!obj)	// server/zone/objects/player/PlayerObject.idl():  			return;
	return;
	// server/zone/objects/player/PlayerObject.idl():  		ownedStructures.put(obj.getObjectID());
	(&ownedStructures)->put(obj->getObjectID());
}

void PlayerObjectImplementation::removeOwnedStructure(StructureObject* obj) {
	Locker _locker(_this.getReferenceUnsafeStaticCast());
	// server/zone/objects/player/PlayerObject.idl():  		ownedStructures.
	if (!obj)	// server/zone/objects/player/PlayerObject.idl():  			return;
	return;
	// server/zone/objects/player/PlayerObject.idl():  		ownedStructures.drop(obj.getObjectID());
	(&ownedStructures)->drop(obj->getObjectID());
	// server/zone/objects/player/PlayerObject.idl():  	}
	if (obj->getObjectID() == getDeclaredResidence())	// server/zone/objects/player/PlayerObject.idl():  			setDeclaredResidence(null);
	setDeclaredResidence(NULL);
}

int PlayerObjectImplementation::getAcceptedTOSVersion() const{
	// server/zone/objects/player/PlayerObject.idl():  		return tosVersionAccepted;
	return tosVersionAccepted;
}

void PlayerObjectImplementation::setAcceptedTOSVersion(int version) {
	// server/zone/objects/player/PlayerObject.idl():  		tosVersionAccepted = version;
	tosVersionAccepted = version;
}

int PlayerObjectImplementation::getTotalOwnedStructureCount() {
	Locker _locker(_this.getReferenceUnsafeStaticCast());
	// server/zone/objects/player/PlayerObject.idl():  		return ownedStructures.size();
	return (&ownedStructures)->size();
}

bool PlayerObjectImplementation::isOwnedStructure(StructureObject* obj) {
	Locker _locker(_this.getReferenceUnsafeStaticCast());
	// server/zone/objects/player/PlayerObject.idl():  		return 
	if (!obj)	// server/zone/objects/player/PlayerObject.idl():  			return false;
	return false;
	// server/zone/objects/player/PlayerObject.idl():  		return ownedStructures.contains(obj.getObjectID());
	return (&ownedStructures)->contains(obj->getObjectID());
}

unsigned long long PlayerObjectImplementation::getOwnedStructure(int i) {
	Locker _locker(_this.getReferenceUnsafeStaticCast());
	// server/zone/objects/player/PlayerObject.idl():  		return ownedStructures.get(i);
	return (&ownedStructures)->get(i);
}

bool PlayerObjectImplementation::hasLotsRemaining(int lots) {
	Locker _locker(_this.getReferenceUnsafeStaticCast());
	// server/zone/objects/player/PlayerObject.idl():  		return lots <= getLotsRemaining();
	return lots <= getLotsRemaining();
}

bool PlayerObjectImplementation::hasWaypoint(unsigned long long objectID) const{
	// server/zone/objects/player/PlayerObject.idl():  		return waypointList.contains(objectID);
	return (&waypointList)->contains(objectID);
}

WaypointObject* PlayerObjectImplementation::getWaypointAt(float x, float y, String& planet) const{
	// server/zone/objects/player/PlayerObject.idl():  		return waypointList.getWaypointAt(x, y, planet);
	return (&waypointList)->getWaypointAt(x, y, planet);
}

void PlayerObjectImplementation::insertWaypointListToMessage(BaseMessage* msg) const{
	// server/zone/objects/player/PlayerObject.idl():  		waypointList.insertToMessage(msg);
	(&waypointList)->insertToMessage(msg);
}

int PlayerObjectImplementation::getWaypointListSize() const{
	// server/zone/objects/player/PlayerObject.idl():  		return waypointList.size();
	return (&waypointList)->size();
}

WaypointObject* PlayerObjectImplementation::getWaypoint(int index) const{
	// server/zone/objects/player/PlayerObject.idl():  		return waypointList.getValueAt(index);
	return (&waypointList)->getValueAt(index);
}

void PlayerObjectImplementation::setScreenPlayData(const String& screenPlay, const String& variable, const String& data) {
	// server/zone/objects/player/PlayerObject.idl():  		screenPlayData.put(screenPlay + "_" + variable, data);
	(&screenPlayData)->put(screenPlay + "_" + variable, data);
}

void PlayerObjectImplementation::deleteScreenPlayData(const String& screenPlay, const String& variable) {
	// server/zone/objects/player/PlayerObject.idl():  		screenPlayData.drop(screenPlay + "_" + variable);
	(&screenPlayData)->drop(screenPlay + "_" + variable);
}

String PlayerObjectImplementation::getScreenPlayData(const String& screenPlay, const String& variable) const{
	// server/zone/objects/player/PlayerObject.idl():  		return screenPlayData.get(screenPlay + "_" + variable);
	return (&screenPlayData)->get(screenPlay + "_" + variable);
}

void PlayerObjectImplementation::clearActiveQuestsBit(int bitIndex, bool notifyClient) {
	// server/zone/objects/player/PlayerObject.idl():  		setActiveQuestsBit(bitIndex, (byte)0, notifyClient);
	setActiveQuestsBit(bitIndex, (byte) 0, notifyClient);
}

bool PlayerObjectImplementation::hasActiveQuestBitSet(int bitIndex) const{
	// server/zone/objects/player/PlayerObject.idl():  		return activeQuests.getBitValue(bitIndex);
	return (&activeQuests)->getBitValue(bitIndex);
}

bool PlayerObjectImplementation::hasCompletedQuestsBitSet(int bitIndex) const{
	// server/zone/objects/player/PlayerObject.idl():  		return completedQuests.getBitValue(bitIndex);
	return (&completedQuests)->getBitValue(bitIndex);
}

void PlayerObjectImplementation::clearCompletedQuestsBit(int bitIndex, bool notifyClient) {
	// server/zone/objects/player/PlayerObject.idl():  		setCompletedQuestsBit(bitIndex, (byte)0, notifyClient);
	setCompletedQuestsBit(bitIndex, (byte) 0, notifyClient);
}

bool PlayerObjectImplementation::hasQuestData(unsigned int questCrc) const{
	// server/zone/objects/player/PlayerObject.idl():  		return playerQuestsData.contains(questCrc);
	return (&playerQuestsData)->contains(questCrc);
}

FactionStandingList* PlayerObjectImplementation::getFactionStandingList() {
	// server/zone/objects/player/PlayerObject.idl():  		return factionStandingList;
	return (&factionStandingList);
}

void PlayerObjectImplementation::setLastNpcConvStr(const String& conv) {
	// server/zone/objects/player/PlayerObject.idl():  		lastNpcConvo = conv;
	lastNpcConvo = conv;
}

void PlayerObjectImplementation::setLastNpcConvMessStr(const String& mess) {
	// server/zone/objects/player/PlayerObject.idl():  		lastNpcConvoMessage = mess;
	lastNpcConvoMessage = mess;
}

String PlayerObjectImplementation::getLastNpcConvStr() const{
	// server/zone/objects/player/PlayerObject.idl():  		return lastNpcConvo;
	return lastNpcConvo;
}

String PlayerObjectImplementation::getLastNpcConvMessStr() const{
	// server/zone/objects/player/PlayerObject.idl():  		return lastNpcConvoMessage;
	return lastNpcConvoMessage;
}

String PlayerObjectImplementation::getLastNpcConvOption(int idx) const{
	// server/zone/objects/player/PlayerObject.idl():  		return lastNpcConvoOptions.get(idx);
	return (&lastNpcConvoOptions)->get(idx);
}

void PlayerObjectImplementation::addLastNpcConvOptions(const String& option) {
	// server/zone/objects/player/PlayerObject.idl():  		lastNpcConvoOptions.add(option);
	(&lastNpcConvoOptions)->add(option);
}

int PlayerObjectImplementation::countLastNpcConvOptions() const{
	// server/zone/objects/player/PlayerObject.idl():  		return lastNpcConvoOptions.size();
	return (&lastNpcConvoOptions)->size();
}

void PlayerObjectImplementation::clearLastNpcConvOptions() {
	// server/zone/objects/player/PlayerObject.idl():  		lastNpcConvoOptions.removeAll();
	(&lastNpcConvoOptions)->removeAll();
}

void PlayerObjectImplementation::setConversatingCreature(CreatureObject* creature) {
	// server/zone/objects/player/PlayerObject.idl():  			conversatingCreature = creature.getObjectID();
	if (!creature)	// server/zone/objects/player/PlayerObject.idl():  			conversatingCreature = 0;
	conversatingCreature = 0;

	else 	// server/zone/objects/player/PlayerObject.idl():  			conversatingCreature = creature.getObjectID();
	conversatingCreature = creature->getObjectID();
}

unsigned long long PlayerObjectImplementation::getConversatingCreature() const{
	// server/zone/objects/player/PlayerObject.idl():  		return conversatingCreature;
	return conversatingCreature;
}

void PlayerObjectImplementation::setTrainerZoneName(String& zoneName) {
	// server/zone/objects/player/PlayerObject.idl():  		trainerZoneName = zoneName;
	trainerZoneName = zoneName;
}

String PlayerObjectImplementation::getTrainerZoneName() const{
	// server/zone/objects/player/PlayerObject.idl():  		return trainerZoneName;
	return trainerZoneName;
}

SortedVector<unsigned long long>* PlayerObjectImplementation::getPersistentMessages() {
	// server/zone/objects/player/PlayerObject.idl():  		return persistentMessages;
	return (&persistentMessages);
}

void PlayerObjectImplementation::addPersistentMessage(unsigned long long id) {
	// server/zone/objects/player/PlayerObject.idl():  		persistentMessages.put(id);
	(&persistentMessages)->put(id);
}

void PlayerObjectImplementation::dropPersistentMessage(unsigned long long id) {
	// server/zone/objects/player/PlayerObject.idl():  		persistentMessages.drop(id);
	(&persistentMessages)->drop(id);
}

void PlayerObjectImplementation::addToConsentList(const String& name) {
	// server/zone/objects/player/PlayerObject.idl():  		consentList.put(name);
	(&consentList)->put(name);
}

bool PlayerObjectImplementation::hasInConsentList(const String& name) const{
	// server/zone/objects/player/PlayerObject.idl():  		return consentList.contains(name);
	return (&consentList)->contains(name);
}

void PlayerObjectImplementation::removeFromConsentList(const String& name) {
	// server/zone/objects/player/PlayerObject.idl():  		consentList.drop(name);
	(&consentList)->drop(name);
}

String PlayerObjectImplementation::getConsentName(int i) const{
	// server/zone/objects/player/PlayerObject.idl():  		return consentList.get(i);
	return (&consentList)->get(i);
}

int PlayerObjectImplementation::getConsentListSize() const{
	// server/zone/objects/player/PlayerObject.idl():  		return consentList.size();
	return (&consentList)->size();
}

int PlayerObjectImplementation::getReactionFines() const{
	// server/zone/objects/player/PlayerObject.idl():  		return reactionFines;
	return reactionFines;
}

String PlayerObjectImplementation::getFactionRank() const{
	// server/zone/objects/player/PlayerObject.idl():  		return factionStandingList.getFactionRank();
	return (&factionStandingList)->getFactionRank();
}

void PlayerObjectImplementation::setFactionRank(const String& rank) {
	// server/zone/objects/player/PlayerObject.idl():  		factionStandingList.setFactionRank(rank);
	(&factionStandingList)->setFactionRank(rank);
}

void PlayerObjectImplementation::setCommandMessageString(unsigned int actionCRC, String& message) {
	// server/zone/objects/player/PlayerObject.idl():  		commandMessageStrings.put(actionCRC, message);
	(&commandMessageStrings)->put(actionCRC, message);
}

void PlayerObjectImplementation::removeCommandMessageString(unsigned int actionCRC) {
	// server/zone/objects/player/PlayerObject.idl():  		commandMessageStrings.drop(actionCRC);
	(&commandMessageStrings)->drop(actionCRC);
}

unsigned long long PlayerObjectImplementation::getDeclaredResidence() const{
	// server/zone/objects/player/PlayerObject.idl():  		return declaredResidence;
	return declaredResidence;
}

void PlayerObjectImplementation::setDeclaredResidence(BuildingObject* residence) {
	// server/zone/objects/player/PlayerObject.idl():  			declaredResidence = residence.getObjectID();
	if (!residence)	// server/zone/objects/player/PlayerObject.idl():  			declaredResidence = 0;
	declaredResidence = 0;

	else 	// server/zone/objects/player/PlayerObject.idl():  			declaredResidence = residence.getObjectID();
	declaredResidence = residence->getObjectID();
}

void PlayerObjectImplementation::setCloningFacility(BuildingObject* cloningfac) {
	// server/zone/objects/player/PlayerObject.idl():  			cloningFacility = cloningfac.getObjectID();
	if (!cloningfac)	// server/zone/objects/player/PlayerObject.idl():  			cloningFacility = 0;
	cloningFacility = 0;

	else 	// server/zone/objects/player/PlayerObject.idl():  			cloningFacility = cloningfac.getObjectID();
	cloningFacility = cloningfac->getObjectID();
}

unsigned long long PlayerObjectImplementation::getCloningFacility() const{
	// server/zone/objects/player/PlayerObject.idl():  		return cloningFacility;
	return cloningFacility;
}

bool PlayerObjectImplementation::isDigesting() const{
	// server/zone/objects/player/PlayerObject.idl():  		}
	if (getDrinkFilling() > 0 || getFoodFilling() > 0){
	// server/zone/objects/player/PlayerObject.idl():  			return true;
	return true;
}

	else {
	// server/zone/objects/player/PlayerObject.idl():  			return false;
	return false;
}
}

String PlayerObjectImplementation::getSavedTerrainName() const{
	// server/zone/objects/player/PlayerObject.idl():  		return savedTerrainName;
	return savedTerrainName;
}

void PlayerObjectImplementation::setSavedParentID(unsigned long long id) {
	// server/zone/objects/player/PlayerObject.idl():  		savedParentID = id;
	savedParentID = id;
}

void PlayerObjectImplementation::setSavedTerrainName(const String& name) {
	// server/zone/objects/player/PlayerObject.idl():  		savedTerrainName = name;
	savedTerrainName = name;
}

void PlayerObjectImplementation::setBirthDate(int date) {
	// server/zone/objects/player/PlayerObject.idl():  		birthDate = date;
	birthDate = date;
}

unsigned long long PlayerObjectImplementation::getSavedParentID() const{
	// server/zone/objects/player/PlayerObject.idl():  		return savedParentID;
	return savedParentID;
}

bool PlayerObjectImplementation::hasSuiBox(unsigned int boxID) const{
	// server/zone/objects/player/PlayerObject.idl():  		return suiBoxes.contains(boxID);
	return (&suiBoxes)->contains(boxID);
}

Reference<SuiBox* > PlayerObjectImplementation::getSuiBox(unsigned int boxID) const{
	// server/zone/objects/player/PlayerObject.idl():  		return suiBoxes.get(boxID);
	return (&suiBoxes)->get(boxID);
}

bool PlayerObjectImplementation::hasSuiBoxWindowType(unsigned int windowType) {
	// server/zone/objects/player/PlayerObject.idl():  		unsigned int type = 0;
	unsigned int type = 0;
	// server/zone/objects/player/PlayerObject.idl():  		}
	for (	// server/zone/objects/player/PlayerObject.idl():  		for (int i = 0;
	int i = 0;
	i < (&suiBoxes)->size();
 ++i) {
	// server/zone/objects/player/PlayerObject.idl():  			SuiBox sui = suiBoxes.get(i);
	ManagedReference<SuiBox* > sui = (&suiBoxes)->get(i);
	// server/zone/objects/player/PlayerObject.idl():  			type = sui.getWindowType();
	type = sui->getWindowType();
	// server/zone/objects/player/PlayerObject.idl():  		}
	if (windowType == type)	// server/zone/objects/player/PlayerObject.idl():  				return true;
	return true;
}
	// server/zone/objects/player/PlayerObject.idl():  		return false;
	return false;
}

void PlayerObjectImplementation::closeSuiWindowType(unsigned int windowType) {
	// server/zone/objects/player/PlayerObject.idl():  	}
	if (hasSuiBoxWindowType(windowType)){
	// server/zone/objects/player/PlayerObject.idl():  			SuiBox sui = getSuiBoxFromWindowType(windowType);
	ManagedReference<SuiBox* > sui = getSuiBoxFromWindowType(windowType);
	// server/zone/objects/player/PlayerObject.idl():  		}
	if (sui){
	// server/zone/objects/player/PlayerObject.idl():  				sendMessage(sui.generateCloseMessage());
	sendMessage(sui->generateCloseMessage());
	// server/zone/objects/player/PlayerObject.idl():  				removeSuiBox(sui.getBoxID());
	removeSuiBox(sui->getBoxID());
}
}
}

Reference<SuiBox* > PlayerObjectImplementation::getSuiBoxFromWindowType(unsigned int windowType) {
	// server/zone/objects/player/PlayerObject.idl():  		unsigned int type = 0;
	unsigned int type = 0;
	// server/zone/objects/player/PlayerObject.idl():  		}
	for (	// server/zone/objects/player/PlayerObject.idl():  		for (int i = 0;
	int i = 0;
	i < (&suiBoxes)->size();
 ++i) {
	// server/zone/objects/player/PlayerObject.idl():  			SuiBox sui = suiBoxes.get(i);
	ManagedReference<SuiBox* > sui = (&suiBoxes)->get(i);
	// server/zone/objects/player/PlayerObject.idl():  		}
	if (windowType == sui->getWindowType())	// server/zone/objects/player/PlayerObject.idl():  				return sui;
	return sui;
}
	// server/zone/objects/player/PlayerObject.idl():  		return null;
	return NULL;
}

void PlayerObjectImplementation::addSuiBox(SuiBox* sui) {
	// server/zone/objects/player/PlayerObject.idl():  		unsigned int key = sui.getBoxID();
	unsigned int key = sui->getBoxID();
	// server/zone/objects/player/PlayerObject.idl():  		suiBoxes.put(key, sui);
	(&suiBoxes)->put(key, sui);
}

SortedVector<String>* PlayerObjectImplementation::getPermissionGroups() {
	// server/zone/objects/player/PlayerObject.idl():  		return permissionGroups;
	return (&permissionGroups);
}

byte PlayerObjectImplementation::getIncapacitationCounter() const{
	// server/zone/objects/player/PlayerObject.idl():  		return incapacitationTimes.size();
	return (&incapacitationTimes)->size();
}

void PlayerObjectImplementation::resetIncapacitationTimes() {
	// server/zone/objects/player/PlayerObject.idl():  		incapacitationTimes.removeAll();
	(&incapacitationTimes)->removeAll();
}

void PlayerObjectImplementation::addToDuelList(CreatureObject* targetPlayer) {
	// server/zone/objects/player/PlayerObject.idl():  		duelList.put(targetPlayer);
	(&duelList)->put(targetPlayer);
}

void PlayerObjectImplementation::removeFromDuelList(CreatureObject* targetPlayer) {
	// server/zone/objects/player/PlayerObject.idl():  		duelList.drop(targetPlayer);
	(&duelList)->drop(targetPlayer);
}

Reference<CreatureObject* > PlayerObjectImplementation::getDuelListObject(int index) {
	// server/zone/objects/player/PlayerObject.idl():  		return duelList.get(index);
	return (&duelList)->get(index);
}

bool PlayerObjectImplementation::requestedDuelTo(CreatureObject* targetPlayer) const{
	// server/zone/objects/player/PlayerObject.idl():  		return duelList.contains(targetPlayer);
	return (&duelList)->contains(targetPlayer);
}

bool PlayerObjectImplementation::isDuelListEmpty() const{
	// server/zone/objects/player/PlayerObject.idl():  		return duelList.isEmpty();
	return (&duelList)->isEmpty();
}

int PlayerObjectImplementation::getDuelListSize() const{
	// server/zone/objects/player/PlayerObject.idl():  		return duelList.size();
	return (&duelList)->size();
}

void PlayerObjectImplementation::addToActivePets(AiAgent* pet) {
	// server/zone/objects/player/PlayerObject.idl():  		activePets.put(pet);
	(&activePets)->put(pet);
}

void PlayerObjectImplementation::removeFromActivePets(AiAgent* pet) {
	// server/zone/objects/player/PlayerObject.idl():  		activePets.drop(pet);
	(&activePets)->drop(pet);
}

AiAgent* PlayerObjectImplementation::getActivePet(int index) {
	// server/zone/objects/player/PlayerObject.idl():  		return activePets.get(index);
	return (&activePets)->get(index);
}

bool PlayerObjectImplementation::hasActivePet(AiAgent* pet) const{
	// server/zone/objects/player/PlayerObject.idl():  		return activePets.contains(pet);
	return (&activePets)->contains(pet);
}

int PlayerObjectImplementation::getActivePetsSize() const{
	// server/zone/objects/player/PlayerObject.idl():  		return activePets.size();
	return (&activePets)->size();
}

UnicodeString PlayerObjectImplementation::getBiography() const{
	// server/zone/objects/player/PlayerObject.idl():  		return biography;
	return biography;
}

void PlayerObjectImplementation::setBadge(unsigned int badge) {
	// server/zone/objects/player/PlayerObject.idl():  		badges.setBadge(badge);
	(&badges)->setBadge(badge);
}

void PlayerObjectImplementation::revokeBadge(unsigned int badge) {
	// server/zone/objects/player/PlayerObject.idl():  		badges.unsetBadge(badge);
	(&badges)->unsetBadge(badge);
}

void PlayerObjectImplementation::setTeleporting(bool val) {
	// server/zone/objects/player/PlayerObject.idl():  		teleporting = val;
	teleporting = val;
}

void PlayerObjectImplementation::setOnLoadScreen(bool val) {
	// server/zone/objects/player/PlayerObject.idl():  		onLoadScreen = val;
	onLoadScreen = val;
}

void PlayerObjectImplementation::setForcedTransform(bool val) {
	// server/zone/objects/player/PlayerObject.idl():  		forcedTransform = val;
	forcedTransform = val;
}

int PlayerObjectImplementation::getNumBadges() const{
	// server/zone/objects/player/PlayerObject.idl():  		return badges.getNumBadges();
	return (&badges)->getNumBadges();
}

int PlayerObjectImplementation::getBadgeTypeCount(unsigned int type) const{
	// server/zone/objects/player/PlayerObject.idl():  		return badges.getTypeCount(type);
	return (&badges)->getTypeCount(type);
}

bool PlayerObjectImplementation::hasFriend(const String& name) const{
	// server/zone/objects/player/PlayerObject.idl():  		return friendList.contains(name);
	return (&friendList)->contains(name);
}

int PlayerObjectImplementation::getFriendListSize() const{
	// server/zone/objects/player/PlayerObject.idl():  		return friendList.size();
	return (&friendList)->size();
}

void PlayerObjectImplementation::addReverseFriend(const String& name) {
	// server/zone/objects/player/PlayerObject.idl():  		friendList.addReversePlayer(name);
	(&friendList)->addReversePlayer(name);
}

void PlayerObjectImplementation::removeReverseFriend(const String& name) {
	// server/zone/objects/player/PlayerObject.idl():  		friendList.removeReversePlayer(name);
	(&friendList)->removeReversePlayer(name);
}

bool PlayerObjectImplementation::hasAbility(const String& ability) const{
	// server/zone/objects/player/PlayerObject.idl():  		return abilityList.contains(ability);
	return (&abilityList)->contains(ability);
}

bool PlayerObjectImplementation::hasCommandMessageString(unsigned int actionCRC) const{
	// server/zone/objects/player/PlayerObject.idl():  		return commandMessageStrings.contains(actionCRC);
	return (&commandMessageStrings)->contains(actionCRC);
}

const PlayerBitmasks* PlayerObjectImplementation::getPlayerBitmasks() const{
	// server/zone/objects/player/PlayerObject.idl():  		return playerBitmask;
	return (&playerBitmask);
}

String PlayerObjectImplementation::getTitle() const{
	// server/zone/objects/player/PlayerObject.idl():  		return title;
	return title;
}

unsigned int PlayerObjectImplementation::getAdminLevel() const{
	// server/zone/objects/player/PlayerObject.idl():  		return adminLevel;
	return adminLevel;
}

void PlayerObjectImplementation::setAdminLevel(unsigned int adminlvl) {
	// server/zone/objects/player/PlayerObject.idl():  		adminLevel = adminlvl;
	adminLevel = adminlvl;
}

int PlayerObjectImplementation::getPriviledgeFlag() const{
	// server/zone/objects/player/PlayerObject.idl():  		return priviledgeFlag;
	return priviledgeFlag;
}

void PlayerObjectImplementation::setPriviledgeFlag(int flag) {
	// server/zone/objects/player/PlayerObject.idl():  		priviledgeFlag = flag;
	priviledgeFlag = flag;
}

void PlayerObjectImplementation::setBiography(const UnicodeString& bio) {
	// server/zone/objects/player/PlayerObject.idl():  		biography = bio;
	biography = bio;
}

bool PlayerObjectImplementation::hasGodMode() const{
	// server/zone/objects/player/PlayerObject.idl():  		return (adminLevel > 0 && hasAbility("admin"));
	return (adminLevel > 0 && hasAbility("admin"));
}

bool PlayerObjectImplementation::isPrivileged() const{
	// server/zone/objects/player/PlayerObject.idl():  		return (adminLevel > 6 && hasAbility("admin"));
	return (adminLevel > 6 && hasAbility("admin"));
}

bool PlayerObjectImplementation::isStaff() const{
	// server/zone/objects/player/PlayerObject.idl():  		return (adminLevel > 10 && hasAbility("admin"));
	return (adminLevel > 10 && hasAbility("admin"));
}

bool PlayerObjectImplementation::isAdmin() const{
	// server/zone/objects/player/PlayerObject.idl():  		return (adminLevel == 15 && hasAbility("admin"));
	return (adminLevel == 15 && hasAbility("admin"));
}

const VectorMap<String, int>* PlayerObjectImplementation::getXpTypeCapList() const{
	// server/zone/objects/player/PlayerObject.idl():  	 return xpTypeCapList;
	return (&xpTypeCapList);
}

VectorMap<String, int>* PlayerObjectImplementation::getXpTypeCapList() {
	// server/zone/objects/player/PlayerObject.idl():  	 return xpTypeCapList;
	return (&xpTypeCapList);
}

const DeltaVectorMap<String, int>* PlayerObjectImplementation::getExperienceList() const{
	// server/zone/objects/player/PlayerObject.idl():  		return experienceList;
	return (&experienceList);
}

DeltaVectorMap<String, int>* PlayerObjectImplementation::getExperienceList() {
	// server/zone/objects/player/PlayerObject.idl():  		return experienceList;
	return (&experienceList);
}

const DeltaVectorMap<uint32, PlayerQuestData >* PlayerObjectImplementation::getPlayerQuestsData() const{
	// server/zone/objects/player/PlayerObject.idl():  		return playerQuestsData;
	return (&playerQuestsData);
}

const DeltaBitArray* PlayerObjectImplementation::getActiveQuests() const{
	// server/zone/objects/player/PlayerObject.idl():  		return activeQuests;
	return (&activeQuests);
}

const DeltaBitArray* PlayerObjectImplementation::getCompletedQuests() const{
	// server/zone/objects/player/PlayerObject.idl():  		return completedQuests;
	return (&completedQuests);
}

int PlayerObjectImplementation::getTotalPlayedTime() const{
	// server/zone/objects/player/PlayerObject.idl():  		int totalTime = miliSecsPlayed / 1000 / 30;
	int totalTime = miliSecsPlayed / 1000 / 30;
	// server/zone/objects/player/PlayerObject.idl():  		return totalTime;
	return totalTime;
}

int PlayerObjectImplementation::getForcePower() const{
	// server/zone/objects/player/PlayerObject.idl():  		return forcePower;
	return forcePower;
}

int PlayerObjectImplementation::getForcePowerMax() const{
	// server/zone/objects/player/PlayerObject.idl():  		return forcePowerMax;
	return forcePowerMax;
}

const AbilityList* PlayerObjectImplementation::getAbilityList() const{
	// server/zone/objects/player/PlayerObject.idl():  		return abilityList;
	return (&abilityList);
}

FrsData* PlayerObjectImplementation::getFrsData() {
	// server/zone/objects/player/PlayerObject.idl():  		return frsData;
	return (&frsData);
}

const SchematicList* PlayerObjectImplementation::getSchematics() const{
	// server/zone/objects/player/PlayerObject.idl():  		return schematicList;
	return (&schematicList);
}

SchematicList* PlayerObjectImplementation::getSchematics() {
	// server/zone/objects/player/PlayerObject.idl():  		return schematicList;
	return (&schematicList);
}

DraftSchematic* PlayerObjectImplementation::getSchematic(int i) const{
	// server/zone/objects/player/PlayerObject.idl():  		return schematicList.get(i);
	return (&schematicList)->get(i);
}

int PlayerObjectImplementation::getFoodFilling() const{
	// server/zone/objects/player/PlayerObject.idl():  		return foodFilling;
	return foodFilling;
}

int PlayerObjectImplementation::getFoodFillingMax() const{
	// server/zone/objects/player/PlayerObject.idl():  		return foodFillingMax;
	return foodFillingMax;
}

int PlayerObjectImplementation::getDrinkFilling() const{
	// server/zone/objects/player/PlayerObject.idl():  		return drinkFilling;
	return drinkFilling;
}

int PlayerObjectImplementation::getDrinkFillingMax() const{
	// server/zone/objects/player/PlayerObject.idl():  		return drinkFillingMax;
	return drinkFillingMax;
}

int PlayerObjectImplementation::getJediState() const{
	// server/zone/objects/player/PlayerObject.idl():  		return jediState;
	return jediState;
}

byte PlayerObjectImplementation::getLanguageID() const{
	// server/zone/objects/player/PlayerObject.idl():  		return languageID;
	return languageID;
}

const DeltaVector<String>* PlayerObjectImplementation::getFriendList() const{
	// server/zone/objects/player/PlayerObject.idl():  		return friendList;
	return (&friendList);
}

bool PlayerObjectImplementation::isTeleporting() const{
	// server/zone/objects/player/PlayerObject.idl():  		return teleporting;
	return teleporting;
}

bool PlayerObjectImplementation::isOnLoadScreen() const{
	// server/zone/objects/player/PlayerObject.idl():  		return onLoadScreen;
	return onLoadScreen;
}

bool PlayerObjectImplementation::isForcedTransform() const{
	// server/zone/objects/player/PlayerObject.idl():  		return forcedTransform;
	return forcedTransform;
}

void PlayerObjectImplementation::addChatRoom(unsigned int roomID) {
	// server/zone/objects/player/PlayerObject.idl():  		chatRooms.put(roomID);
	(&chatRooms)->put(roomID);
}

void PlayerObjectImplementation::removeChatRoom(unsigned int roomID) {
	// server/zone/objects/player/PlayerObject.idl():  		chatRooms.drop(roomID);
	(&chatRooms)->drop(roomID);
}

void PlayerObjectImplementation::addOwnedChatRoom(unsigned int roomID) {
	// server/zone/objects/player/PlayerObject.idl():  		ownedChatRooms.put(roomID);
	(&ownedChatRooms)->put(roomID);
}

void PlayerObjectImplementation::removeOwnedChatRoom(unsigned int roomID) {
	// server/zone/objects/player/PlayerObject.idl():  		ownedChatRooms.drop(roomID);
	(&ownedChatRooms)->drop(roomID);
}

void PlayerObjectImplementation::setBankLocation(const String& location) {
	// server/zone/objects/player/PlayerObject.idl():  		bankLocation = location;
	bankLocation = location;
}

String PlayerObjectImplementation::getBankLocation() const{
	// server/zone/objects/player/PlayerObject.idl():  		return bankLocation;
	return bankLocation;
}

const DeltaVector<String>* PlayerObjectImplementation::getIgnoreList() const{
	// server/zone/objects/player/PlayerObject.idl():  		return ignoreList;
	return (&ignoreList);
}

int PlayerObjectImplementation::getExperience(const String& xp) const{
	// server/zone/objects/player/PlayerObject.idl():  		}
	if ((&experienceList)->contains(xp)){
	// server/zone/objects/player/PlayerObject.idl():  			return experienceList.get(xp);
	return (&experienceList)->get(xp);
}

	else {
	// server/zone/objects/player/PlayerObject.idl():  			return 0;
	return 0;
}
}

String PlayerObjectImplementation::getCommandMessageString(unsigned int actionCRC) const{
	// server/zone/objects/player/PlayerObject.idl():  		return commandMessageStrings.get(actionCRC);
	return (&commandMessageStrings)->get(actionCRC);
}

bool PlayerObjectImplementation::hasBadge(unsigned int badge) const{
	// server/zone/objects/player/PlayerObject.idl():  		return badges.hasBadge(badge);
	return (&badges)->hasBadge(badge);
}

bool PlayerObjectImplementation::isOnline() const{
	// server/zone/objects/player/PlayerObject.idl():  		return onlineStatus != OFFLINE && onlineStatus != LINKDEAD;
	return onlineStatus != OFFLINE && onlineStatus != LINKDEAD;
}

bool PlayerObjectImplementation::isOffline() const{
	// server/zone/objects/player/PlayerObject.idl():  		return onlineStatus == OFFLINE;
	return onlineStatus == OFFLINE;
}

bool PlayerObjectImplementation::isLinkDead() const{
	// server/zone/objects/player/PlayerObject.idl():  		return onlineStatus == LINKDEAD;
	return onlineStatus == LINKDEAD;
}

bool PlayerObjectImplementation::isLoggingOut() const{
	// server/zone/objects/player/PlayerObject.idl():  		return onlineStatus == LOGGINGOUT;
	return onlineStatus == LOGGINGOUT;
}

Time* PlayerObjectImplementation::getLastLogout() {
	// server/zone/objects/player/PlayerObject.idl():  		return logoutTimeStamp;
	return (&logoutTimeStamp);
}

int PlayerObjectImplementation::getDaysSinceLastLogout() const{
	// server/zone/objects/player/PlayerObject.idl():  		return (int)(logoutTimeStamp.miliDifference() / 1000 / 60 / 60 / 24);
	return (int) ((&logoutTimeStamp)->miliDifference() / 1000 / 60 / 60 / 24);
}

void PlayerObjectImplementation::setSkillPoints(int points) {
	// server/zone/objects/player/PlayerObject.idl():  		skillPoints = points;
	skillPoints = points;
}

void PlayerObjectImplementation::addSkillPoints(int points) {
	// server/zone/objects/player/PlayerObject.idl():  		skillPoints += points;
	skillPoints += points;
}

int PlayerObjectImplementation::getSkillPoints() const{
	// server/zone/objects/player/PlayerObject.idl():  		return skillPoints;
	return skillPoints;
}

ValidatedPosition* PlayerObjectImplementation::getLastValidatedPosition() {
	// server/zone/objects/player/PlayerObject.idl():  		return lastValidatedPosition;
	return (&lastValidatedPosition);
}

const ValidatedPosition* PlayerObjectImplementation::getLastValidatedPosition() const{
	// server/zone/objects/player/PlayerObject.idl():  		return lastValidatedPosition;
	return (&lastValidatedPosition);
}

void PlayerObjectImplementation::updateLastValidatedPosition() {
	// server/zone/objects/player/PlayerObject.idl():  		SceneObject par = super.getParent();
	ManagedReference<SceneObject* > par = IntangibleObjectImplementation::getParent();
	// server/zone/objects/player/PlayerObject.idl():  		lastValidatedPosition.update(par);
	(&lastValidatedPosition)->update(par);
	// server/zone/objects/player/PlayerObject.idl():  		serverLastMovementStamp.updateToCurrentTime();
	(&serverLastMovementStamp)->updateToCurrentTime();
}

unsigned int PlayerObjectImplementation::getAccountID() const{
	// server/zone/objects/player/PlayerObject.idl():  		return accountID;
	return accountID;
}

GalaxyAccountInfo* PlayerObjectImplementation::getGalaxyAccountInfo() const{
	// server/zone/objects/player/PlayerObject.idl():  		return galaxyAccountInfo;
	return galaxyAccountInfo;
}

unsigned long long PlayerObjectImplementation::getServerMovementTimeDelta() const{
	// server/zone/objects/player/PlayerObject.idl():  		return serverLastMovementStamp.miliDifference();
	return (&serverLastMovementStamp)->miliDifference();
}

Time* PlayerObjectImplementation::getServerMovementTimeStamp() {
	// server/zone/objects/player/PlayerObject.idl():  		return serverLastMovementStamp;
	return (&serverLastMovementStamp);
}

void PlayerObjectImplementation::setClientLastMovementStamp(unsigned int stamp) {
	// server/zone/objects/player/PlayerObject.idl():  		clientLastMovementStamp = stamp;
	clientLastMovementStamp = stamp;
}

void PlayerObjectImplementation::updateServerLastMovementStamp() {
	// server/zone/objects/player/PlayerObject.idl():  		serverLastMovementStamp.updateToCurrentTime();
	(&serverLastMovementStamp)->updateToCurrentTime();
}

void PlayerObjectImplementation::setAccountID(unsigned int id) {
	// server/zone/objects/player/PlayerObject.idl():  		accountID = id;
	accountID = id;
}

unsigned int PlayerObjectImplementation::getClientLastMovementStamp() const{
	// server/zone/objects/player/PlayerObject.idl():  		return clientLastMovementStamp;
	return clientLastMovementStamp;
}

void PlayerObjectImplementation::addHologrindProfession(byte prof) {
	// server/zone/objects/player/PlayerObject.idl():  		hologrindProfessions.add(prof);
	(&hologrindProfessions)->add(prof);
}

const Vector<byte>* PlayerObjectImplementation::getHologrindProfessions() const{
	// server/zone/objects/player/PlayerObject.idl():  		return hologrindProfessions;
	return (&hologrindProfessions);
}

void PlayerObjectImplementation::setMaximumLots(byte lots) {
	// server/zone/objects/player/PlayerObject.idl():  		maximumLots = lots;
	maximumLots = lots;
}

byte PlayerObjectImplementation::getMaximumLots() const{
	// server/zone/objects/player/PlayerObject.idl():  		return maximumLots;
	return maximumLots;
}

String PlayerObjectImplementation::getStarterProfession() const{
	// server/zone/objects/player/PlayerObject.idl():  		return starterProfession;
	return starterProfession;
}

void PlayerObjectImplementation::setStarterProfession(String& profession) {
	// server/zone/objects/player/PlayerObject.idl():  		starterProfession = profession;
	starterProfession = profession;
}

unsigned long long PlayerObjectImplementation::getPerformanceBuffTarget() const{
	// server/zone/objects/player/PlayerObject.idl():  		return performanceBuffTarget;
	return performanceBuffTarget;
}

void PlayerObjectImplementation::setPerformanceBuffTarget(unsigned long long target) {
	// server/zone/objects/player/PlayerObject.idl():  		performanceBuffTarget = target;
	performanceBuffTarget = target;
}

void PlayerObjectImplementation::setDebug(bool value) {
	// server/zone/objects/player/PlayerObject.idl():  		debugOutput = value;
	debugOutput = value;
}

bool PlayerObjectImplementation::getDebug() const{
	// server/zone/objects/player/PlayerObject.idl():  		return debugOutput;
	return debugOutput;
}

float PlayerObjectImplementation::getVisibility() const{
	// server/zone/objects/player/PlayerObject.idl():  		return visibility;
	return visibility;
}

void PlayerObjectImplementation::setVisibility(float value) {
	// server/zone/objects/player/PlayerObject.idl():  		visibility = value;
	visibility = value;
	// server/zone/objects/player/PlayerObject.idl():  		lastVisibilityUpdateTimestamp.updateToCurrentTime();
	(&lastVisibilityUpdateTimestamp)->updateToCurrentTime();
}

void PlayerObjectImplementation::addVendor(SceneObject* vendor) {
	// server/zone/objects/player/PlayerObject.idl():  		ownedVendors.add(vendor.getObjectID());
	(&ownedVendors)->add(vendor->getObjectID());
}

void PlayerObjectImplementation::removeVendor(SceneObject* vendor) {
	// server/zone/objects/player/PlayerObject.idl():  		ownedVendors.removeElement(vendor.getObjectID());
	(&ownedVendors)->removeElement(vendor->getObjectID());
}

const SortedVector<unsigned long long>* PlayerObjectImplementation::getOwnedVendors() const{
	// server/zone/objects/player/PlayerObject.idl():  		return ownedVendors;
	return (&ownedVendors);
}

bool PlayerObjectImplementation::isJedi() const{
	// server/zone/objects/player/PlayerObject.idl():  		return jediState >= 2;
	return jediState >= 2;
}

bool PlayerObjectImplementation::isJediLight() const{
	// server/zone/objects/player/PlayerObject.idl():  		return jediState == 4;
	return jediState == 4;
}

bool PlayerObjectImplementation::isJediDark() const{
	// server/zone/objects/player/PlayerObject.idl():  		return jediState == 8;
	return jediState == 8;
}

bool PlayerObjectImplementation::isMuted() const{
	// server/zone/objects/player/PlayerObject.idl():  		return muted;
	return muted;
}

void PlayerObjectImplementation::setMutedState(bool mute) {
	// server/zone/objects/player/PlayerObject.idl():  		muted = mute;
	muted = mute;
}

String PlayerObjectImplementation::getMutedReason() const{
	// server/zone/objects/player/PlayerObject.idl():  		return mutedReason;
	return mutedReason;
}

void PlayerObjectImplementation::setMutedReason(String& reason) {
	// server/zone/objects/player/PlayerObject.idl():  		mutedReason = reason;
	mutedReason = reason;
}

String PlayerObjectImplementation::getInstalledHoloEmote() const{
	// server/zone/objects/player/PlayerObject.idl():  		return installedHoloEmote;
	return installedHoloEmote;
}

void PlayerObjectImplementation::setInstalledHoloEmote(String& holoEmote) {
	// server/zone/objects/player/PlayerObject.idl():  		installedHoloEmote = holoEmote;
	installedHoloEmote = holoEmote;
	// server/zone/objects/player/PlayerObject.idl():  		holoEmoteUseCount = 20;
	holoEmoteUseCount = 20;
}

void PlayerObjectImplementation::removeInstalledHoloEmote() {
	// server/zone/objects/player/PlayerObject.idl():  		installedHoloEmote = "";
	installedHoloEmote = "";
	// server/zone/objects/player/PlayerObject.idl():  		holoEmoteUseCount = 0;
	holoEmoteUseCount = 0;
}

int PlayerObjectImplementation::getHoloEmoteUseCount() const{
	// server/zone/objects/player/PlayerObject.idl():  		return holoEmoteUseCount;
	return holoEmoteUseCount;
}

void PlayerObjectImplementation::decreaseHoloEmoteUseCount() {
	// server/zone/objects/player/PlayerObject.idl():  		holoEmoteUseCount = holoEmoteUseCount - 1;
	holoEmoteUseCount = holoEmoteUseCount - 1;
	// server/zone/objects/player/PlayerObject.idl():  	}
	if (holoEmoteUseCount < 0)	// server/zone/objects/player/PlayerObject.idl():  			holoEmoteUseCount = 0;
	holoEmoteUseCount = 0;
}

bool PlayerObjectImplementation::isMarried() const{
	// server/zone/objects/player/PlayerObject.idl():  		return spouseName != "";
	return spouseName != "";
}

String PlayerObjectImplementation::getSpouseName() const{
	// server/zone/objects/player/PlayerObject.idl():  		return spouseName;
	return spouseName;
}

void PlayerObjectImplementation::setSpouseName(String& firstName) {
	// server/zone/objects/player/PlayerObject.idl():  		 spouseName = firstName;
	spouseName = firstName;
}

void PlayerObjectImplementation::removeSpouse() {
	// server/zone/objects/player/PlayerObject.idl():  		spouseName = "";
	spouseName = "";
}

Account* PlayerObjectImplementation::getAccount() {
	// server/zone/objects/player/PlayerObject.idl():  		return account;
	return account;
}

String PlayerObjectImplementation::getChosenVeteranReward(unsigned int milestone) const{
	// server/zone/objects/player/PlayerObject.idl():  		return galaxyAccountInfo.getChosenVeteranReward(milestone);
	return galaxyAccountInfo->getChosenVeteranReward(milestone);
}

bool PlayerObjectImplementation::hasChosenVeteranReward(const String& rewardTemplate) const{
	// server/zone/objects/player/PlayerObject.idl():  		return galaxyAccountInfo.hasChosenVeteranReward(rewardTemplate);
	return galaxyAccountInfo->hasChosenVeteranReward(rewardTemplate);
}

void PlayerObjectImplementation::clearVeteranReward(unsigned int milestone) {
	// server/zone/objects/player/PlayerObject.idl():  		galaxyAccountInfo.clearVeteranReward(milestone);
	galaxyAccountInfo->clearVeteranReward(milestone);
}

void PlayerObjectImplementation::addEventPerk(SceneObject* deed) {
	// server/zone/objects/player/PlayerObject.idl():  		currentEventPerks.put(deed.getObjectID());
	(&currentEventPerks)->put(deed->getObjectID());
}

void PlayerObjectImplementation::removeEventPerk(SceneObject* deed) {
	// server/zone/objects/player/PlayerObject.idl():  		currentEventPerks.drop(deed.getObjectID());
	(&currentEventPerks)->drop(deed->getObjectID());
}

int PlayerObjectImplementation::getEventPerkCount() const{
	// server/zone/objects/player/PlayerObject.idl():  		return currentEventPerks.size();
	return (&currentEventPerks)->size();
}

void PlayerObjectImplementation::addToReactionFines(int fine) {
	// server/zone/objects/player/PlayerObject.idl():  		reactionFines = reactionFines + fine;
	reactionFines = reactionFines + fine;
}

void PlayerObjectImplementation::setReactionFines(int amount) {
	// server/zone/objects/player/PlayerObject.idl():  		reactionFines = amount;
	reactionFines = amount;
}

void PlayerObjectImplementation::subtractFromReactionFines(int amount) {
	// server/zone/objects/player/PlayerObject.idl():  		reactionFines = reactionFines - amount;
	reactionFines = reactionFines - amount;
}

void PlayerObjectImplementation::updateReactionFineTimestamp() {
	// server/zone/objects/player/PlayerObject.idl():  		reactionFineTimestamp.updateToCurrentTime();
	(&reactionFineTimestamp)->updateToCurrentTime();
}

void PlayerObjectImplementation::updateReactionFineMailTimestamp() {
	// server/zone/objects/player/PlayerObject.idl():  		reactionFineMailTimestamp.updateToCurrentTime();
	(&reactionFineMailTimestamp)->updateToCurrentTime();
}

Time* PlayerObjectImplementation::getReactionFineTimestamp() {
	// server/zone/objects/player/PlayerObject.idl():  		return reactionFineTimestamp;
	return (&reactionFineTimestamp);
}

Time* PlayerObjectImplementation::getReactionFineMailTimestamp() {
	// server/zone/objects/player/PlayerObject.idl():  		return reactionFineMailTimestamp;
	return (&reactionFineMailTimestamp);
}

int PlayerObjectImplementation::getXpCap(const String& type) const{
	// server/zone/objects/player/PlayerObject.idl():  		return xpTypeCapList.get(type);
	return (&xpTypeCapList)->get(type);
}

bool PlayerObjectImplementation::hasSchematic(DraftSchematic* schematic) const{
	// server/zone/objects/player/PlayerObject.idl():  		return schematicList.contains(schematic);
	return (&schematicList)->contains(schematic);
}

void PlayerObjectImplementation::addToVictimList(unsigned int playerID) {
	// server/zone/objects/player/PlayerObject.idl():  		victimList.
	if ((&lastPvpRatingUpdate)->miliDifference() >= PVP_RESET_TIME && (&victimList)->size() > 0)	// server/zone/objects/player/PlayerObject.idl():  			victimList.removeAll();
	(&victimList)->removeAll();
	// server/zone/objects/player/PlayerObject.idl():  		victimList.add(0, playerID);
	(&victimList)->add(0, playerID);
	// server/zone/objects/player/PlayerObject.idl():  		lastPvpRatingUpdate.
	if ((&victimList)->size() > 20)	// server/zone/objects/player/PlayerObject.idl():  			victimList.remove(victimList.size() - 1);
	(&victimList)->remove((&victimList)->size() - 1);
	// server/zone/objects/player/PlayerObject.idl():  		lastPvpRatingUpdate.updateToCurrentTime();
	(&lastPvpRatingUpdate)->updateToCurrentTime();
}

bool PlayerObjectImplementation::hasOnVictimList(unsigned int playerID) {
	Locker _locker(_this.getReferenceUnsafeStaticCast());
	// server/zone/objects/player/PlayerObject.idl():  		return 
	if ((&lastPvpRatingUpdate)->miliDifference() >= PVP_RESET_TIME && (&victimList)->size() > 0){
	// server/zone/objects/player/PlayerObject.idl():  			victimList.removeAll();
	(&victimList)->removeAll();
	// server/zone/objects/player/PlayerObject.idl():  			return false;
	return false;
}
	// server/zone/objects/player/PlayerObject.idl():  		return victimList.contains(playerID);
	return (&victimList)->contains(playerID);
}

int PlayerObjectImplementation::getPvpRating() const{
	// server/zone/objects/player/PlayerObject.idl():  		return 
	if (pvpRating == 0)	// server/zone/objects/player/PlayerObject.idl():  			return 1200;
	return 1200;
	// server/zone/objects/player/PlayerObject.idl():  		return pvpRating;
	return pvpRating;
}

void PlayerObjectImplementation::setPvpRating(int rating) {
	// server/zone/objects/player/PlayerObject.idl():  		pvpRating 
	if (rating < PVP_RATING_FLOOR)	// server/zone/objects/player/PlayerObject.idl():  			rating = PVP_RATING_FLOOR;
	rating = PVP_RATING_FLOOR;
	// server/zone/objects/player/PlayerObject.idl():  		pvpRating = rating;
	pvpRating = rating;
}

bool PlayerObjectImplementation::isCloning() const{
	// server/zone/objects/player/PlayerObject.idl():  		return isPlayerCloning;
	return isPlayerCloning;
}

void PlayerObjectImplementation::setCloning(bool val) {
	// server/zone/objects/player/PlayerObject.idl():  		isPlayerCloning = val;
	isPlayerCloning = val;
}

unsigned long long PlayerObjectImplementation::getPlayedMiliSecs() const{
	// server/zone/objects/player/PlayerObject.idl():  		return miliSecsPlayed;
	return miliSecsPlayed;
}

unsigned long long PlayerObjectImplementation::getSessionMiliSecs() const{
	// server/zone/objects/player/PlayerObject.idl():  		return miliSecsSession;
	return miliSecsSession;
}

unsigned long long PlayerObjectImplementation::getSessionTotalMovement() const{
	// server/zone/objects/player/PlayerObject.idl():  		return sessionStatsTotalMovement;
	return sessionStatsTotalMovement;
}

long long PlayerObjectImplementation::getSessionTotalCredits() const{
	// server/zone/objects/player/PlayerObject.idl():  	 return sessionStatsTotalCredits;
	return sessionStatsTotalCredits;
}

/*
 *	PlayerObjectAdapter
 */


#include "engine/orb/messages/InvokeMethodMessage.h"


PlayerObjectAdapter::PlayerObjectAdapter(PlayerObject* obj) : IntangibleObjectAdapter(obj) {
}

void PlayerObjectAdapter::invokeMethod(uint32 methid, DistributedMethod* inv) {
	DOBMessage* resp = inv->getInvocationMessage();

	switch (methid) {
	case RPC_FINALIZE__:
		{
			
			finalize();
			
		}
		break;
	case RPC_SETLOGLEVEL__INT_:
		{
			int newLevel = inv->getSignedIntParameter();
			
			setLogLevel(newLevel);
			
		}
		break;
	case RPC_GETLOGLEVEL__:
		{
			
			int _m_res = getLogLevel();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETCOUNTMAXCOV__:
		{
			
			int _m_res = getCountMaxCov();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_SETCOUNTMAXCOV__INT_:
		{
			int newMaxCov = inv->getSignedIntParameter();
			
			setCountMaxCov(newMaxCov);
			
		}
		break;
	case RPC_SETCLIENTPATHWAYPOINT__SCENEOBJECT_:
		{
			SceneObject* obj = static_cast<SceneObject*>(inv->getObjectParameter());
			
			setClientPathWaypoint(obj);
			
		}
		break;
	case RPC_INITIALIZEACCOUNT__:
		{
			
			initializeAccount();
			
		}
		break;
	case RPC_NOTIFYLOADFROMDATABASE__:
		{
			
			notifyLoadFromDatabase();
			
		}
		break;
	case RPC_UNLOAD__:
		{
			
			unload();
			
		}
		break;
	case RPC_CALCULATEBHREWARD__:
		{
			
			int _m_res = calculateBhReward();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_INITIALIZETRANSIENTMEMBERS__:
		{
			
			initializeTransientMembers();
			
		}
		break;
	case RPC_SENDBASELINESTO__SCENEOBJECT_:
		{
			SceneObject* player = static_cast<SceneObject*>(inv->getObjectParameter());
			
			sendBaselinesTo(player);
			
		}
		break;
	case RPC_ADDOWNEDSTRUCTURE__STRUCTUREOBJECT_:
		{
			StructureObject* obj = static_cast<StructureObject*>(inv->getObjectParameter());
			
			addOwnedStructure(obj);
			
		}
		break;
	case RPC_REMOVEOWNEDSTRUCTURE__STRUCTUREOBJECT_:
		{
			StructureObject* obj = static_cast<StructureObject*>(inv->getObjectParameter());
			
			removeOwnedStructure(obj);
			
		}
		break;
	case RPC_GETACCEPTEDTOSVERSION__:
		{
			
			int _m_res = getAcceptedTOSVersion();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_SETACCEPTEDTOSVERSION__INT_:
		{
			int version = inv->getSignedIntParameter();
			
			setAcceptedTOSVersion(version);
			
		}
		break;
	case RPC_CHECKANDSHOWTOS__:
		{
			
			checkAndShowTOS();
			
		}
		break;
	case RPC_CREATEHELPERDROID__:
		{
			
			createHelperDroid();
			
		}
		break;
	case RPC_GETTOTALOWNEDSTRUCTURECOUNT__:
		{
			
			int _m_res = getTotalOwnedStructureCount();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_ISOWNEDSTRUCTURE__STRUCTUREOBJECT_:
		{
			StructureObject* obj = static_cast<StructureObject*>(inv->getObjectParameter());
			
			bool _m_res = isOwnedStructure(obj);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETOWNEDSTRUCTURE__INT_:
		{
			int i = inv->getSignedIntParameter();
			
			unsigned long long _m_res = getOwnedStructure(i);
			resp->insertLong(_m_res);
		}
		break;
	case RPC_GETLOTSREMAINING__:
		{
			
			int _m_res = getLotsRemaining();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_HASLOTSREMAINING__INT_:
		{
			int lots = inv->getSignedIntParameter();
			
			bool _m_res = hasLotsRemaining(lots);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_NOTIFYSCENEREADY__:
		{
			
			notifySceneReady();
			
		}
		break;
	case RPC_CHECKPENDINGMESSAGES__:
		{
			
			checkPendingMessages();
			
		}
		break;
	case RPC_HASCAPPEDEXPERIENCE__STRING_:
		{
			 String xpType; inv->getAsciiParameter(xpType);
			
			bool _m_res = hasCappedExperience(xpType);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ADDWAYPOINT__WAYPOINTOBJECT_BOOL_BOOL_:
		{
			WaypointObject* waypoint = static_cast<WaypointObject*>(inv->getObjectParameter());
			bool checkName = inv->getBooleanParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			addWaypoint(waypoint, checkName, notifyClient);
			
		}
		break;
	case RPC_SETWAYPOINT__WAYPOINTOBJECT_BOOL_:
		{
			WaypointObject* waypoint = static_cast<WaypointObject*>(inv->getObjectParameter());
			bool notifyClient = inv->getBooleanParameter();
			
			setWaypoint(waypoint, notifyClient);
			
		}
		break;
	case RPC_REMOVEWAYPOINT__LONG_BOOL_BOOL_:
		{
			unsigned long long waypointID = inv->getUnsignedLongParameter();
			bool notifyClient = inv->getBooleanParameter();
			bool destroy = inv->getBooleanParameter();
			
			removeWaypoint(waypointID, notifyClient, destroy);
			
		}
		break;
	case RPC_UPDATEWAYPOINT__LONG_:
		{
			unsigned long long waypointID = inv->getUnsignedLongParameter();
			
			updateWaypoint(waypointID);
			
		}
		break;
	case RPC_REMOVEWAYPOINTBYSPECIALTYPE__INT_BOOL_:
		{
			int specialTypeID = inv->getSignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			removeWaypointBySpecialType(specialTypeID, notifyClient);
			
		}
		break;
	case RPC_GETWAYPOINTBYSPECIALTYPE__INT_:
		{
			int specialTypeID = inv->getSignedIntParameter();
			
			DistributedObject* _m_res = getWaypointBySpecialType(specialTypeID);
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_GETSURVEYWAYPOINT__:
		{
			
			DistributedObject* _m_res = getSurveyWaypoint();
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_HASWAYPOINT__LONG_:
		{
			unsigned long long objectID = inv->getUnsignedLongParameter();
			
			bool _m_res = hasWaypoint(objectID);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETWAYPOINTAT__FLOAT_FLOAT_STRING_:
		{
			float x = inv->getFloatParameter();
			float y = inv->getFloatParameter();
			String planet; inv->getAsciiParameter(planet);
			
			DistributedObject* _m_res = getWaypointAt(x, y, planet);
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_GETWAYPOINTLISTSIZE__:
		{
			
			int _m_res = getWaypointListSize();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETWAYPOINT__INT_:
		{
			int index = inv->getSignedIntParameter();
			
			DistributedObject* _m_res = getWaypoint(index);
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_SETLANGUAGEID__BYTE_BOOL_:
		{
			byte language = inv->getByteParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setLanguageID(language, notifyClient);
			
		}
		break;
	case RPC_ADDFRIEND__STRING_BOOL_:
		{
			 String name; inv->getAsciiParameter(name);
			bool notifyClient = inv->getBooleanParameter();
			
			addFriend(name, notifyClient);
			
		}
		break;
	case RPC_REMOVEFRIEND__STRING_BOOL_:
		{
			 String name; inv->getAsciiParameter(name);
			bool notifyClient = inv->getBooleanParameter();
			
			removeFriend(name, notifyClient);
			
		}
		break;
	case RPC_REMOVEALLREVERSEFRIENDS__STRING_:
		{
			 String oldName; inv->getAsciiParameter(oldName);
			
			removeAllReverseFriends(oldName);
			
		}
		break;
	case RPC_ADDIGNORE__STRING_BOOL_:
		{
			 String name; inv->getAsciiParameter(name);
			bool notifyClient = inv->getBooleanParameter();
			
			addIgnore(name, notifyClient);
			
		}
		break;
	case RPC_REMOVEIGNORE__STRING_BOOL_:
		{
			 String name; inv->getAsciiParameter(name);
			bool notifyClient = inv->getBooleanParameter();
			
			removeIgnore(name, notifyClient);
			
		}
		break;
	case RPC_SETTITLE__STRING_BOOL_:
		{
			 String characterTitle; inv->getAsciiParameter(characterTitle);
			bool notifyClient = inv->getBooleanParameter();
			
			setTitle(characterTitle, notifyClient);
			
		}
		break;
	case RPC_SETFOODFILLING__INT_BOOL_:
		{
			int newValue = inv->getSignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setFoodFilling(newValue, notifyClient);
			
		}
		break;
	case RPC_SETDRINKFILLING__INT_BOOL_:
		{
			int newValue = inv->getSignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setDrinkFilling(newValue, notifyClient);
			
		}
		break;
	case RPC_INCREASEFACTIONSTANDING__STRING_FLOAT_:
		{
			 String factionName; inv->getAsciiParameter(factionName);
			float amount = inv->getFloatParameter();
			
			increaseFactionStanding(factionName, amount);
			
		}
		break;
	case RPC_GIVECOABONUS__STRING_FLOAT_FLOAT_:
		{
			 String factionName; inv->getAsciiParameter(factionName);
			float amount = inv->getFloatParameter();
			float currentStanding = inv->getFloatParameter();
			
			giveCoaBonus(factionName, amount, currentStanding);
			
		}
		break;
	case RPC_DECREASEFACTIONSTANDING__STRING_FLOAT_:
		{
			 String factionName; inv->getAsciiParameter(factionName);
			float amount = inv->getFloatParameter();
			
			decreaseFactionStanding(factionName, amount);
			
		}
		break;
	case RPC_SETFACTIONSTANDING__STRING_FLOAT_:
		{
			 String factionName; inv->getAsciiParameter(factionName);
			float amount = inv->getFloatParameter();
			
			setFactionStanding(factionName, amount);
			
		}
		break;
	case RPC_GETFACTIONSTANDING__STRING_:
		{
			 String factionName; inv->getAsciiParameter(factionName);
			
			float _m_res = getFactionStanding(factionName);
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_SETSCREENPLAYDATA__STRING_STRING_STRING_:
		{
			 String screenPlay; inv->getAsciiParameter(screenPlay);
			 String variable; inv->getAsciiParameter(variable);
			 String data; inv->getAsciiParameter(data);
			
			setScreenPlayData(screenPlay, variable, data);
			
		}
		break;
	case RPC_DELETESCREENPLAYDATA__STRING_STRING_:
		{
			 String screenPlay; inv->getAsciiParameter(screenPlay);
			 String variable; inv->getAsciiParameter(variable);
			
			deleteScreenPlayData(screenPlay, variable);
			
		}
		break;
	case RPC_GETSCREENPLAYDATA__STRING_STRING_:
		{
			 String screenPlay; inv->getAsciiParameter(screenPlay);
			 String variable; inv->getAsciiParameter(variable);
			
			String _m_res = getScreenPlayData(screenPlay, variable);
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_CLEARSCREENPLAYDATA__STRING_:
		{
			 String screenPlay; inv->getAsciiParameter(screenPlay);
			
			clearScreenPlayData(screenPlay);
			
		}
		break;
	case RPC_ACTIVATERECOVERY__:
		{
			
			activateRecovery();
			
		}
		break;
	case RPC_ACTIVATEFORCEPOWERREGEN__:
		{
			
			activateForcePowerRegen();
			
		}
		break;
	case RPC_DORECOVERY__INT_:
		{
			int latency = inv->getSignedIntParameter();
			
			doRecovery(latency);
			
		}
		break;
	case RPC_DISCONNECT__BOOL_BOOL_:
		{
			bool closeClient = inv->getBooleanParameter();
			bool doLock = inv->getBooleanParameter();
			
			disconnect(closeClient, doLock);
			
		}
		break;
	case RPC_RELOAD__ZONECLIENTSESSION_:
		{
			ZoneClientSession* client = static_cast<ZoneClientSession*>(inv->getObjectParameter());
			
			reload(client);
			
		}
		break;
	case RPC_SETOFFLINE__:
		{
			
			setOffline();
			
		}
		break;
	case RPC_SETLINKDEAD__BOOL_:
		{
			bool isSafeLogout = inv->getBooleanParameter();
			
			setLinkDead(isSafeLogout);
			
		}
		break;
	case RPC_SETONLINE__:
		{
			
			setOnline();
			
		}
		break;
	case RPC_SETLOGGINGOUT__:
		{
			
			setLoggingOut();
			
		}
		break;
	case RPC_ACTIVATEJOURNALQUEST__INT_BOOL_:
		{
			unsigned int questCrc = inv->getUnsignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			activateJournalQuest(questCrc, notifyClient);
			
		}
		break;
	case RPC_COMPLETEJOURNALQUEST__INT_BOOL_:
		{
			unsigned int questCrc = inv->getUnsignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			completeJournalQuest(questCrc, notifyClient);
			
		}
		break;
	case RPC_CLEARJOURNALQUEST__INT_BOOL_:
		{
			unsigned int questCrc = inv->getUnsignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			clearJournalQuest(questCrc, notifyClient);
			
		}
		break;
	case RPC_ACTIVATEJOURNALQUESTTASK__INT_INT_BOOL_:
		{
			unsigned int questCrc = inv->getUnsignedIntParameter();
			int taskNum = inv->getSignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			activateJournalQuestTask(questCrc, taskNum, notifyClient);
			
		}
		break;
	case RPC_COMPLETEJOURNALQUESTTASK__INT_INT_BOOL_:
		{
			unsigned int questCrc = inv->getUnsignedIntParameter();
			int taskNum = inv->getSignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			completeJournalQuestTask(questCrc, taskNum, notifyClient);
			
		}
		break;
	case RPC_CLEARJOURNALQUESTTASK__INT_INT_BOOL_:
		{
			unsigned int questCrc = inv->getUnsignedIntParameter();
			int taskNum = inv->getSignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			clearJournalQuestTask(questCrc, taskNum, notifyClient);
			
		}
		break;
	case RPC_ISJOURNALQUESTACTIVE__INT_:
		{
			unsigned int questCrc = inv->getUnsignedIntParameter();
			
			bool _m_res = isJournalQuestActive(questCrc);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISJOURNALQUESTCOMPLETE__INT_:
		{
			unsigned int questCrc = inv->getUnsignedIntParameter();
			
			bool _m_res = isJournalQuestComplete(questCrc);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISJOURNALQUESTTASKACTIVE__INT_INT_:
		{
			unsigned int questCrc = inv->getUnsignedIntParameter();
			int taskNum = inv->getSignedIntParameter();
			
			bool _m_res = isJournalQuestTaskActive(questCrc, taskNum);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISJOURNALQUESTTASKCOMPLETE__INT_INT_:
		{
			unsigned int questCrc = inv->getUnsignedIntParameter();
			int taskNum = inv->getSignedIntParameter();
			
			bool _m_res = isJournalQuestTaskComplete(questCrc, taskNum);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SENDBADGESRESPONSETO__CREATUREOBJECT_:
		{
			CreatureObject* player = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			sendBadgesResponseTo(player);
			
		}
		break;
	case RPC_LOGOUT__BOOL_:
		{
			bool doLock = inv->getBooleanParameter();
			
			logout(doLock);
			
		}
		break;
	case RPC_SETJEDISTATE__INT_BOOL_:
		{
			int state = inv->getSignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setJediState(state, notifyClient);
			
		}
		break;
	case RPC_SETACTIVEQUESTSBIT__INT_BYTE_BOOL_:
		{
			int bitIndex = inv->getSignedIntParameter();
			byte value = inv->getByteParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setActiveQuestsBit(bitIndex, value, notifyClient);
			
		}
		break;
	case RPC_CLEARACTIVEQUESTSBIT__INT_BOOL_:
		{
			int bitIndex = inv->getSignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			clearActiveQuestsBit(bitIndex, notifyClient);
			
		}
		break;
	case RPC_CANACTIVATEQUEST__INT_:
		{
			int questID = inv->getSignedIntParameter();
			
			bool _m_res = canActivateQuest(questID);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ACTIVATEQUEST__INT_:
		{
			int questID = inv->getSignedIntParameter();
			
			activateQuest(questID);
			
		}
		break;
	case RPC_HASACTIVEQUESTBITSET__INT_:
		{
			int bitIndex = inv->getSignedIntParameter();
			
			bool _m_res = hasActiveQuestBitSet(bitIndex);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_HASCOMPLETEDQUESTSBITSET__INT_:
		{
			int bitIndex = inv->getSignedIntParameter();
			
			bool _m_res = hasCompletedQuestsBitSet(bitIndex);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETCOMPLETEDQUESTSBIT__INT_BYTE_BOOL_:
		{
			int bitIndex = inv->getSignedIntParameter();
			byte value = inv->getByteParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setCompletedQuestsBit(bitIndex, value, notifyClient);
			
		}
		break;
	case RPC_CLEARCOMPLETEDQUESTSBIT__INT_BOOL_:
		{
			int bitIndex = inv->getSignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			clearCompletedQuestsBit(bitIndex, notifyClient);
			
		}
		break;
	case RPC_COMPLETEQUEST__INT_:
		{
			int questID = inv->getSignedIntParameter();
			
			completeQuest(questID);
			
		}
		break;
	case RPC_HASQUESTDATA__INT_:
		{
			unsigned int questCrc = inv->getUnsignedIntParameter();
			
			bool _m_res = hasQuestData(questCrc);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETLASTNPCCONVSTR__STRING_:
		{
			 String conv; inv->getAsciiParameter(conv);
			
			setLastNpcConvStr(conv);
			
		}
		break;
	case RPC_SETLASTNPCCONVMESSSTR__STRING_:
		{
			 String mess; inv->getAsciiParameter(mess);
			
			setLastNpcConvMessStr(mess);
			
		}
		break;
	case RPC_GETLASTNPCCONVSTR__:
		{
			
			String _m_res = getLastNpcConvStr();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_GETLASTNPCCONVMESSSTR__:
		{
			
			String _m_res = getLastNpcConvMessStr();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_GETLASTNPCCONVOPTION__INT_:
		{
			int idx = inv->getSignedIntParameter();
			
			String _m_res = getLastNpcConvOption(idx);
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_ADDLASTNPCCONVOPTIONS__STRING_:
		{
			 String option; inv->getAsciiParameter(option);
			
			addLastNpcConvOptions(option);
			
		}
		break;
	case RPC_COUNTLASTNPCCONVOPTIONS__:
		{
			
			int _m_res = countLastNpcConvOptions();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_CLEARLASTNPCCONVOPTIONS__:
		{
			
			clearLastNpcConvOptions();
			
		}
		break;
	case RPC_SETCONVERSATINGCREATURE__CREATUREOBJECT_:
		{
			CreatureObject* creature = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			setConversatingCreature(creature);
			
		}
		break;
	case RPC_GETCONVERSATINGCREATURE__:
		{
			
			unsigned long long _m_res = getConversatingCreature();
			resp->insertLong(_m_res);
		}
		break;
	case RPC_SETTRAINERZONENAME__STRING_:
		{
			String zoneName; inv->getAsciiParameter(zoneName);
			
			setTrainerZoneName(zoneName);
			
		}
		break;
	case RPC_GETTRAINERZONENAME__:
		{
			
			String _m_res = getTrainerZoneName();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_ADDPERSISTENTMESSAGE__LONG_:
		{
			unsigned long long id = inv->getUnsignedLongParameter();
			
			addPersistentMessage(id);
			
		}
		break;
	case RPC_DROPPERSISTENTMESSAGE__LONG_:
		{
			unsigned long long id = inv->getUnsignedLongParameter();
			
			dropPersistentMessage(id);
			
		}
		break;
	case RPC_UNLOADSPAWNEDCHILDREN__:
		{
			
			unloadSpawnedChildren();
			
		}
		break;
	case RPC_ADDTOCONSENTLIST__STRING_:
		{
			 String name; inv->getAsciiParameter(name);
			
			addToConsentList(name);
			
		}
		break;
	case RPC_HASINCONSENTLIST__STRING_:
		{
			 String name; inv->getAsciiParameter(name);
			
			bool _m_res = hasInConsentList(name);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_REMOVEFROMCONSENTLIST__STRING_:
		{
			 String name; inv->getAsciiParameter(name);
			
			removeFromConsentList(name);
			
		}
		break;
	case RPC_GETCONSENTNAME__INT_:
		{
			int i = inv->getSignedIntParameter();
			
			String _m_res = getConsentName(i);
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_GETCONSENTLISTSIZE__:
		{
			
			int _m_res = getConsentListSize();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETREACTIONFINES__:
		{
			
			int _m_res = getReactionFines();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETFACTIONRANK__:
		{
			
			String _m_res = getFactionRank();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_SETCOMMANDMESSAGESTRING__INT_STRING_:
		{
			unsigned int actionCRC = inv->getUnsignedIntParameter();
			String message; inv->getAsciiParameter(message);
			
			setCommandMessageString(actionCRC, message);
			
		}
		break;
	case RPC_REMOVECOMMANDMESSAGESTRING__INT_:
		{
			unsigned int actionCRC = inv->getUnsignedIntParameter();
			
			removeCommandMessageString(actionCRC);
			
		}
		break;
	case RPC_GETDECLAREDRESIDENCE__:
		{
			
			unsigned long long _m_res = getDeclaredResidence();
			resp->insertLong(_m_res);
		}
		break;
	case RPC_SETDECLAREDRESIDENCE__BUILDINGOBJECT_:
		{
			BuildingObject* residence = static_cast<BuildingObject*>(inv->getObjectParameter());
			
			setDeclaredResidence(residence);
			
		}
		break;
	case RPC_SETCLONINGFACILITY__BUILDINGOBJECT_:
		{
			BuildingObject* cloningfac = static_cast<BuildingObject*>(inv->getObjectParameter());
			
			setCloningFacility(cloningfac);
			
		}
		break;
	case RPC_GETCLONINGFACILITY__:
		{
			
			unsigned long long _m_res = getCloningFacility();
			resp->insertLong(_m_res);
		}
		break;
	case RPC_NOTIFYONLINE__:
		{
			
			notifyOnline();
			
		}
		break;
	case RPC_DODIGEST__INT_:
		{
			int fillingReduction = inv->getSignedIntParameter();
			
			doDigest(fillingReduction);
			
		}
		break;
	case RPC_ISDIGESTING__:
		{
			
			bool _m_res = isDigesting();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETSAVEDTERRAINNAME__:
		{
			
			String _m_res = getSavedTerrainName();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_SETSAVEDPARENTID__LONG_:
		{
			unsigned long long id = inv->getUnsignedLongParameter();
			
			setSavedParentID(id);
			
		}
		break;
	case RPC_SETSAVEDTERRAINNAME__STRING_:
		{
			 String name; inv->getAsciiParameter(name);
			
			setSavedTerrainName(name);
			
		}
		break;
	case RPC_SETBIRTHDATE__INT_:
		{
			int date = inv->getSignedIntParameter();
			
			setBirthDate(date);
			
		}
		break;
	case RPC_SETFORCEPOWER__INT_BOOL_:
		{
			int fp = inv->getSignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setForcePower(fp, notifyClient);
			
		}
		break;
	case RPC_SETFORCEPOWERMAX__INT_BOOL_:
		{
			int newValue = inv->getSignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			setForcePowerMax(newValue, notifyClient);
			
		}
		break;
	case RPC_DOFORCEREGEN__:
		{
			
			doForceRegen();
			
		}
		break;
	case RPC_RECALCULATEFORCEPOWER__:
		{
			
			recalculateForcePower();
			
		}
		break;
	case RPC_GETFORCEPOWERREGEN__:
		{
			
			int _m_res = getForcePowerRegen();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETSAVEDPARENTID__:
		{
			
			unsigned long long _m_res = getSavedParentID();
			resp->insertLong(_m_res);
		}
		break;
	case RPC_GETNEWSUIBOXID__INT_:
		{
			unsigned int type = inv->getUnsignedIntParameter();
			
			unsigned int _m_res = getNewSuiBoxID(type);
			resp->insertInt(_m_res);
		}
		break;
	case RPC_HASSUIBOX__INT_:
		{
			unsigned int boxID = inv->getUnsignedIntParameter();
			
			bool _m_res = hasSuiBox(boxID);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETSUIBOX__INT_:
		{
			unsigned int boxID = inv->getUnsignedIntParameter();
			
			DistributedObject* _m_res = getSuiBox(boxID);
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_REMOVESUIBOX__INT_BOOL_:
		{
			unsigned int boxID = inv->getUnsignedIntParameter();
			bool closeWindowToClient = inv->getBooleanParameter();
			
			removeSuiBox(boxID, closeWindowToClient);
			
		}
		break;
	case RPC_REMOVESUIBOXTYPE__INT_:
		{
			unsigned int windowType = inv->getUnsignedIntParameter();
			
			removeSuiBoxType(windowType);
			
		}
		break;
	case RPC_HASSUIBOXWINDOWTYPE__INT_:
		{
			unsigned int windowType = inv->getUnsignedIntParameter();
			
			bool _m_res = hasSuiBoxWindowType(windowType);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_CLOSESUIWINDOWTYPE__INT_:
		{
			unsigned int windowType = inv->getUnsignedIntParameter();
			
			closeSuiWindowType(windowType);
			
		}
		break;
	case RPC_GETSUIBOXFROMWINDOWTYPE__INT_:
		{
			unsigned int windowType = inv->getUnsignedIntParameter();
			
			DistributedObject* _m_res = getSuiBoxFromWindowType(windowType);
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_ADDSUIBOX__SUIBOX_:
		{
			SuiBox* sui = static_cast<SuiBox*>(inv->getObjectParameter());
			
			addSuiBox(sui);
			
		}
		break;
	case RPC_ADDPERMISSIONGROUP__STRING_BOOL_:
		{
			 String group; inv->getAsciiParameter(group);
			bool updatePermissions = inv->getBooleanParameter();
			
			addPermissionGroup(group, updatePermissions);
			
		}
		break;
	case RPC_REMOVEPERMISSIONGROUP__STRING_BOOL_:
		{
			 String group; inv->getAsciiParameter(group);
			bool updatePermissions = inv->getBooleanParameter();
			
			removePermissionGroup(group, updatePermissions);
			
		}
		break;
	case RPC_UPDATEINRANGEBUILDINGPERMISSIONS__:
		{
			
			updateInRangeBuildingPermissions();
			
		}
		break;
	case RPC_HASPERMISSIONGROUP__STRING_:
		{
			 String group; inv->getAsciiParameter(group);
			
			bool _m_res = hasPermissionGroup(group);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ADDINCAPACITATIONTIME__:
		{
			
			addIncapacitationTime();
			
		}
		break;
	case RPC_GETINCAPACITATIONCOUNTER__:
		{
			
			byte _m_res = getIncapacitationCounter();
			resp->insertByte(_m_res);
		}
		break;
	case RPC_RESETINCAPACITATIONTIMES__:
		{
			
			resetIncapacitationTimes();
			
		}
		break;
	case RPC_ADDTODUELLIST__CREATUREOBJECT_:
		{
			CreatureObject* targetPlayer = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			addToDuelList(targetPlayer);
			
		}
		break;
	case RPC_REMOVEFROMDUELLIST__CREATUREOBJECT_:
		{
			CreatureObject* targetPlayer = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			removeFromDuelList(targetPlayer);
			
		}
		break;
	case RPC_GETDUELLISTOBJECT__INT_:
		{
			int index = inv->getSignedIntParameter();
			
			DistributedObject* _m_res = getDuelListObject(index);
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_REQUESTEDDUELTO__CREATUREOBJECT_:
		{
			CreatureObject* targetPlayer = static_cast<CreatureObject*>(inv->getObjectParameter());
			
			bool _m_res = requestedDuelTo(targetPlayer);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISDUELLISTEMPTY__:
		{
			
			bool _m_res = isDuelListEmpty();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETDUELLISTSIZE__:
		{
			
			int _m_res = getDuelListSize();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_ADDTOACTIVEPETS__AIAGENT_:
		{
			AiAgent* pet = static_cast<AiAgent*>(inv->getObjectParameter());
			
			addToActivePets(pet);
			
		}
		break;
	case RPC_REMOVEFROMACTIVEPETS__AIAGENT_:
		{
			AiAgent* pet = static_cast<AiAgent*>(inv->getObjectParameter());
			
			removeFromActivePets(pet);
			
		}
		break;
	case RPC_GETACTIVEPET__INT_:
		{
			int index = inv->getSignedIntParameter();
			
			DistributedObject* _m_res = getActivePet(index);
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_HASACTIVEPET__AIAGENT_:
		{
			AiAgent* pet = static_cast<AiAgent*>(inv->getObjectParameter());
			
			bool _m_res = hasActivePet(pet);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETACTIVEPETSSIZE__:
		{
			
			int _m_res = getActivePetsSize();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETBIOGRAPHY__:
		{
			
			UnicodeString _m_res = getBiography();
			resp->insertUnicode(_m_res);
		}
		break;
	case RPC_NOTIFYOFFLINE__:
		{
			
			notifyOffline();
			
		}
		break;
	case RPC_RESETSESSIONSTATS__BOOL_:
		{
			bool isSessionStart = inv->getBooleanParameter();
			
			resetSessionStats(isSessionStart);
			
		}
		break;
	case RPC_INCREMENTSESSIONMOVEMENT__FLOAT_:
		{
			float moveDelta = inv->getFloatParameter();
			
			incrementSessionMovement(moveDelta);
			
		}
		break;
	case RPC_LOGSESSIONSTATS__BOOL_:
		{
			bool isSessionEnd = inv->getBooleanParameter();
			
			logSessionStats(isSessionEnd);
			
		}
		break;
	case RPC_SETBADGE__INT_:
		{
			unsigned int badge = inv->getUnsignedIntParameter();
			
			setBadge(badge);
			
		}
		break;
	case RPC_REVOKEBADGE__INT_:
		{
			unsigned int badge = inv->getUnsignedIntParameter();
			
			revokeBadge(badge);
			
		}
		break;
	case RPC_AWARDBADGE__INT_:
		{
			unsigned int badge = inv->getUnsignedIntParameter();
			
			awardBadge(badge);
			
		}
		break;
	case RPC_SETTELEPORTING__BOOL_:
		{
			bool val = inv->getBooleanParameter();
			
			setTeleporting(val);
			
		}
		break;
	case RPC_SETONLOADSCREEN__BOOL_:
		{
			bool val = inv->getBooleanParameter();
			
			setOnLoadScreen(val);
			
		}
		break;
	case RPC_SETFORCEDTRANSFORM__BOOL_:
		{
			bool val = inv->getBooleanParameter();
			
			setForcedTransform(val);
			
		}
		break;
	case RPC_GETNUMBADGES__:
		{
			
			int _m_res = getNumBadges();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETBADGETYPECOUNT__INT_:
		{
			unsigned int type = inv->getUnsignedIntParameter();
			
			int _m_res = getBadgeTypeCount(type);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_HASFRIEND__STRING_:
		{
			 String name; inv->getAsciiParameter(name);
			
			bool _m_res = hasFriend(name);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETFRIENDLISTSIZE__:
		{
			
			int _m_res = getFriendListSize();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_ISIGNORING__STRING_:
		{
			 String name; inv->getAsciiParameter(name);
			
			bool _m_res = isIgnoring(name);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ADDREVERSEFRIEND__STRING_:
		{
			 String name; inv->getAsciiParameter(name);
			
			addReverseFriend(name);
			
		}
		break;
	case RPC_REMOVEREVERSEFRIEND__STRING_:
		{
			 String name; inv->getAsciiParameter(name);
			
			removeReverseFriend(name);
			
		}
		break;
	case RPC_SENDFRIENDLISTS__:
		{
			
			sendFriendLists();
			
		}
		break;
	case RPC_HASABILITY__STRING_:
		{
			 String ability; inv->getAsciiParameter(ability);
			
			bool _m_res = hasAbility(ability);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_HASCOMMANDMESSAGESTRING__INT_:
		{
			unsigned int actionCRC = inv->getUnsignedIntParameter();
			
			bool _m_res = hasCommandMessageString(actionCRC);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETTITLE__:
		{
			
			String _m_res = getTitle();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_GETADMINLEVEL__:
		{
			
			unsigned int _m_res = getAdminLevel();
			resp->insertInt(_m_res);
		}
		break;
	case RPC_SETADMINLEVEL__INT_:
		{
			unsigned int adminlvl = inv->getUnsignedIntParameter();
			
			setAdminLevel(adminlvl);
			
		}
		break;
	case RPC_GETPRIVILEDGEFLAG__:
		{
			
			int _m_res = getPriviledgeFlag();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_SETPRIVILEDGEFLAG__INT_:
		{
			int flag = inv->getSignedIntParameter();
			
			setPriviledgeFlag(flag);
			
		}
		break;
	case RPC_SETBIOGRAPHY__UNICODESTRING_:
		{
			 UnicodeString bio; inv->getUnicodeParameter(bio);
			
			setBiography(bio);
			
		}
		break;
	case RPC_HASGODMODE__:
		{
			
			bool _m_res = hasGodMode();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISPRIVILEGED__:
		{
			
			bool _m_res = isPrivileged();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISSTAFF__:
		{
			
			bool _m_res = isStaff();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISADMIN__:
		{
			
			bool _m_res = isAdmin();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETPLAYERBIT__INT_BOOL_:
		{
			unsigned int bit = inv->getUnsignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			bool _m_res = setPlayerBit(bit, notifyClient);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_CLEARPLAYERBIT__INT_BOOL_:
		{
			unsigned int bit = inv->getUnsignedIntParameter();
			bool notifyClient = inv->getBooleanParameter();
			
			bool _m_res = clearPlayerBit(bit, notifyClient);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_TOGGLECHARACTERBIT__INT_:
		{
			unsigned int bit = inv->getUnsignedIntParameter();
			
			toggleCharacterBit(bit);
			
		}
		break;
	case RPC_ISLFG__:
		{
			
			bool _m_res = isLFG();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISAFK__:
		{
			
			bool _m_res = isAFK();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISANONYMOUS__:
		{
			
			bool _m_res = isAnonymous();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISROLEPLAYER__:
		{
			
			bool _m_res = isRoleplayer();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISNEWBIEHELPER__:
		{
			
			bool _m_res = isNewbieHelper();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETTOTALPLAYEDTIME__:
		{
			
			int _m_res = getTotalPlayedTime();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETFORCEPOWER__:
		{
			
			int _m_res = getForcePower();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETFORCEPOWERMAX__:
		{
			
			int _m_res = getForcePowerMax();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETSCHEMATIC__INT_:
		{
			int i = inv->getSignedIntParameter();
			
			DistributedObject* _m_res = getSchematic(i);
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_GETFOODFILLING__:
		{
			
			int _m_res = getFoodFilling();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETFOODFILLINGMAX__:
		{
			
			int _m_res = getFoodFillingMax();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETDRINKFILLING__:
		{
			
			int _m_res = getDrinkFilling();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETDRINKFILLINGMAX__:
		{
			
			int _m_res = getDrinkFillingMax();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETJEDISTATE__:
		{
			
			int _m_res = getJediState();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETLANGUAGEID__:
		{
			
			byte _m_res = getLanguageID();
			resp->insertByte(_m_res);
		}
		break;
	case RPC_ISTELEPORTING__:
		{
			
			bool _m_res = isTeleporting();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISONLOADSCREEN__:
		{
			
			bool _m_res = isOnLoadScreen();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISFORCEDTRANSFORM__:
		{
			
			bool _m_res = isForcedTransform();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ADDCHATROOM__INT_:
		{
			unsigned int roomID = inv->getUnsignedIntParameter();
			
			addChatRoom(roomID);
			
		}
		break;
	case RPC_REMOVECHATROOM__INT_:
		{
			unsigned int roomID = inv->getUnsignedIntParameter();
			
			removeChatRoom(roomID);
			
		}
		break;
	case RPC_ADDOWNEDCHATROOM__INT_:
		{
			unsigned int roomID = inv->getUnsignedIntParameter();
			
			addOwnedChatRoom(roomID);
			
		}
		break;
	case RPC_REMOVEOWNEDCHATROOM__INT_:
		{
			unsigned int roomID = inv->getUnsignedIntParameter();
			
			removeOwnedChatRoom(roomID);
			
		}
		break;
	case RPC_GETOWNEDCHATROOMCOUNT__:
		{
			
			int _m_res = getOwnedChatRoomCount();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_SETBANKLOCATION__STRING_:
		{
			 String location; inv->getAsciiParameter(location);
			
			setBankLocation(location);
			
		}
		break;
	case RPC_GETBANKLOCATION__:
		{
			
			String _m_res = getBankLocation();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_GETEXPERIENCE__STRING_:
		{
			 String xp; inv->getAsciiParameter(xp);
			
			int _m_res = getExperience(xp);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_MAXIMIZEEXPERIENCE__:
		{
			
			maximizeExperience();
			
		}
		break;
	case RPC_ACTIVATEMISSIONS__:
		{
			
			activateMissions();
			
		}
		break;
	case RPC_GETCOMMANDMESSAGESTRING__INT_:
		{
			unsigned int actionCRC = inv->getUnsignedIntParameter();
			
			String _m_res = getCommandMessageString(actionCRC);
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_HASBADGE__INT_:
		{
			unsigned int badge = inv->getUnsignedIntParameter();
			
			bool _m_res = hasBadge(badge);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_CLEARDISCONNECTEVENT__:
		{
			
			clearDisconnectEvent();
			
		}
		break;
	case RPC_ISONLINE__:
		{
			
			bool _m_res = isOnline();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISOFFLINE__:
		{
			
			bool _m_res = isOffline();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISLINKDEAD__:
		{
			
			bool _m_res = isLinkDead();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISLOGGINGOUT__:
		{
			
			bool _m_res = isLoggingOut();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETSKILLPOINTS__INT_:
		{
			int points = inv->getSignedIntParameter();
			
			setSkillPoints(points);
			
		}
		break;
	case RPC_ADDSKILLPOINTS__INT_:
		{
			int points = inv->getSignedIntParameter();
			
			addSkillPoints(points);
			
		}
		break;
	case RPC_GETSKILLPOINTS__:
		{
			
			int _m_res = getSkillPoints();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_UPDATELASTVALIDATEDPOSITION__:
		{
			
			updateLastValidatedPosition();
			
		}
		break;
	case RPC_GETACCOUNTID__:
		{
			
			unsigned int _m_res = getAccountID();
			resp->insertInt(_m_res);
		}
		break;
	case RPC_GETSERVERMOVEMENTTIMEDELTA__:
		{
			
			unsigned long long _m_res = getServerMovementTimeDelta();
			resp->insertLong(_m_res);
		}
		break;
	case RPC_SETCLIENTLASTMOVEMENTSTAMP__INT_:
		{
			unsigned int stamp = inv->getUnsignedIntParameter();
			
			setClientLastMovementStamp(stamp);
			
		}
		break;
	case RPC_UPDATESERVERLASTMOVEMENTSTAMP__:
		{
			
			updateServerLastMovementStamp();
			
		}
		break;
	case RPC_SETACCOUNTID__INT_:
		{
			unsigned int id = inv->getUnsignedIntParameter();
			
			setAccountID(id);
			
		}
		break;
	case RPC_GETCLIENTLASTMOVEMENTSTAMP__:
		{
			
			unsigned int _m_res = getClientLastMovementStamp();
			resp->insertInt(_m_res);
		}
		break;
	case RPC_ADDHOLOGRINDPROFESSION__BYTE_:
		{
			byte prof = inv->getByteParameter();
			
			addHologrindProfession(prof);
			
		}
		break;
	case RPC_SETMAXIMUMLOTS__BYTE_:
		{
			byte lots = inv->getByteParameter();
			
			setMaximumLots(lots);
			
		}
		break;
	case RPC_GETMAXIMUMLOTS__:
		{
			
			byte _m_res = getMaximumLots();
			resp->insertByte(_m_res);
		}
		break;
	case RPC_GETSTARTERPROFESSION__:
		{
			
			String _m_res = getStarterProfession();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_SETSTARTERPROFESSION__STRING_:
		{
			String profession; inv->getAsciiParameter(profession);
			
			setStarterProfession(profession);
			
		}
		break;
	case RPC_GETPERFORMANCEBUFFTARGET__:
		{
			
			unsigned long long _m_res = getPerformanceBuffTarget();
			resp->insertLong(_m_res);
		}
		break;
	case RPC_SETPERFORMANCEBUFFTARGET__LONG_:
		{
			unsigned long long target = inv->getUnsignedLongParameter();
			
			setPerformanceBuffTarget(target);
			
		}
		break;
	case RPC_SETDEBUG__BOOL_:
		{
			bool value = inv->getBooleanParameter();
			
			setDebug(value);
			
		}
		break;
	case RPC_GETDEBUG__:
		{
			
			bool _m_res = getDebug();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETVISIBILITY__:
		{
			
			float _m_res = getVisibility();
			resp->insertFloat(_m_res);
		}
		break;
	case RPC_SETVISIBILITY__FLOAT_:
		{
			float value = inv->getFloatParameter();
			
			setVisibility(value);
			
		}
		break;
	case RPC_UPDATELASTCOMBATACTIONTIMESTAMP__BOOL_BOOL_BOOL_:
		{
			bool updateGcwCrackdownAction = inv->getBooleanParameter();
			bool updateGcwAction = inv->getBooleanParameter();
			bool updateBhAction = inv->getBooleanParameter();
			
			updateLastCombatActionTimestamp(updateGcwCrackdownAction, updateGcwAction, updateBhAction);
			
		}
		break;
	case RPC_UPDATELASTBHPVPCOMBATACTIONTIMESTAMP__:
		{
			
			updateLastBhPvpCombatActionTimestamp();
			
		}
		break;
	case RPC_UPDATELASTGCWPVPCOMBATACTIONTIMESTAMP__:
		{
			
			updateLastGcwPvpCombatActionTimestamp();
			
		}
		break;
	case RPC_UPDATELASTPVPAREACOMBATACTIONTIMESTAMP__:
		{
			
			updateLastPvpAreaCombatActionTimestamp();
			
		}
		break;
	case RPC_HASTEF__:
		{
			
			bool _m_res = hasTef();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_HASPVPTEF__:
		{
			
			bool _m_res = hasPvpTef();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_HASGCWTEF__:
		{
			
			bool _m_res = hasGcwTef();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_HASBHTEF__:
		{
			
			bool _m_res = hasBhTef();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETCRACKDOWNTEFTOWARDS__INT_BOOL_:
		{
			unsigned int factionCrc = inv->getUnsignedIntParameter();
			bool scheduleTefRemovalTask = inv->getBooleanParameter();
			
			setCrackdownTefTowards(factionCrc, scheduleTefRemovalTask);
			
		}
		break;
	case RPC_HASCRACKDOWNTEFTOWARDS__INT_:
		{
			unsigned int factionCrc = inv->getUnsignedIntParameter();
			
			bool _m_res = hasCrackdownTefTowards(factionCrc);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_HASCRACKDOWNTEF__:
		{
			
			bool _m_res = hasCrackdownTef();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SCHEDULEPVPTEFREMOVALTASK__BOOL_BOOL_BOOL_:
		{
			bool removeCrackdownGcwTefNow = inv->getBooleanParameter();
			bool removeGcwTefNow = inv->getBooleanParameter();
			bool removeBhTefNow = inv->getBooleanParameter();
			
			schedulePvpTefRemovalTask(removeCrackdownGcwTefNow, removeGcwTefNow, removeBhTefNow);
			
		}
		break;
	case RPC_SCHEDULEPVPTEFREMOVALTASK__BOOL_:
		{
			bool removeNow = inv->getBooleanParameter();
			
			schedulePvpTefRemovalTask(removeNow);
			
		}
		break;
	case RPC_ISINPVPAREA__BOOL_:
		{
			bool checkTime = inv->getBooleanParameter();
			
			bool _m_res = isInPvpArea(checkTime);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ADDVENDOR__SCENEOBJECT_:
		{
			SceneObject* vendor = static_cast<SceneObject*>(inv->getObjectParameter());
			
			addVendor(vendor);
			
		}
		break;
	case RPC_REMOVEVENDOR__SCENEOBJECT_:
		{
			SceneObject* vendor = static_cast<SceneObject*>(inv->getObjectParameter());
			
			removeVendor(vendor);
			
		}
		break;
	case RPC_GETVENDORCOUNT__:
		{
			
			int _m_res = getVendorCount();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_DESTROYOBJECTFROMDATABASE__BOOL_:
		{
			bool destroyContainedObjects = inv->getBooleanParameter();
			
			destroyObjectFromDatabase(destroyContainedObjects);
			
		}
		break;
	case RPC_DELETEALLPERSISTENTMESSAGES__:
		{
			
			deleteAllPersistentMessages();
			
		}
		break;
	case RPC_ISJEDI__:
		{
			
			bool _m_res = isJedi();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISJEDILIGHT__:
		{
			
			bool _m_res = isJediLight();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISJEDIDARK__:
		{
			
			bool _m_res = isJediDark();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_ISMUTED__:
		{
			
			bool _m_res = isMuted();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETMUTEDSTATE__BOOL_:
		{
			bool mute = inv->getBooleanParameter();
			
			setMutedState(mute);
			
		}
		break;
	case RPC_GETMUTEDREASON__:
		{
			
			String _m_res = getMutedReason();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_SETMUTEDREASON__STRING_:
		{
			String reason; inv->getAsciiParameter(reason);
			
			setMutedReason(reason);
			
		}
		break;
	case RPC_GETINSTALLEDHOLOEMOTE__:
		{
			
			String _m_res = getInstalledHoloEmote();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_SETINSTALLEDHOLOEMOTE__STRING_:
		{
			String holoEmote; inv->getAsciiParameter(holoEmote);
			
			setInstalledHoloEmote(holoEmote);
			
		}
		break;
	case RPC_REMOVEINSTALLEDHOLOEMOTE__:
		{
			
			removeInstalledHoloEmote();
			
		}
		break;
	case RPC_GETHOLOEMOTEUSECOUNT__:
		{
			
			int _m_res = getHoloEmoteUseCount();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_DECREASEHOLOEMOTEUSECOUNT__:
		{
			
			decreaseHoloEmoteUseCount();
			
		}
		break;
	case RPC_ISMARRIED__:
		{
			
			bool _m_res = isMarried();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETSPOUSENAME__:
		{
			
			String _m_res = getSpouseName();
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_SETSPOUSENAME__STRING_:
		{
			String firstName; inv->getAsciiParameter(firstName);
			
			setSpouseName(firstName);
			
		}
		break;
	case RPC_REMOVESPOUSE__:
		{
			
			removeSpouse();
			
		}
		break;
	case RPC_GETACCOUNT__:
		{
			
			DistributedObject* _m_res = getAccount();
			resp->insertLong(_m_res == NULL ? 0 : _m_res->_getObjectID());
		}
		break;
	case RPC_GETCHOSENVETERANREWARD__INT_:
		{
			unsigned int milestone = inv->getUnsignedIntParameter();
			
			String _m_res = getChosenVeteranReward(milestone);
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_HASCHOSENVETERANREWARD__STRING_:
		{
			 String rewardTemplate; inv->getAsciiParameter(rewardTemplate);
			
			bool _m_res = hasChosenVeteranReward(rewardTemplate);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_CLEARVETERANREWARD__INT_:
		{
			unsigned int milestone = inv->getUnsignedIntParameter();
			
			clearVeteranReward(milestone);
			
		}
		break;
	case RPC_ADDEVENTPERK__SCENEOBJECT_:
		{
			SceneObject* deed = static_cast<SceneObject*>(inv->getObjectParameter());
			
			addEventPerk(deed);
			
		}
		break;
	case RPC_REMOVEEVENTPERK__SCENEOBJECT_:
		{
			SceneObject* deed = static_cast<SceneObject*>(inv->getObjectParameter());
			
			removeEventPerk(deed);
			
		}
		break;
	case RPC_GETEVENTPERKCOUNT__:
		{
			
			int _m_res = getEventPerkCount();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETCHARACTERAGEINDAYS__:
		{
			
			int _m_res = getCharacterAgeInDays();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETBIRTHDATE__:
		{
			
			int _m_res = getBirthDate();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_ADDTOREACTIONFINES__INT_:
		{
			int fine = inv->getSignedIntParameter();
			
			addToReactionFines(fine);
			
		}
		break;
	case RPC_SETREACTIONFINES__INT_:
		{
			int amount = inv->getSignedIntParameter();
			
			setReactionFines(amount);
			
		}
		break;
	case RPC_SUBTRACTFROMREACTIONFINES__INT_:
		{
			int amount = inv->getSignedIntParameter();
			
			subtractFromReactionFines(amount);
			
		}
		break;
	case RPC_UPDATEREACTIONFINETIMESTAMP__:
		{
			
			updateReactionFineTimestamp();
			
		}
		break;
	case RPC_UPDATEREACTIONFINEMAILTIMESTAMP__:
		{
			
			updateReactionFineMailTimestamp();
			
		}
		break;
	case RPC_GETXPCAP__STRING_:
		{
			 String type; inv->getAsciiParameter(type);
			
			int _m_res = getXpCap(type);
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_GETSPENTJEDISKILLPOINTS__:
		{
			
			int _m_res = getSpentJediSkillPoints();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_HASSCHEMATIC__DRAFTSCHEMATIC_:
		{
			DraftSchematic* schematic = static_cast<DraftSchematic*>(inv->getObjectParameter());
			
			bool _m_res = hasSchematic(schematic);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_HASEVENTPERK__STRING_:
		{
			 String templatePath; inv->getAsciiParameter(templatePath);
			
			bool _m_res = hasEventPerk(templatePath);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_DOFIELDFACTIONCHANGE__INT_:
		{
			int newStatus = inv->getSignedIntParameter();
			
			doFieldFactionChange(newStatus);
			
		}
		break;
	case RPC_ADDTOVICTIMLIST__INT_:
		{
			unsigned int playerID = inv->getUnsignedIntParameter();
			
			addToVictimList(playerID);
			
		}
		break;
	case RPC_HASONVICTIMLIST__INT_:
		{
			unsigned int playerID = inv->getUnsignedIntParameter();
			
			bool _m_res = hasOnVictimList(playerID);
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_GETPVPRATING__:
		{
			
			int _m_res = getPvpRating();
			resp->insertSignedInt(_m_res);
		}
		break;
	case RPC_SETPVPRATING__INT_:
		{
			int rating = inv->getSignedIntParameter();
			
			setPvpRating(rating);
			
		}
		break;
	case RPC_ISCLONING__:
		{
			
			bool _m_res = isCloning();
			resp->insertBoolean(_m_res);
		}
		break;
	case RPC_SETCLONING__BOOL_:
		{
			bool val = inv->getBooleanParameter();
			
			setCloning(val);
			
		}
		break;
	case RPC_GETPLAYEDMILISECS__:
		{
			
			unsigned long long _m_res = getPlayedMiliSecs();
			resp->insertLong(_m_res);
		}
		break;
	case RPC_GETSESSIONMILISECS__:
		{
			
			unsigned long long _m_res = getSessionMiliSecs();
			resp->insertLong(_m_res);
		}
		break;
	case RPC_GETSESSIONTOTALMOVEMENT__:
		{
			
			unsigned long long _m_res = getSessionTotalMovement();
			resp->insertLong(_m_res);
		}
		break;
	case RPC_GETSESSIONTOTALCREDITS__:
		{
			
			long long _m_res = getSessionTotalCredits();
			resp->insertSignedLong(_m_res);
		}
		break;
	case RPC_GETMILISECSTIMESTRING__LONG_BOOL_:
		{
			unsigned long long miliSecs = inv->getUnsignedLongParameter();
			bool verbose = inv->getBooleanParameter();
			
			String _m_res = getMiliSecsTimeString(miliSecs, verbose);
			resp->insertAscii(_m_res);
		}
		break;
	case RPC_GETPLAYEDTIMESTRING__BOOL_:
		{
			bool verbose = inv->getBooleanParameter();
			
			String _m_res = getPlayedTimeString(verbose);
			resp->insertAscii(_m_res);
		}
		break;
	default:
		IntangibleObjectAdapter::invokeMethod(methid, inv);
	}
}

void PlayerObjectAdapter::finalize() {
	(static_cast<PlayerObject*>(stub))->finalize();
}

void PlayerObjectAdapter::setLogLevel(int newLevel) {
	(static_cast<PlayerObject*>(stub))->setLogLevel(newLevel);
}

int PlayerObjectAdapter::getLogLevel() const {
	return (static_cast<PlayerObject*>(stub))->getLogLevel();
}

int PlayerObjectAdapter::getCountMaxCov() const {
	return (static_cast<PlayerObject*>(stub))->getCountMaxCov();
}

void PlayerObjectAdapter::setCountMaxCov(int newMaxCov) {
	(static_cast<PlayerObject*>(stub))->setCountMaxCov(newMaxCov);
}

void PlayerObjectAdapter::setClientPathWaypoint(SceneObject* obj) {
	(static_cast<PlayerObject*>(stub))->setClientPathWaypoint(obj);
}

void PlayerObjectAdapter::initializeAccount() {
	(static_cast<PlayerObject*>(stub))->initializeAccount();
}

void PlayerObjectAdapter::notifyLoadFromDatabase() {
	(static_cast<PlayerObject*>(stub))->notifyLoadFromDatabase();
}

void PlayerObjectAdapter::unload() {
	(static_cast<PlayerObject*>(stub))->unload();
}

int PlayerObjectAdapter::calculateBhReward() {
	return (static_cast<PlayerObject*>(stub))->calculateBhReward();
}

void PlayerObjectAdapter::initializeTransientMembers() {
	(static_cast<PlayerObject*>(stub))->initializeTransientMembers();
}

void PlayerObjectAdapter::sendBaselinesTo(SceneObject* player) {
	(static_cast<PlayerObject*>(stub))->sendBaselinesTo(player);
}

void PlayerObjectAdapter::addOwnedStructure(StructureObject* obj) {
	(static_cast<PlayerObject*>(stub))->addOwnedStructure(obj);
}

void PlayerObjectAdapter::removeOwnedStructure(StructureObject* obj) {
	(static_cast<PlayerObject*>(stub))->removeOwnedStructure(obj);
}

int PlayerObjectAdapter::getAcceptedTOSVersion() const {
	return (static_cast<PlayerObject*>(stub))->getAcceptedTOSVersion();
}

void PlayerObjectAdapter::setAcceptedTOSVersion(int version) {
	(static_cast<PlayerObject*>(stub))->setAcceptedTOSVersion(version);
}

void PlayerObjectAdapter::checkAndShowTOS() {
	(static_cast<PlayerObject*>(stub))->checkAndShowTOS();
}

void PlayerObjectAdapter::createHelperDroid() {
	(static_cast<PlayerObject*>(stub))->createHelperDroid();
}

int PlayerObjectAdapter::getTotalOwnedStructureCount() {
	return (static_cast<PlayerObject*>(stub))->getTotalOwnedStructureCount();
}

bool PlayerObjectAdapter::isOwnedStructure(StructureObject* obj) {
	return (static_cast<PlayerObject*>(stub))->isOwnedStructure(obj);
}

unsigned long long PlayerObjectAdapter::getOwnedStructure(int i) {
	return (static_cast<PlayerObject*>(stub))->getOwnedStructure(i);
}

int PlayerObjectAdapter::getLotsRemaining() {
	return (static_cast<PlayerObject*>(stub))->getLotsRemaining();
}

bool PlayerObjectAdapter::hasLotsRemaining(int lots) {
	return (static_cast<PlayerObject*>(stub))->hasLotsRemaining(lots);
}

void PlayerObjectAdapter::notifySceneReady() {
	(static_cast<PlayerObject*>(stub))->notifySceneReady();
}

void PlayerObjectAdapter::checkPendingMessages() {
	(static_cast<PlayerObject*>(stub))->checkPendingMessages();
}

bool PlayerObjectAdapter::hasCappedExperience(const String& xpType) const {
	return (static_cast<PlayerObject*>(stub))->hasCappedExperience(xpType);
}

void PlayerObjectAdapter::addWaypoint(WaypointObject* waypoint, bool checkName, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->addWaypoint(waypoint, checkName, notifyClient);
}

void PlayerObjectAdapter::setWaypoint(WaypointObject* waypoint, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->setWaypoint(waypoint, notifyClient);
}

void PlayerObjectAdapter::removeWaypoint(unsigned long long waypointID, bool notifyClient, bool destroy) {
	(static_cast<PlayerObject*>(stub))->removeWaypoint(waypointID, notifyClient, destroy);
}

void PlayerObjectAdapter::updateWaypoint(unsigned long long waypointID) {
	(static_cast<PlayerObject*>(stub))->updateWaypoint(waypointID);
}

void PlayerObjectAdapter::removeWaypointBySpecialType(int specialTypeID, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->removeWaypointBySpecialType(specialTypeID, notifyClient);
}

WaypointObject* PlayerObjectAdapter::getWaypointBySpecialType(int specialTypeID) const {
	return (static_cast<PlayerObject*>(stub))->getWaypointBySpecialType(specialTypeID);
}

WaypointObject* PlayerObjectAdapter::getSurveyWaypoint() const {
	return (static_cast<PlayerObject*>(stub))->getSurveyWaypoint();
}

bool PlayerObjectAdapter::hasWaypoint(unsigned long long objectID) const {
	return (static_cast<PlayerObject*>(stub))->hasWaypoint(objectID);
}

WaypointObject* PlayerObjectAdapter::getWaypointAt(float x, float y, String& planet) const {
	return (static_cast<PlayerObject*>(stub))->getWaypointAt(x, y, planet);
}

int PlayerObjectAdapter::getWaypointListSize() const {
	return (static_cast<PlayerObject*>(stub))->getWaypointListSize();
}

WaypointObject* PlayerObjectAdapter::getWaypoint(int index) const {
	return (static_cast<PlayerObject*>(stub))->getWaypoint(index);
}

void PlayerObjectAdapter::setLanguageID(byte language, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->setLanguageID(language, notifyClient);
}

void PlayerObjectAdapter::addFriend(const String& name, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->addFriend(name, notifyClient);
}

void PlayerObjectAdapter::removeFriend(const String& name, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->removeFriend(name, notifyClient);
}

void PlayerObjectAdapter::removeAllReverseFriends(const String& oldName) {
	(static_cast<PlayerObject*>(stub))->removeAllReverseFriends(oldName);
}

void PlayerObjectAdapter::addIgnore(const String& name, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->addIgnore(name, notifyClient);
}

void PlayerObjectAdapter::removeIgnore(const String& name, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->removeIgnore(name, notifyClient);
}

void PlayerObjectAdapter::setTitle(const String& characterTitle, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->setTitle(characterTitle, notifyClient);
}

void PlayerObjectAdapter::setFoodFilling(int newValue, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->setFoodFilling(newValue, notifyClient);
}

void PlayerObjectAdapter::setDrinkFilling(int newValue, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->setDrinkFilling(newValue, notifyClient);
}

void PlayerObjectAdapter::increaseFactionStanding(const String& factionName, float amount) {
	(static_cast<PlayerObject*>(stub))->increaseFactionStanding(factionName, amount);
}

void PlayerObjectAdapter::giveCoaBonus(const String& factionName, float amount, float currentStanding) {
	(static_cast<PlayerObject*>(stub))->giveCoaBonus(factionName, amount, currentStanding);
}

void PlayerObjectAdapter::decreaseFactionStanding(const String& factionName, float amount) {
	(static_cast<PlayerObject*>(stub))->decreaseFactionStanding(factionName, amount);
}

void PlayerObjectAdapter::setFactionStanding(const String& factionName, float amount) {
	(static_cast<PlayerObject*>(stub))->setFactionStanding(factionName, amount);
}

float PlayerObjectAdapter::getFactionStanding(const String& factionName) const {
	return (static_cast<PlayerObject*>(stub))->getFactionStanding(factionName);
}

void PlayerObjectAdapter::setScreenPlayData(const String& screenPlay, const String& variable, const String& data) {
	(static_cast<PlayerObject*>(stub))->setScreenPlayData(screenPlay, variable, data);
}

void PlayerObjectAdapter::deleteScreenPlayData(const String& screenPlay, const String& variable) {
	(static_cast<PlayerObject*>(stub))->deleteScreenPlayData(screenPlay, variable);
}

String PlayerObjectAdapter::getScreenPlayData(const String& screenPlay, const String& variable) const {
	return (static_cast<PlayerObject*>(stub))->getScreenPlayData(screenPlay, variable);
}

void PlayerObjectAdapter::clearScreenPlayData(const String& screenPlay) {
	(static_cast<PlayerObject*>(stub))->clearScreenPlayData(screenPlay);
}

void PlayerObjectAdapter::activateRecovery() {
	(static_cast<PlayerObject*>(stub))->activateRecovery();
}

void PlayerObjectAdapter::activateForcePowerRegen() {
	(static_cast<PlayerObject*>(stub))->activateForcePowerRegen();
}

void PlayerObjectAdapter::doRecovery(int latency) {
	(static_cast<PlayerObject*>(stub))->doRecovery(latency);
}

void PlayerObjectAdapter::disconnect(bool closeClient, bool doLock) {
	(static_cast<PlayerObject*>(stub))->disconnect(closeClient, doLock);
}

void PlayerObjectAdapter::reload(ZoneClientSession* client) {
	(static_cast<PlayerObject*>(stub))->reload(client);
}

void PlayerObjectAdapter::setOffline() {
	(static_cast<PlayerObject*>(stub))->setOffline();
}

void PlayerObjectAdapter::setLinkDead(bool isSafeLogout) {
	(static_cast<PlayerObject*>(stub))->setLinkDead(isSafeLogout);
}

void PlayerObjectAdapter::setOnline() {
	(static_cast<PlayerObject*>(stub))->setOnline();
}

void PlayerObjectAdapter::setLoggingOut() {
	(static_cast<PlayerObject*>(stub))->setLoggingOut();
}

void PlayerObjectAdapter::activateJournalQuest(unsigned int questCrc, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->activateJournalQuest(questCrc, notifyClient);
}

void PlayerObjectAdapter::completeJournalQuest(unsigned int questCrc, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->completeJournalQuest(questCrc, notifyClient);
}

void PlayerObjectAdapter::clearJournalQuest(unsigned int questCrc, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->clearJournalQuest(questCrc, notifyClient);
}

void PlayerObjectAdapter::activateJournalQuestTask(unsigned int questCrc, int taskNum, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->activateJournalQuestTask(questCrc, taskNum, notifyClient);
}

void PlayerObjectAdapter::completeJournalQuestTask(unsigned int questCrc, int taskNum, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->completeJournalQuestTask(questCrc, taskNum, notifyClient);
}

void PlayerObjectAdapter::clearJournalQuestTask(unsigned int questCrc, int taskNum, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->clearJournalQuestTask(questCrc, taskNum, notifyClient);
}

bool PlayerObjectAdapter::isJournalQuestActive(unsigned int questCrc) {
	return (static_cast<PlayerObject*>(stub))->isJournalQuestActive(questCrc);
}

bool PlayerObjectAdapter::isJournalQuestComplete(unsigned int questCrc) {
	return (static_cast<PlayerObject*>(stub))->isJournalQuestComplete(questCrc);
}

bool PlayerObjectAdapter::isJournalQuestTaskActive(unsigned int questCrc, int taskNum) {
	return (static_cast<PlayerObject*>(stub))->isJournalQuestTaskActive(questCrc, taskNum);
}

bool PlayerObjectAdapter::isJournalQuestTaskComplete(unsigned int questCrc, int taskNum) {
	return (static_cast<PlayerObject*>(stub))->isJournalQuestTaskComplete(questCrc, taskNum);
}

void PlayerObjectAdapter::sendBadgesResponseTo(CreatureObject* player) {
	(static_cast<PlayerObject*>(stub))->sendBadgesResponseTo(player);
}

void PlayerObjectAdapter::logout(bool doLock) {
	(static_cast<PlayerObject*>(stub))->logout(doLock);
}

void PlayerObjectAdapter::setJediState(int state, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->setJediState(state, notifyClient);
}

void PlayerObjectAdapter::setActiveQuestsBit(int bitIndex, byte value, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->setActiveQuestsBit(bitIndex, value, notifyClient);
}

void PlayerObjectAdapter::clearActiveQuestsBit(int bitIndex, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->clearActiveQuestsBit(bitIndex, notifyClient);
}

bool PlayerObjectAdapter::canActivateQuest(int questID) {
	return (static_cast<PlayerObject*>(stub))->canActivateQuest(questID);
}

void PlayerObjectAdapter::activateQuest(int questID) {
	(static_cast<PlayerObject*>(stub))->activateQuest(questID);
}

bool PlayerObjectAdapter::hasActiveQuestBitSet(int bitIndex) const {
	return (static_cast<PlayerObject*>(stub))->hasActiveQuestBitSet(bitIndex);
}

bool PlayerObjectAdapter::hasCompletedQuestsBitSet(int bitIndex) const {
	return (static_cast<PlayerObject*>(stub))->hasCompletedQuestsBitSet(bitIndex);
}

void PlayerObjectAdapter::setCompletedQuestsBit(int bitIndex, byte value, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->setCompletedQuestsBit(bitIndex, value, notifyClient);
}

void PlayerObjectAdapter::clearCompletedQuestsBit(int bitIndex, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->clearCompletedQuestsBit(bitIndex, notifyClient);
}

void PlayerObjectAdapter::completeQuest(int questID) {
	(static_cast<PlayerObject*>(stub))->completeQuest(questID);
}

bool PlayerObjectAdapter::hasQuestData(unsigned int questCrc) const {
	return (static_cast<PlayerObject*>(stub))->hasQuestData(questCrc);
}

void PlayerObjectAdapter::setLastNpcConvStr(const String& conv) {
	(static_cast<PlayerObject*>(stub))->setLastNpcConvStr(conv);
}

void PlayerObjectAdapter::setLastNpcConvMessStr(const String& mess) {
	(static_cast<PlayerObject*>(stub))->setLastNpcConvMessStr(mess);
}

String PlayerObjectAdapter::getLastNpcConvStr() const {
	return (static_cast<PlayerObject*>(stub))->getLastNpcConvStr();
}

String PlayerObjectAdapter::getLastNpcConvMessStr() const {
	return (static_cast<PlayerObject*>(stub))->getLastNpcConvMessStr();
}

String PlayerObjectAdapter::getLastNpcConvOption(int idx) const {
	return (static_cast<PlayerObject*>(stub))->getLastNpcConvOption(idx);
}

void PlayerObjectAdapter::addLastNpcConvOptions(const String& option) {
	(static_cast<PlayerObject*>(stub))->addLastNpcConvOptions(option);
}

int PlayerObjectAdapter::countLastNpcConvOptions() const {
	return (static_cast<PlayerObject*>(stub))->countLastNpcConvOptions();
}

void PlayerObjectAdapter::clearLastNpcConvOptions() {
	(static_cast<PlayerObject*>(stub))->clearLastNpcConvOptions();
}

void PlayerObjectAdapter::setConversatingCreature(CreatureObject* creature) {
	(static_cast<PlayerObject*>(stub))->setConversatingCreature(creature);
}

unsigned long long PlayerObjectAdapter::getConversatingCreature() const {
	return (static_cast<PlayerObject*>(stub))->getConversatingCreature();
}

void PlayerObjectAdapter::setTrainerZoneName(String& zoneName) {
	(static_cast<PlayerObject*>(stub))->setTrainerZoneName(zoneName);
}

String PlayerObjectAdapter::getTrainerZoneName() const {
	return (static_cast<PlayerObject*>(stub))->getTrainerZoneName();
}

void PlayerObjectAdapter::addPersistentMessage(unsigned long long id) {
	(static_cast<PlayerObject*>(stub))->addPersistentMessage(id);
}

void PlayerObjectAdapter::dropPersistentMessage(unsigned long long id) {
	(static_cast<PlayerObject*>(stub))->dropPersistentMessage(id);
}

void PlayerObjectAdapter::unloadSpawnedChildren() {
	(static_cast<PlayerObject*>(stub))->unloadSpawnedChildren();
}

void PlayerObjectAdapter::addToConsentList(const String& name) {
	(static_cast<PlayerObject*>(stub))->addToConsentList(name);
}

bool PlayerObjectAdapter::hasInConsentList(const String& name) const {
	return (static_cast<PlayerObject*>(stub))->hasInConsentList(name);
}

void PlayerObjectAdapter::removeFromConsentList(const String& name) {
	(static_cast<PlayerObject*>(stub))->removeFromConsentList(name);
}

String PlayerObjectAdapter::getConsentName(int i) const {
	return (static_cast<PlayerObject*>(stub))->getConsentName(i);
}

int PlayerObjectAdapter::getConsentListSize() const {
	return (static_cast<PlayerObject*>(stub))->getConsentListSize();
}

int PlayerObjectAdapter::getReactionFines() const {
	return (static_cast<PlayerObject*>(stub))->getReactionFines();
}

String PlayerObjectAdapter::getFactionRank() const {
	return (static_cast<PlayerObject*>(stub))->getFactionRank();
}

void PlayerObjectAdapter::setCommandMessageString(unsigned int actionCRC, String& message) {
	(static_cast<PlayerObject*>(stub))->setCommandMessageString(actionCRC, message);
}

void PlayerObjectAdapter::removeCommandMessageString(unsigned int actionCRC) {
	(static_cast<PlayerObject*>(stub))->removeCommandMessageString(actionCRC);
}

unsigned long long PlayerObjectAdapter::getDeclaredResidence() const {
	return (static_cast<PlayerObject*>(stub))->getDeclaredResidence();
}

void PlayerObjectAdapter::setDeclaredResidence(BuildingObject* residence) {
	(static_cast<PlayerObject*>(stub))->setDeclaredResidence(residence);
}

void PlayerObjectAdapter::setCloningFacility(BuildingObject* cloningfac) {
	(static_cast<PlayerObject*>(stub))->setCloningFacility(cloningfac);
}

unsigned long long PlayerObjectAdapter::getCloningFacility() const {
	return (static_cast<PlayerObject*>(stub))->getCloningFacility();
}

void PlayerObjectAdapter::notifyOnline() {
	(static_cast<PlayerObject*>(stub))->notifyOnline();
}

void PlayerObjectAdapter::doDigest(int fillingReduction) {
	(static_cast<PlayerObject*>(stub))->doDigest(fillingReduction);
}

bool PlayerObjectAdapter::isDigesting() const {
	return (static_cast<PlayerObject*>(stub))->isDigesting();
}

String PlayerObjectAdapter::getSavedTerrainName() const {
	return (static_cast<PlayerObject*>(stub))->getSavedTerrainName();
}

void PlayerObjectAdapter::setSavedParentID(unsigned long long id) {
	(static_cast<PlayerObject*>(stub))->setSavedParentID(id);
}

void PlayerObjectAdapter::setSavedTerrainName(const String& name) {
	(static_cast<PlayerObject*>(stub))->setSavedTerrainName(name);
}

void PlayerObjectAdapter::setBirthDate(int date) {
	(static_cast<PlayerObject*>(stub))->setBirthDate(date);
}

void PlayerObjectAdapter::setForcePower(int fp, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->setForcePower(fp, notifyClient);
}

void PlayerObjectAdapter::setForcePowerMax(int newValue, bool notifyClient) {
	(static_cast<PlayerObject*>(stub))->setForcePowerMax(newValue, notifyClient);
}

void PlayerObjectAdapter::doForceRegen() {
	(static_cast<PlayerObject*>(stub))->doForceRegen();
}

void PlayerObjectAdapter::recalculateForcePower() {
	(static_cast<PlayerObject*>(stub))->recalculateForcePower();
}

int PlayerObjectAdapter::getForcePowerRegen() {
	return (static_cast<PlayerObject*>(stub))->getForcePowerRegen();
}

unsigned long long PlayerObjectAdapter::getSavedParentID() const {
	return (static_cast<PlayerObject*>(stub))->getSavedParentID();
}

unsigned int PlayerObjectAdapter::getNewSuiBoxID(unsigned int type) {
	return (static_cast<PlayerObject*>(stub))->getNewSuiBoxID(type);
}

bool PlayerObjectAdapter::hasSuiBox(unsigned int boxID) const {
	return (static_cast<PlayerObject*>(stub))->hasSuiBox(boxID);
}

Reference<SuiBox* > PlayerObjectAdapter::getSuiBox(unsigned int boxID) const {
	return (static_cast<PlayerObject*>(stub))->getSuiBox(boxID);
}

void PlayerObjectAdapter::removeSuiBox(unsigned int boxID, bool closeWindowToClient) {
	(static_cast<PlayerObject*>(stub))->removeSuiBox(boxID, closeWindowToClient);
}

void PlayerObjectAdapter::removeSuiBoxType(unsigned int windowType) {
	(static_cast<PlayerObject*>(stub))->removeSuiBoxType(windowType);
}

bool PlayerObjectAdapter::hasSuiBoxWindowType(unsigned int windowType) {
	return (static_cast<PlayerObject*>(stub))->hasSuiBoxWindowType(windowType);
}

void PlayerObjectAdapter::closeSuiWindowType(unsigned int windowType) {
	(static_cast<PlayerObject*>(stub))->closeSuiWindowType(windowType);
}

Reference<SuiBox* > PlayerObjectAdapter::getSuiBoxFromWindowType(unsigned int windowType) {
	return (static_cast<PlayerObject*>(stub))->getSuiBoxFromWindowType(windowType);
}

void PlayerObjectAdapter::addSuiBox(SuiBox* sui) {
	(static_cast<PlayerObject*>(stub))->addSuiBox(sui);
}

void PlayerObjectAdapter::addPermissionGroup(const String& group, bool updatePermissions) {
	(static_cast<PlayerObject*>(stub))->addPermissionGroup(group, updatePermissions);
}

void PlayerObjectAdapter::removePermissionGroup(const String& group, bool updatePermissions) {
	(static_cast<PlayerObject*>(stub))->removePermissionGroup(group, updatePermissions);
}

void PlayerObjectAdapter::updateInRangeBuildingPermissions() {
	(static_cast<PlayerObject*>(stub))->updateInRangeBuildingPermissions();
}

bool PlayerObjectAdapter::hasPermissionGroup(const String& group) const {
	return (static_cast<PlayerObject*>(stub))->hasPermissionGroup(group);
}

void PlayerObjectAdapter::addIncapacitationTime() {
	(static_cast<PlayerObject*>(stub))->addIncapacitationTime();
}

byte PlayerObjectAdapter::getIncapacitationCounter() const {
	return (static_cast<PlayerObject*>(stub))->getIncapacitationCounter();
}

void PlayerObjectAdapter::resetIncapacitationTimes() {
	(static_cast<PlayerObject*>(stub))->resetIncapacitationTimes();
}

void PlayerObjectAdapter::addToDuelList(CreatureObject* targetPlayer) {
	(static_cast<PlayerObject*>(stub))->addToDuelList(targetPlayer);
}

void PlayerObjectAdapter::removeFromDuelList(CreatureObject* targetPlayer) {
	(static_cast<PlayerObject*>(stub))->removeFromDuelList(targetPlayer);
}

Reference<CreatureObject* > PlayerObjectAdapter::getDuelListObject(int index) {
	return (static_cast<PlayerObject*>(stub))->getDuelListObject(index);
}

bool PlayerObjectAdapter::requestedDuelTo(CreatureObject* targetPlayer) const {
	return (static_cast<PlayerObject*>(stub))->requestedDuelTo(targetPlayer);
}

bool PlayerObjectAdapter::isDuelListEmpty() const {
	return (static_cast<PlayerObject*>(stub))->isDuelListEmpty();
}

int PlayerObjectAdapter::getDuelListSize() const {
	return (static_cast<PlayerObject*>(stub))->getDuelListSize();
}

void PlayerObjectAdapter::addToActivePets(AiAgent* pet) {
	(static_cast<PlayerObject*>(stub))->addToActivePets(pet);
}

void PlayerObjectAdapter::removeFromActivePets(AiAgent* pet) {
	(static_cast<PlayerObject*>(stub))->removeFromActivePets(pet);
}

AiAgent* PlayerObjectAdapter::getActivePet(int index) {
	return (static_cast<PlayerObject*>(stub))->getActivePet(index);
}

bool PlayerObjectAdapter::hasActivePet(AiAgent* pet) const {
	return (static_cast<PlayerObject*>(stub))->hasActivePet(pet);
}

int PlayerObjectAdapter::getActivePetsSize() const {
	return (static_cast<PlayerObject*>(stub))->getActivePetsSize();
}

UnicodeString PlayerObjectAdapter::getBiography() const {
	return (static_cast<PlayerObject*>(stub))->getBiography();
}

void PlayerObjectAdapter::notifyOffline() {
	(static_cast<PlayerObject*>(stub))->notifyOffline();
}

void PlayerObjectAdapter::resetSessionStats(bool isSessionStart) {
	(static_cast<PlayerObject*>(stub))->resetSessionStats(isSessionStart);
}

void PlayerObjectAdapter::incrementSessionMovement(float moveDelta) {
	(static_cast<PlayerObject*>(stub))->incrementSessionMovement(moveDelta);
}

void PlayerObjectAdapter::logSessionStats(bool isSessionEnd) {
	(static_cast<PlayerObject*>(stub))->logSessionStats(isSessionEnd);
}

void PlayerObjectAdapter::setBadge(unsigned int badge) {
	(static_cast<PlayerObject*>(stub))->setBadge(badge);
}

void PlayerObjectAdapter::revokeBadge(unsigned int badge) {
	(static_cast<PlayerObject*>(stub))->revokeBadge(badge);
}

void PlayerObjectAdapter::awardBadge(unsigned int badge) {
	(static_cast<PlayerObject*>(stub))->awardBadge(badge);
}

void PlayerObjectAdapter::setTeleporting(bool val) {
	(static_cast<PlayerObject*>(stub))->setTeleporting(val);
}

void PlayerObjectAdapter::setOnLoadScreen(bool val) {
	(static_cast<PlayerObject*>(stub))->setOnLoadScreen(val);
}

void PlayerObjectAdapter::setForcedTransform(bool val) {
	(static_cast<PlayerObject*>(stub))->setForcedTransform(val);
}

int PlayerObjectAdapter::getNumBadges() const {
	return (static_cast<PlayerObject*>(stub))->getNumBadges();
}

int PlayerObjectAdapter::getBadgeTypeCount(unsigned int type) const {
	return (static_cast<PlayerObject*>(stub))->getBadgeTypeCount(type);
}

bool PlayerObjectAdapter::hasFriend(const String& name) const {
	return (static_cast<PlayerObject*>(stub))->hasFriend(name);
}

int PlayerObjectAdapter::getFriendListSize() const {
	return (static_cast<PlayerObject*>(stub))->getFriendListSize();
}

bool PlayerObjectAdapter::isIgnoring(const String& name) const {
	return (static_cast<PlayerObject*>(stub))->isIgnoring(name);
}

void PlayerObjectAdapter::addReverseFriend(const String& name) {
	(static_cast<PlayerObject*>(stub))->addReverseFriend(name);
}

void PlayerObjectAdapter::removeReverseFriend(const String& name) {
	(static_cast<PlayerObject*>(stub))->removeReverseFriend(name);
}

void PlayerObjectAdapter::sendFriendLists() {
	(static_cast<PlayerObject*>(stub))->sendFriendLists();
}

bool PlayerObjectAdapter::hasAbility(const String& ability) const {
	return (static_cast<PlayerObject*>(stub))->hasAbility(ability);
}

bool PlayerObjectAdapter::hasCommandMessageString(unsigned int actionCRC) const {
	return (static_cast<PlayerObject*>(stub))->hasCommandMessageString(actionCRC);
}

String PlayerObjectAdapter::getTitle() const {
	return (static_cast<PlayerObject*>(stub))->getTitle();
}

unsigned int PlayerObjectAdapter::getAdminLevel() const {
	return (static_cast<PlayerObject*>(stub))->getAdminLevel();
}

void PlayerObjectAdapter::setAdminLevel(unsigned int adminlvl) {
	(static_cast<PlayerObject*>(stub))->setAdminLevel(adminlvl);
}

int PlayerObjectAdapter::getPriviledgeFlag() const {
	return (static_cast<PlayerObject*>(stub))->getPriviledgeFlag();
}

void PlayerObjectAdapter::setPriviledgeFlag(int flag) {
	(static_cast<PlayerObject*>(stub))->setPriviledgeFlag(flag);
}

void PlayerObjectAdapter::setBiography(const UnicodeString& bio) {
	(static_cast<PlayerObject*>(stub))->setBiography(bio);
}

bool PlayerObjectAdapter::hasGodMode() const {
	return (static_cast<PlayerObject*>(stub))->hasGodMode();
}

bool PlayerObjectAdapter::isPrivileged() const {
	return (static_cast<PlayerObject*>(stub))->isPrivileged();
}

bool PlayerObjectAdapter::isStaff() const {
	return (static_cast<PlayerObject*>(stub))->isStaff();
}

bool PlayerObjectAdapter::isAdmin() const {
	return (static_cast<PlayerObject*>(stub))->isAdmin();
}

bool PlayerObjectAdapter::setPlayerBit(unsigned int bit, bool notifyClient) {
	return (static_cast<PlayerObject*>(stub))->setPlayerBit(bit, notifyClient);
}

bool PlayerObjectAdapter::clearPlayerBit(unsigned int bit, bool notifyClient) {
	return (static_cast<PlayerObject*>(stub))->clearPlayerBit(bit, notifyClient);
}

void PlayerObjectAdapter::toggleCharacterBit(unsigned int bit) {
	(static_cast<PlayerObject*>(stub))->toggleCharacterBit(bit);
}

bool PlayerObjectAdapter::isLFG() const {
	return (static_cast<PlayerObject*>(stub))->isLFG();
}

bool PlayerObjectAdapter::isAFK() const {
	return (static_cast<PlayerObject*>(stub))->isAFK();
}

bool PlayerObjectAdapter::isAnonymous() const {
	return (static_cast<PlayerObject*>(stub))->isAnonymous();
}

bool PlayerObjectAdapter::isRoleplayer() const {
	return (static_cast<PlayerObject*>(stub))->isRoleplayer();
}

bool PlayerObjectAdapter::isNewbieHelper() const {
	return (static_cast<PlayerObject*>(stub))->isNewbieHelper();
}

int PlayerObjectAdapter::getTotalPlayedTime() const {
	return (static_cast<PlayerObject*>(stub))->getTotalPlayedTime();
}

int PlayerObjectAdapter::getForcePower() const {
	return (static_cast<PlayerObject*>(stub))->getForcePower();
}

int PlayerObjectAdapter::getForcePowerMax() const {
	return (static_cast<PlayerObject*>(stub))->getForcePowerMax();
}

DraftSchematic* PlayerObjectAdapter::getSchematic(int i) const {
	return (static_cast<PlayerObject*>(stub))->getSchematic(i);
}

int PlayerObjectAdapter::getFoodFilling() const {
	return (static_cast<PlayerObject*>(stub))->getFoodFilling();
}

int PlayerObjectAdapter::getFoodFillingMax() const {
	return (static_cast<PlayerObject*>(stub))->getFoodFillingMax();
}

int PlayerObjectAdapter::getDrinkFilling() const {
	return (static_cast<PlayerObject*>(stub))->getDrinkFilling();
}

int PlayerObjectAdapter::getDrinkFillingMax() const {
	return (static_cast<PlayerObject*>(stub))->getDrinkFillingMax();
}

int PlayerObjectAdapter::getJediState() const {
	return (static_cast<PlayerObject*>(stub))->getJediState();
}

byte PlayerObjectAdapter::getLanguageID() const {
	return (static_cast<PlayerObject*>(stub))->getLanguageID();
}

bool PlayerObjectAdapter::isTeleporting() const {
	return (static_cast<PlayerObject*>(stub))->isTeleporting();
}

bool PlayerObjectAdapter::isOnLoadScreen() const {
	return (static_cast<PlayerObject*>(stub))->isOnLoadScreen();
}

bool PlayerObjectAdapter::isForcedTransform() const {
	return (static_cast<PlayerObject*>(stub))->isForcedTransform();
}

void PlayerObjectAdapter::addChatRoom(unsigned int roomID) {
	(static_cast<PlayerObject*>(stub))->addChatRoom(roomID);
}

void PlayerObjectAdapter::removeChatRoom(unsigned int roomID) {
	(static_cast<PlayerObject*>(stub))->removeChatRoom(roomID);
}

void PlayerObjectAdapter::addOwnedChatRoom(unsigned int roomID) {
	(static_cast<PlayerObject*>(stub))->addOwnedChatRoom(roomID);
}

void PlayerObjectAdapter::removeOwnedChatRoom(unsigned int roomID) {
	(static_cast<PlayerObject*>(stub))->removeOwnedChatRoom(roomID);
}

int PlayerObjectAdapter::getOwnedChatRoomCount() {
	return (static_cast<PlayerObject*>(stub))->getOwnedChatRoomCount();
}

void PlayerObjectAdapter::setBankLocation(const String& location) {
	(static_cast<PlayerObject*>(stub))->setBankLocation(location);
}

String PlayerObjectAdapter::getBankLocation() const {
	return (static_cast<PlayerObject*>(stub))->getBankLocation();
}

int PlayerObjectAdapter::getExperience(const String& xp) const {
	return (static_cast<PlayerObject*>(stub))->getExperience(xp);
}

void PlayerObjectAdapter::maximizeExperience() {
	(static_cast<PlayerObject*>(stub))->maximizeExperience();
}

void PlayerObjectAdapter::activateMissions() {
	(static_cast<PlayerObject*>(stub))->activateMissions();
}

String PlayerObjectAdapter::getCommandMessageString(unsigned int actionCRC) const {
	return (static_cast<PlayerObject*>(stub))->getCommandMessageString(actionCRC);
}

bool PlayerObjectAdapter::hasBadge(unsigned int badge) const {
	return (static_cast<PlayerObject*>(stub))->hasBadge(badge);
}

void PlayerObjectAdapter::clearDisconnectEvent() {
	(static_cast<PlayerObject*>(stub))->clearDisconnectEvent();
}

bool PlayerObjectAdapter::isOnline() const {
	return (static_cast<PlayerObject*>(stub))->isOnline();
}

bool PlayerObjectAdapter::isOffline() const {
	return (static_cast<PlayerObject*>(stub))->isOffline();
}

bool PlayerObjectAdapter::isLinkDead() const {
	return (static_cast<PlayerObject*>(stub))->isLinkDead();
}

bool PlayerObjectAdapter::isLoggingOut() const {
	return (static_cast<PlayerObject*>(stub))->isLoggingOut();
}

void PlayerObjectAdapter::setSkillPoints(int points) {
	(static_cast<PlayerObject*>(stub))->setSkillPoints(points);
}

void PlayerObjectAdapter::addSkillPoints(int points) {
	(static_cast<PlayerObject*>(stub))->addSkillPoints(points);
}

int PlayerObjectAdapter::getSkillPoints() const {
	return (static_cast<PlayerObject*>(stub))->getSkillPoints();
}

void PlayerObjectAdapter::updateLastValidatedPosition() {
	(static_cast<PlayerObject*>(stub))->updateLastValidatedPosition();
}

unsigned int PlayerObjectAdapter::getAccountID() const {
	return (static_cast<PlayerObject*>(stub))->getAccountID();
}

unsigned long long PlayerObjectAdapter::getServerMovementTimeDelta() const {
	return (static_cast<PlayerObject*>(stub))->getServerMovementTimeDelta();
}

void PlayerObjectAdapter::setClientLastMovementStamp(unsigned int stamp) {
	(static_cast<PlayerObject*>(stub))->setClientLastMovementStamp(stamp);
}

void PlayerObjectAdapter::updateServerLastMovementStamp() {
	(static_cast<PlayerObject*>(stub))->updateServerLastMovementStamp();
}

void PlayerObjectAdapter::setAccountID(unsigned int id) {
	(static_cast<PlayerObject*>(stub))->setAccountID(id);
}

unsigned int PlayerObjectAdapter::getClientLastMovementStamp() const {
	return (static_cast<PlayerObject*>(stub))->getClientLastMovementStamp();
}

void PlayerObjectAdapter::addHologrindProfession(byte prof) {
	(static_cast<PlayerObject*>(stub))->addHologrindProfession(prof);
}

void PlayerObjectAdapter::setMaximumLots(byte lots) {
	(static_cast<PlayerObject*>(stub))->setMaximumLots(lots);
}

byte PlayerObjectAdapter::getMaximumLots() const {
	return (static_cast<PlayerObject*>(stub))->getMaximumLots();
}

String PlayerObjectAdapter::getStarterProfession() const {
	return (static_cast<PlayerObject*>(stub))->getStarterProfession();
}

void PlayerObjectAdapter::setStarterProfession(String& profession) {
	(static_cast<PlayerObject*>(stub))->setStarterProfession(profession);
}

unsigned long long PlayerObjectAdapter::getPerformanceBuffTarget() const {
	return (static_cast<PlayerObject*>(stub))->getPerformanceBuffTarget();
}

void PlayerObjectAdapter::setPerformanceBuffTarget(unsigned long long target) {
	(static_cast<PlayerObject*>(stub))->setPerformanceBuffTarget(target);
}

void PlayerObjectAdapter::setDebug(bool value) {
	(static_cast<PlayerObject*>(stub))->setDebug(value);
}

bool PlayerObjectAdapter::getDebug() const {
	return (static_cast<PlayerObject*>(stub))->getDebug();
}

float PlayerObjectAdapter::getVisibility() const {
	return (static_cast<PlayerObject*>(stub))->getVisibility();
}

void PlayerObjectAdapter::setVisibility(float value) {
	(static_cast<PlayerObject*>(stub))->setVisibility(value);
}

void PlayerObjectAdapter::updateLastCombatActionTimestamp(bool updateGcwCrackdownAction, bool updateGcwAction, bool updateBhAction) {
	(static_cast<PlayerObject*>(stub))->updateLastCombatActionTimestamp(updateGcwCrackdownAction, updateGcwAction, updateBhAction);
}

void PlayerObjectAdapter::updateLastBhPvpCombatActionTimestamp() {
	(static_cast<PlayerObject*>(stub))->updateLastBhPvpCombatActionTimestamp();
}

void PlayerObjectAdapter::updateLastGcwPvpCombatActionTimestamp() {
	(static_cast<PlayerObject*>(stub))->updateLastGcwPvpCombatActionTimestamp();
}

void PlayerObjectAdapter::updateLastPvpAreaCombatActionTimestamp() {
	(static_cast<PlayerObject*>(stub))->updateLastPvpAreaCombatActionTimestamp();
}

bool PlayerObjectAdapter::hasTef() const {
	return (static_cast<PlayerObject*>(stub))->hasTef();
}

bool PlayerObjectAdapter::hasPvpTef() const {
	return (static_cast<PlayerObject*>(stub))->hasPvpTef();
}

bool PlayerObjectAdapter::hasGcwTef() const {
	return (static_cast<PlayerObject*>(stub))->hasGcwTef();
}

bool PlayerObjectAdapter::hasBhTef() const {
	return (static_cast<PlayerObject*>(stub))->hasBhTef();
}

void PlayerObjectAdapter::setCrackdownTefTowards(unsigned int factionCrc, bool scheduleTefRemovalTask) {
	(static_cast<PlayerObject*>(stub))->setCrackdownTefTowards(factionCrc, scheduleTefRemovalTask);
}

bool PlayerObjectAdapter::hasCrackdownTefTowards(unsigned int factionCrc) const {
	return (static_cast<PlayerObject*>(stub))->hasCrackdownTefTowards(factionCrc);
}

bool PlayerObjectAdapter::hasCrackdownTef() const {
	return (static_cast<PlayerObject*>(stub))->hasCrackdownTef();
}

void PlayerObjectAdapter::schedulePvpTefRemovalTask(bool removeCrackdownGcwTefNow, bool removeGcwTefNow, bool removeBhTefNow) {
	(static_cast<PlayerObject*>(stub))->schedulePvpTefRemovalTask(removeCrackdownGcwTefNow, removeGcwTefNow, removeBhTefNow);
}

void PlayerObjectAdapter::schedulePvpTefRemovalTask(bool removeNow) {
	(static_cast<PlayerObject*>(stub))->schedulePvpTefRemovalTask(removeNow);
}

bool PlayerObjectAdapter::isInPvpArea(bool checkTime) {
	return (static_cast<PlayerObject*>(stub))->isInPvpArea(checkTime);
}

void PlayerObjectAdapter::addVendor(SceneObject* vendor) {
	(static_cast<PlayerObject*>(stub))->addVendor(vendor);
}

void PlayerObjectAdapter::removeVendor(SceneObject* vendor) {
	(static_cast<PlayerObject*>(stub))->removeVendor(vendor);
}

int PlayerObjectAdapter::getVendorCount() {
	return (static_cast<PlayerObject*>(stub))->getVendorCount();
}

void PlayerObjectAdapter::destroyObjectFromDatabase(bool destroyContainedObjects) {
	(static_cast<PlayerObject*>(stub))->destroyObjectFromDatabase(destroyContainedObjects);
}

void PlayerObjectAdapter::deleteAllPersistentMessages() {
	(static_cast<PlayerObject*>(stub))->deleteAllPersistentMessages();
}

bool PlayerObjectAdapter::isJedi() const {
	return (static_cast<PlayerObject*>(stub))->isJedi();
}

bool PlayerObjectAdapter::isJediLight() const {
	return (static_cast<PlayerObject*>(stub))->isJediLight();
}

bool PlayerObjectAdapter::isJediDark() const {
	return (static_cast<PlayerObject*>(stub))->isJediDark();
}

bool PlayerObjectAdapter::isMuted() const {
	return (static_cast<PlayerObject*>(stub))->isMuted();
}

void PlayerObjectAdapter::setMutedState(bool mute) {
	(static_cast<PlayerObject*>(stub))->setMutedState(mute);
}

String PlayerObjectAdapter::getMutedReason() const {
	return (static_cast<PlayerObject*>(stub))->getMutedReason();
}

void PlayerObjectAdapter::setMutedReason(String& reason) {
	(static_cast<PlayerObject*>(stub))->setMutedReason(reason);
}

String PlayerObjectAdapter::getInstalledHoloEmote() const {
	return (static_cast<PlayerObject*>(stub))->getInstalledHoloEmote();
}

void PlayerObjectAdapter::setInstalledHoloEmote(String& holoEmote) {
	(static_cast<PlayerObject*>(stub))->setInstalledHoloEmote(holoEmote);
}

void PlayerObjectAdapter::removeInstalledHoloEmote() {
	(static_cast<PlayerObject*>(stub))->removeInstalledHoloEmote();
}

int PlayerObjectAdapter::getHoloEmoteUseCount() const {
	return (static_cast<PlayerObject*>(stub))->getHoloEmoteUseCount();
}

void PlayerObjectAdapter::decreaseHoloEmoteUseCount() {
	(static_cast<PlayerObject*>(stub))->decreaseHoloEmoteUseCount();
}

bool PlayerObjectAdapter::isMarried() const {
	return (static_cast<PlayerObject*>(stub))->isMarried();
}

String PlayerObjectAdapter::getSpouseName() const {
	return (static_cast<PlayerObject*>(stub))->getSpouseName();
}

void PlayerObjectAdapter::setSpouseName(String& firstName) {
	(static_cast<PlayerObject*>(stub))->setSpouseName(firstName);
}

void PlayerObjectAdapter::removeSpouse() {
	(static_cast<PlayerObject*>(stub))->removeSpouse();
}

Account* PlayerObjectAdapter::getAccount() {
	return (static_cast<PlayerObject*>(stub))->getAccount();
}

String PlayerObjectAdapter::getChosenVeteranReward(unsigned int milestone) const {
	return (static_cast<PlayerObject*>(stub))->getChosenVeteranReward(milestone);
}

bool PlayerObjectAdapter::hasChosenVeteranReward(const String& rewardTemplate) const {
	return (static_cast<PlayerObject*>(stub))->hasChosenVeteranReward(rewardTemplate);
}

void PlayerObjectAdapter::clearVeteranReward(unsigned int milestone) {
	(static_cast<PlayerObject*>(stub))->clearVeteranReward(milestone);
}

void PlayerObjectAdapter::addEventPerk(SceneObject* deed) {
	(static_cast<PlayerObject*>(stub))->addEventPerk(deed);
}

void PlayerObjectAdapter::removeEventPerk(SceneObject* deed) {
	(static_cast<PlayerObject*>(stub))->removeEventPerk(deed);
}

int PlayerObjectAdapter::getEventPerkCount() const {
	return (static_cast<PlayerObject*>(stub))->getEventPerkCount();
}

int PlayerObjectAdapter::getCharacterAgeInDays() {
	return (static_cast<PlayerObject*>(stub))->getCharacterAgeInDays();
}

int PlayerObjectAdapter::getBirthDate() {
	return (static_cast<PlayerObject*>(stub))->getBirthDate();
}

void PlayerObjectAdapter::addToReactionFines(int fine) {
	(static_cast<PlayerObject*>(stub))->addToReactionFines(fine);
}

void PlayerObjectAdapter::setReactionFines(int amount) {
	(static_cast<PlayerObject*>(stub))->setReactionFines(amount);
}

void PlayerObjectAdapter::subtractFromReactionFines(int amount) {
	(static_cast<PlayerObject*>(stub))->subtractFromReactionFines(amount);
}

void PlayerObjectAdapter::updateReactionFineTimestamp() {
	(static_cast<PlayerObject*>(stub))->updateReactionFineTimestamp();
}

void PlayerObjectAdapter::updateReactionFineMailTimestamp() {
	(static_cast<PlayerObject*>(stub))->updateReactionFineMailTimestamp();
}

int PlayerObjectAdapter::getXpCap(const String& type) const {
	return (static_cast<PlayerObject*>(stub))->getXpCap(type);
}

int PlayerObjectAdapter::getSpentJediSkillPoints() {
	return (static_cast<PlayerObject*>(stub))->getSpentJediSkillPoints();
}

bool PlayerObjectAdapter::hasSchematic(DraftSchematic* schematic) const {
	return (static_cast<PlayerObject*>(stub))->hasSchematic(schematic);
}

bool PlayerObjectAdapter::hasEventPerk(const String& templatePath) const {
	return (static_cast<PlayerObject*>(stub))->hasEventPerk(templatePath);
}

void PlayerObjectAdapter::doFieldFactionChange(int newStatus) {
	(static_cast<PlayerObject*>(stub))->doFieldFactionChange(newStatus);
}

void PlayerObjectAdapter::addToVictimList(unsigned int playerID) {
	(static_cast<PlayerObject*>(stub))->addToVictimList(playerID);
}

bool PlayerObjectAdapter::hasOnVictimList(unsigned int playerID) {
	return (static_cast<PlayerObject*>(stub))->hasOnVictimList(playerID);
}

int PlayerObjectAdapter::getPvpRating() const {
	return (static_cast<PlayerObject*>(stub))->getPvpRating();
}

void PlayerObjectAdapter::setPvpRating(int rating) {
	(static_cast<PlayerObject*>(stub))->setPvpRating(rating);
}

bool PlayerObjectAdapter::isCloning() const {
	return (static_cast<PlayerObject*>(stub))->isCloning();
}

void PlayerObjectAdapter::setCloning(bool val) {
	(static_cast<PlayerObject*>(stub))->setCloning(val);
}

unsigned long long PlayerObjectAdapter::getPlayedMiliSecs() const {
	return (static_cast<PlayerObject*>(stub))->getPlayedMiliSecs();
}

unsigned long long PlayerObjectAdapter::getSessionMiliSecs() const {
	return (static_cast<PlayerObject*>(stub))->getSessionMiliSecs();
}

unsigned long long PlayerObjectAdapter::getSessionTotalMovement() const {
	return (static_cast<PlayerObject*>(stub))->getSessionTotalMovement();
}

long long PlayerObjectAdapter::getSessionTotalCredits() const {
	return (static_cast<PlayerObject*>(stub))->getSessionTotalCredits();
}

String PlayerObjectAdapter::getMiliSecsTimeString(unsigned long long miliSecs, bool verbose) const {
	return (static_cast<PlayerObject*>(stub))->getMiliSecsTimeString(miliSecs, verbose);
}

String PlayerObjectAdapter::getPlayedTimeString(bool verbose) const {
	return (static_cast<PlayerObject*>(stub))->getPlayedTimeString(verbose);
}

/*
 *	PlayerObjectHelper
 */

PlayerObjectHelper* PlayerObjectHelper::staticInitializer = PlayerObjectHelper::instance();

PlayerObjectHelper::PlayerObjectHelper() {
	className = "PlayerObject";

	Core::getObjectBroker()->registerClass(className, this);
}

void PlayerObjectHelper::finalizeHelper() {
	PlayerObjectHelper::finalize();
}

DistributedObject* PlayerObjectHelper::instantiateObject() {
	return new PlayerObject(DummyConstructorParameter::instance());
}

DistributedObjectServant* PlayerObjectHelper::instantiateServant() {
	return new PlayerObjectImplementation();
}

DistributedObjectPOD* PlayerObjectHelper::instantiatePOD() {
	return new PlayerObjectPOD();
}

DistributedObjectAdapter* PlayerObjectHelper::createAdapter(DistributedObjectStub* obj) {
	DistributedObjectAdapter* adapter = new PlayerObjectAdapter(static_cast<PlayerObject*>(obj));

	obj->_setClassName(className);
	obj->_setClassHelper(this);

	adapter->setStub(obj);

	return adapter;
}

/*
 *	PlayerObjectPOD
 */

PlayerObjectPOD::~PlayerObjectPOD() {
	finalize();
}

PlayerObjectPOD::PlayerObjectPOD(void) {
	_className = "PlayerObject";
}


void PlayerObjectPOD::writeJSON(nlohmann::json& j) {
	IntangibleObjectPOD::writeJSON(j);

	nlohmann::json thisObject = nlohmann::json::object();
	if (playerLogLevel)
		thisObject["playerLogLevel"] = playerLogLevel.value();

	if (playerBitmask)
		thisObject["playerBitmask"] = playerBitmask.value();

	if (title)
		thisObject["title"] = title.value();

	if (savedTerrainName)
		thisObject["savedTerrainName"] = savedTerrainName.value();

	if (savedParentID)
		thisObject["savedParentID"] = savedParentID.value();

	if (badges)
		thisObject["badges"] = badges.value();

	if (birthDate)
		thisObject["birthDate"] = birthDate.value();

	if (forcePower)
		thisObject["forcePower"] = forcePower.value();

	if (forcePowerMax)
		thisObject["forcePowerMax"] = forcePowerMax.value();

	if (foodFilling)
		thisObject["foodFilling"] = foodFilling.value();

	if (foodFillingMax)
		thisObject["foodFillingMax"] = foodFillingMax.value();

	if (drinkFilling)
		thisObject["drinkFilling"] = drinkFilling.value();

	if (drinkFillingMax)
		thisObject["drinkFillingMax"] = drinkFillingMax.value();

	if (reactionFines)
		thisObject["reactionFines"] = reactionFines.value();

	if (reactionFineTimestamp)
		thisObject["reactionFineTimestamp"] = reactionFineTimestamp.value();

	if (reactionFineMailTimestamp)
		thisObject["reactionFineMailTimestamp"] = reactionFineMailTimestamp.value();

	if (starterProfession)
		thisObject["starterProfession"] = starterProfession.value();

	if (bankLocation)
		thisObject["bankLocation"] = bankLocation.value();

	if (teleporting)
		thisObject["teleporting"] = teleporting.value();

	if (onLoadScreen)
		thisObject["onLoadScreen"] = onLoadScreen.value();

	if (forcedTransform)
		thisObject["forcedTransform"] = forcedTransform.value();

	if (muted)
		thisObject["muted"] = muted.value();

	if (mutedReason)
		thisObject["mutedReason"] = mutedReason.value();

	if (tosVersionAccepted)
		thisObject["tosVersionAccepted"] = tosVersionAccepted.value();

	if (ownedStructures)
		thisObject["ownedStructures"] = ownedStructures.value();

	if (ownedVendors)
		thisObject["ownedVendors"] = ownedVendors.value();

	if (maximumLots)
		thisObject["maximumLots"] = maximumLots.value();

	if (jediState)
		thisObject["jediState"] = jediState.value();

	if (adminLevel)
		thisObject["adminLevel"] = adminLevel.value();

	if (priviledgeFlag)
		thisObject["priviledgeFlag"] = priviledgeFlag.value();

	if (languageID)
		thisObject["languageID"] = languageID.value();

	if (xpTypeCapList)
		thisObject["xpTypeCapList"] = xpTypeCapList.value();

	if (commandMessageStrings)
		thisObject["commandMessageStrings"] = commandMessageStrings.value();

	if (experienceList)
		thisObject["experienceList"] = experienceList.value();

	if (frsData)
		thisObject["frsData"] = frsData.value();

	if (waypointList)
		thisObject["waypointList"] = waypointList.value();

	if (abilityList)
		thisObject["abilityList"] = abilityList.value();

	if (friendList)
		thisObject["friendList"] = friendList.value();

	if (ignoreList)
		thisObject["ignoreList"] = ignoreList.value();

	if (factionStandingList)
		thisObject["factionStandingList"] = factionStandingList.value();

	if (schematicList)
		thisObject["schematicList"] = schematicList.value();

	if (incapacitationTimes)
		thisObject["incapacitationTimes"] = incapacitationTimes.value();

	if (suiBoxNextID)
		thisObject["suiBoxNextID"] = suiBoxNextID.value();

	if (suiBoxes)
		thisObject["suiBoxes"] = suiBoxes.value();

	if (chatRooms)
		thisObject["chatRooms"] = chatRooms.value();

	if (ownedChatRooms)
		thisObject["ownedChatRooms"] = ownedChatRooms.value();

	if (victimList)
		thisObject["victimList"] = victimList.value();

	if (declaredResidence)
		thisObject["declaredResidence"] = declaredResidence.value();

	if (cloningFacility)
		thisObject["cloningFacility"] = cloningFacility.value();

	if (isPlayerCloning)
		thisObject["isPlayerCloning"] = isPlayerCloning.value();

	if (persistentMessages)
		thisObject["persistentMessages"] = persistentMessages.value();

	if (biography)
		thisObject["biography"] = biography.value();

	if (consentList)
		thisObject["consentList"] = consentList.value();

	if (lastNpcConvoMessage)
		thisObject["lastNpcConvoMessage"] = lastNpcConvoMessage.value();

	if (lastNpcConvo)
		thisObject["lastNpcConvo"] = lastNpcConvo.value();

	if (lastNpcConvoOptions)
		thisObject["lastNpcConvoOptions"] = lastNpcConvoOptions.value();

	if (conversatingCreature)
		thisObject["conversatingCreature"] = conversatingCreature.value();

	if (trainerCoordinates)
		thisObject["trainerCoordinates"] = trainerCoordinates.value();

	if (lastLogoutWorldPosition)
		thisObject["lastLogoutWorldPosition"] = lastLogoutWorldPosition.value();

	if (trainerZoneName)
		thisObject["trainerZoneName"] = trainerZoneName.value();

	if (logoutTimeStamp)
		thisObject["logoutTimeStamp"] = logoutTimeStamp.value();

	if (onlineStatus)
		thisObject["onlineStatus"] = onlineStatus.value();

	if (skillPoints)
		thisObject["skillPoints"] = skillPoints.value();

	if (pvpRating)
		thisObject["pvpRating"] = pvpRating.value();

	if (lastPvpRatingUpdate)
		thisObject["lastPvpRatingUpdate"] = lastPvpRatingUpdate.value();

	if (hologrindProfessions)
		thisObject["hologrindProfessions"] = hologrindProfessions.value();

	if (clientLastMovementStamp)
		thisObject["clientLastMovementStamp"] = clientLastMovementStamp.value();

	if (serverLastMovementStamp)
		thisObject["serverLastMovementStamp"] = serverLastMovementStamp.value();

	if (lastValidatedPosition)
		thisObject["lastValidatedPosition"] = lastValidatedPosition.value();

	if (accountID)
		thisObject["accountID"] = accountID.value();

	if (screenPlayData)
		thisObject["screenPlayData"] = screenPlayData.value();

	if (permissionGroups)
		thisObject["permissionGroups"] = permissionGroups.value();

	if (performanceBuffTarget)
		thisObject["performanceBuffTarget"] = performanceBuffTarget.value();

	if (debugOutput)
		thisObject["debugOutput"] = debugOutput.value();

	if (visibility)
		thisObject["visibility"] = visibility.value();

	if (lastVisibilityUpdateTimestamp)
		thisObject["lastVisibilityUpdateTimestamp"] = lastVisibilityUpdateTimestamp.value();

	if (lastBhPvpCombatActionTimestamp)
		thisObject["lastBhPvpCombatActionTimestamp"] = lastBhPvpCombatActionTimestamp.value();

	if (lastGcwPvpCombatActionTimestamp)
		thisObject["lastGcwPvpCombatActionTimestamp"] = lastGcwPvpCombatActionTimestamp.value();

	if (lastCrackdownGcwCombatActionTimestamp)
		thisObject["lastCrackdownGcwCombatActionTimestamp"] = lastCrackdownGcwCombatActionTimestamp.value();

	if (lastPvpAreaCombatActionTimestamp)
		thisObject["lastPvpAreaCombatActionTimestamp"] = lastPvpAreaCombatActionTimestamp.value();

	if (crackdownFactionTefCrc)
		thisObject["crackdownFactionTefCrc"] = crackdownFactionTefCrc.value();

	if (lastDigestion)
		thisObject["lastDigestion"] = lastDigestion.value();

	if (activePets)
		thisObject["activePets"] = activePets.value();

	if (activeQuests)
		thisObject["activeQuests"] = activeQuests.value();

	if (completedQuests)
		thisObject["completedQuests"] = completedQuests.value();

	if (installedHoloEmote)
		thisObject["installedHoloEmote"] = installedHoloEmote.value();

	if (holoEmoteUseCount)
		thisObject["holoEmoteUseCount"] = holoEmoteUseCount.value();

	if (spouseName)
		thisObject["spouseName"] = spouseName.value();

	if (chosenVeteranRewards)
		thisObject["chosenVeteranRewards"] = chosenVeteranRewards.value();

	if (currentEventPerks)
		thisObject["currentEventPerks"] = currentEventPerks.value();

	if (playerQuestsData)
		thisObject["playerQuestsData"] = playerQuestsData.value();

	if (miliSecsPlayed)
		thisObject["miliSecsPlayed"] = miliSecsPlayed.value();

	if (miliSecsSession)
		thisObject["miliSecsSession"] = miliSecsSession.value();

	if (sessionStatsMiliSecs)
		thisObject["sessionStatsMiliSecs"] = sessionStatsMiliSecs.value();

	j["PlayerObject"] = thisObject;
}


void PlayerObjectPOD::writeObject(ObjectOutputStream* stream) {
	int _currentOffset = stream->getOffset();
	stream->writeShort(0);
	int _varCount = PlayerObjectPOD::writeObjectMembers(stream);
	stream->writeShort(_currentOffset, _varCount);
}

int PlayerObjectPOD::writeObjectMembers(ObjectOutputStream* stream) {
	int _count = IntangibleObjectPOD::writeObjectMembers(stream);

	uint32 _nameHashCode;
	int _offset;
	uint32 _totalSize;
	if (playerLogLevel) {
	_nameHashCode = 0x63ca6d5f; //PlayerObject.playerLogLevel
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&playerLogLevel.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (playerBitmask) {
	_nameHashCode = 0x3cc091f4; //PlayerObject.playerBitmask
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<PlayerBitmasks >::toBinaryStream(&playerBitmask.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (title) {
	_nameHashCode = 0x3f59dd69; //PlayerObject.title
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&title.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (savedTerrainName) {
	_nameHashCode = 0x80839c38; //PlayerObject.savedTerrainName
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&savedTerrainName.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (savedParentID) {
	_nameHashCode = 0x185d8184; //PlayerObject.savedParentID
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&savedParentID.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (badges) {
	_nameHashCode = 0xbf409c6b; //PlayerObject.badges
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Badges >::toBinaryStream(&badges.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (birthDate) {
	_nameHashCode = 0x5747cad2; //PlayerObject.birthDate
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&birthDate.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (forcePower) {
	_nameHashCode = 0x6f0f168c; //PlayerObject.forcePower
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&forcePower.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (forcePowerMax) {
	_nameHashCode = 0x626f8b12; //PlayerObject.forcePowerMax
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&forcePowerMax.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (foodFilling) {
	_nameHashCode = 0xd9b9f82b; //PlayerObject.foodFilling
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&foodFilling.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (foodFillingMax) {
	_nameHashCode = 0xa5fa3768; //PlayerObject.foodFillingMax
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&foodFillingMax.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (drinkFilling) {
	_nameHashCode = 0xe620a523; //PlayerObject.drinkFilling
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&drinkFilling.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (drinkFillingMax) {
	_nameHashCode = 0x37da084; //PlayerObject.drinkFillingMax
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&drinkFillingMax.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (reactionFines) {
	_nameHashCode = 0xe59e7515; //PlayerObject.reactionFines
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&reactionFines.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (reactionFineTimestamp) {
	_nameHashCode = 0x911499de; //PlayerObject.reactionFineTimestamp
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Time >::toBinaryStream(&reactionFineTimestamp.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (reactionFineMailTimestamp) {
	_nameHashCode = 0x89dba2ac; //PlayerObject.reactionFineMailTimestamp
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Time >::toBinaryStream(&reactionFineMailTimestamp.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (starterProfession) {
	_nameHashCode = 0x68888ebc; //PlayerObject.starterProfession
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&starterProfession.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (bankLocation) {
	_nameHashCode = 0xf7e4755e; //PlayerObject.bankLocation
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&bankLocation.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (teleporting) {
	_nameHashCode = 0x7a19894f; //PlayerObject.teleporting
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&teleporting.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (onLoadScreen) {
	_nameHashCode = 0xcf0cd987; //PlayerObject.onLoadScreen
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&onLoadScreen.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (forcedTransform) {
	_nameHashCode = 0xdf6adf19; //PlayerObject.forcedTransform
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&forcedTransform.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (muted) {
	_nameHashCode = 0x9af4d57b; //PlayerObject.muted
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&muted.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (mutedReason) {
	_nameHashCode = 0x2ba211bc; //PlayerObject.mutedReason
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&mutedReason.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (tosVersionAccepted) {
	_nameHashCode = 0x28863ed2; //PlayerObject.tosVersionAccepted
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&tosVersionAccepted.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (ownedStructures) {
	_nameHashCode = 0x9151f1d3; //PlayerObject.ownedStructures
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<SortedVector<unsigned long long> >::toBinaryStream(&ownedStructures.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (ownedVendors) {
	_nameHashCode = 0x3f521607; //PlayerObject.ownedVendors
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<SortedVector<unsigned long long> >::toBinaryStream(&ownedVendors.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (maximumLots) {
	_nameHashCode = 0x9c2c0c3f; //PlayerObject.maximumLots
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<byte >::toBinaryStream(&maximumLots.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (jediState) {
	_nameHashCode = 0x39b2b254; //PlayerObject.jediState
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&jediState.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (adminLevel) {
	_nameHashCode = 0x4d1afa57; //PlayerObject.adminLevel
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned int >::toBinaryStream(&adminLevel.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (priviledgeFlag) {
	_nameHashCode = 0xdfba5208; //PlayerObject.priviledgeFlag
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&priviledgeFlag.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (languageID) {
	_nameHashCode = 0x45728d15; //PlayerObject.languageID
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<byte >::toBinaryStream(&languageID.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (xpTypeCapList) {
	_nameHashCode = 0x3737ff5f; //PlayerObject.xpTypeCapList
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<VectorMap<String, int> >::toBinaryStream(&xpTypeCapList.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (commandMessageStrings) {
	_nameHashCode = 0x890785df; //PlayerObject.commandMessageStrings
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<VectorMap<unsigned int, String> >::toBinaryStream(&commandMessageStrings.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (experienceList) {
	_nameHashCode = 0x33656264; //PlayerObject.experienceList
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<DeltaVectorMap<String, int> >::toBinaryStream(&experienceList.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (frsData) {
	_nameHashCode = 0xbcd9bd05; //PlayerObject.frsData
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<FrsData >::toBinaryStream(&frsData.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (waypointList) {
	_nameHashCode = 0xbd209913; //PlayerObject.waypointList
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<WaypointList >::toBinaryStream(&waypointList.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (abilityList) {
	_nameHashCode = 0x56e55cb2; //PlayerObject.abilityList
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<AbilityList >::toBinaryStream(&abilityList.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (friendList) {
	_nameHashCode = 0xdab57393; //PlayerObject.friendList
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<FriendList >::toBinaryStream(&friendList.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (ignoreList) {
	_nameHashCode = 0x4d1f2cfe; //PlayerObject.ignoreList
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<IgnoreList >::toBinaryStream(&ignoreList.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (factionStandingList) {
	_nameHashCode = 0x2ebfed5f; //PlayerObject.factionStandingList
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<FactionStandingList >::toBinaryStream(&factionStandingList.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (schematicList) {
	_nameHashCode = 0x42645912; //PlayerObject.schematicList
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<SchematicList >::toBinaryStream(&schematicList.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (incapacitationTimes) {
	_nameHashCode = 0xb0e1799d; //PlayerObject.incapacitationTimes
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector<unsigned int> >::toBinaryStream(&incapacitationTimes.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (suiBoxNextID) {
	_nameHashCode = 0xbdbf961a; //PlayerObject.suiBoxNextID
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned int >::toBinaryStream(&suiBoxNextID.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (suiBoxes) {
	_nameHashCode = 0xe7ec84f4; //PlayerObject.suiBoxes
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<VectorMap<unsigned int, ManagedReference<SuiBoxPOD* > > >::toBinaryStream(&suiBoxes.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (chatRooms) {
	_nameHashCode = 0xfddc58de; //PlayerObject.chatRooms
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<SortedVector<unsigned int> >::toBinaryStream(&chatRooms.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (ownedChatRooms) {
	_nameHashCode = 0x71d62de1; //PlayerObject.ownedChatRooms
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<SortedVector<unsigned int> >::toBinaryStream(&ownedChatRooms.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (victimList) {
	_nameHashCode = 0xf2a6da3a; //PlayerObject.victimList
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector<unsigned long long> >::toBinaryStream(&victimList.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (declaredResidence) {
	_nameHashCode = 0xa70ae1f1; //PlayerObject.declaredResidence
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&declaredResidence.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (cloningFacility) {
	_nameHashCode = 0xb31847ad; //PlayerObject.cloningFacility
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&cloningFacility.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (isPlayerCloning) {
	_nameHashCode = 0xefbabd05; //PlayerObject.isPlayerCloning
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&isPlayerCloning.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (persistentMessages) {
	_nameHashCode = 0x1c4c135a; //PlayerObject.persistentMessages
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<SortedVector<unsigned long long> >::toBinaryStream(&persistentMessages.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (biography) {
	_nameHashCode = 0x8fdcc5fd; //PlayerObject.biography
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<UnicodeString >::toBinaryStream(&biography.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (consentList) {
	_nameHashCode = 0x2e39a2da; //PlayerObject.consentList
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<SortedVector<String> >::toBinaryStream(&consentList.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (lastNpcConvoMessage) {
	_nameHashCode = 0x20094ebc; //PlayerObject.lastNpcConvoMessage
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&lastNpcConvoMessage.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (lastNpcConvo) {
	_nameHashCode = 0x56616dc4; //PlayerObject.lastNpcConvo
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&lastNpcConvo.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (lastNpcConvoOptions) {
	_nameHashCode = 0x32b94133; //PlayerObject.lastNpcConvoOptions
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector<String> >::toBinaryStream(&lastNpcConvoOptions.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (conversatingCreature) {
	_nameHashCode = 0x5cd36e0f; //PlayerObject.conversatingCreature
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&conversatingCreature.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (trainerCoordinates) {
	_nameHashCode = 0x755815b3; //PlayerObject.trainerCoordinates
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector3 >::toBinaryStream(&trainerCoordinates.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (lastLogoutWorldPosition) {
	_nameHashCode = 0xa3160433; //PlayerObject.lastLogoutWorldPosition
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector3 >::toBinaryStream(&lastLogoutWorldPosition.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (trainerZoneName) {
	_nameHashCode = 0x891a3d47; //PlayerObject.trainerZoneName
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&trainerZoneName.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (logoutTimeStamp) {
	_nameHashCode = 0x7645c7d6; //PlayerObject.logoutTimeStamp
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Time >::toBinaryStream(&logoutTimeStamp.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (onlineStatus) {
	_nameHashCode = 0x377a6e51; //PlayerObject.onlineStatus
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&onlineStatus.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (skillPoints) {
	_nameHashCode = 0xb10c8ae0; //PlayerObject.skillPoints
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&skillPoints.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (pvpRating) {
	_nameHashCode = 0xd49b8d6a; //PlayerObject.pvpRating
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&pvpRating.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (lastPvpRatingUpdate) {
	_nameHashCode = 0xd26b2054; //PlayerObject.lastPvpRatingUpdate
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Time >::toBinaryStream(&lastPvpRatingUpdate.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (hologrindProfessions) {
	_nameHashCode = 0x908bba87; //PlayerObject.hologrindProfessions
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Vector<byte> >::toBinaryStream(&hologrindProfessions.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (clientLastMovementStamp) {
	_nameHashCode = 0x3166ef65; //PlayerObject.clientLastMovementStamp
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned int >::toBinaryStream(&clientLastMovementStamp.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (serverLastMovementStamp) {
	_nameHashCode = 0x62284a10; //PlayerObject.serverLastMovementStamp
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Time >::toBinaryStream(&serverLastMovementStamp.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (lastValidatedPosition) {
	_nameHashCode = 0x3b3fbd40; //PlayerObject.lastValidatedPosition
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<ValidatedPosition >::toBinaryStream(&lastValidatedPosition.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (accountID) {
	_nameHashCode = 0x639a0c4f; //PlayerObject.accountID
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned int >::toBinaryStream(&accountID.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (screenPlayData) {
	_nameHashCode = 0x70fbb795; //PlayerObject.screenPlayData
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<VectorMap<String, String> >::toBinaryStream(&screenPlayData.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (permissionGroups) {
	_nameHashCode = 0x42257652; //PlayerObject.permissionGroups
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<SortedVector<String> >::toBinaryStream(&permissionGroups.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (performanceBuffTarget) {
	_nameHashCode = 0xc7d518a7; //PlayerObject.performanceBuffTarget
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&performanceBuffTarget.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (debugOutput) {
	_nameHashCode = 0xf80402e3; //PlayerObject.debugOutput
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<bool >::toBinaryStream(&debugOutput.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (visibility) {
	_nameHashCode = 0x84d965aa; //PlayerObject.visibility
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<float >::toBinaryStream(&visibility.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (lastVisibilityUpdateTimestamp) {
	_nameHashCode = 0xf2ff7f01; //PlayerObject.lastVisibilityUpdateTimestamp
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Time >::toBinaryStream(&lastVisibilityUpdateTimestamp.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (lastBhPvpCombatActionTimestamp) {
	_nameHashCode = 0xdd80d638; //PlayerObject.lastBhPvpCombatActionTimestamp
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Time >::toBinaryStream(&lastBhPvpCombatActionTimestamp.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (lastGcwPvpCombatActionTimestamp) {
	_nameHashCode = 0x12de4676; //PlayerObject.lastGcwPvpCombatActionTimestamp
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Time >::toBinaryStream(&lastGcwPvpCombatActionTimestamp.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (lastCrackdownGcwCombatActionTimestamp) {
	_nameHashCode = 0x615d7df2; //PlayerObject.lastCrackdownGcwCombatActionTimestamp
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Time >::toBinaryStream(&lastCrackdownGcwCombatActionTimestamp.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (lastPvpAreaCombatActionTimestamp) {
	_nameHashCode = 0xa6906852; //PlayerObject.lastPvpAreaCombatActionTimestamp
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Time >::toBinaryStream(&lastPvpAreaCombatActionTimestamp.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (crackdownFactionTefCrc) {
	_nameHashCode = 0x2dda2fc3; //PlayerObject.crackdownFactionTefCrc
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned int >::toBinaryStream(&crackdownFactionTefCrc.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (lastDigestion) {
	_nameHashCode = 0x23960f0c; //PlayerObject.lastDigestion
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<Time >::toBinaryStream(&lastDigestion.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (activePets) {
	_nameHashCode = 0xc87e4cfc; //PlayerObject.activePets
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<SortedVector<ManagedReference<AiAgentPOD* > > >::toBinaryStream(&activePets.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (activeQuests) {
	_nameHashCode = 0x4ce8be67; //PlayerObject.activeQuests
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<DeltaBitArray >::toBinaryStream(&activeQuests.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (completedQuests) {
	_nameHashCode = 0xa1791985; //PlayerObject.completedQuests
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<DeltaBitArray >::toBinaryStream(&completedQuests.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (installedHoloEmote) {
	_nameHashCode = 0x842b7659; //PlayerObject.installedHoloEmote
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&installedHoloEmote.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (holoEmoteUseCount) {
	_nameHashCode = 0x9b5705cd; //PlayerObject.holoEmoteUseCount
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<int >::toBinaryStream(&holoEmoteUseCount.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (spouseName) {
	_nameHashCode = 0x7114f851; //PlayerObject.spouseName
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<String >::toBinaryStream(&spouseName.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (chosenVeteranRewards) {
	_nameHashCode = 0x7e9115c8; //PlayerObject.chosenVeteranRewards
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<VectorMap<unsigned int, String> >::toBinaryStream(&chosenVeteranRewards.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (currentEventPerks) {
	_nameHashCode = 0xd35e75cf; //PlayerObject.currentEventPerks
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<SortedVector<unsigned long long> >::toBinaryStream(&currentEventPerks.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (playerQuestsData) {
	_nameHashCode = 0x52db715b; //PlayerObject.playerQuestsData
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<DeltaVectorMap<uint32, PlayerQuestData > >::toBinaryStream(&playerQuestsData.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (miliSecsPlayed) {
	_nameHashCode = 0x7bed3550; //PlayerObject.miliSecsPlayed
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&miliSecsPlayed.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (miliSecsSession) {
	_nameHashCode = 0xb1bbc5bb; //PlayerObject.miliSecsSession
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&miliSecsSession.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}

	if (sessionStatsMiliSecs) {
	_nameHashCode = 0x469b6d7e; //PlayerObject.sessionStatsMiliSecs
	TypeInfo<uint32>::toBinaryStream(&_nameHashCode, stream);
	_offset = stream->getOffset();
	stream->writeInt(0);
	TypeInfo<unsigned long long >::toBinaryStream(&sessionStatsMiliSecs.value(), stream);
	_totalSize = (uint32) (stream->getOffset() - (_offset + 4));
	stream->writeInt(_offset, _totalSize);
	_count++;
	}


	return _count;
}

bool PlayerObjectPOD::readObjectMember(ObjectInputStream* stream, const uint32& nameHashCode) {
	if (IntangibleObjectPOD::readObjectMember(stream, nameHashCode))
		return true;

	switch(nameHashCode) {
	case 0x63ca6d5f: //PlayerObject.playerLogLevel
		{
			int _mnplayerLogLevel;
			TypeInfo<int >::parseFromBinaryStream(&_mnplayerLogLevel, stream);
			playerLogLevel = std::move(_mnplayerLogLevel);
		}
		return true;

	case 0x3cc091f4: //PlayerObject.playerBitmask
		{
			PlayerBitmasks _mnplayerBitmask;
			TypeInfo<PlayerBitmasks >::parseFromBinaryStream(&_mnplayerBitmask, stream);
			playerBitmask = std::move(_mnplayerBitmask);
		}
		return true;

	case 0x3f59dd69: //PlayerObject.title
		{
			String _mntitle;
			TypeInfo<String >::parseFromBinaryStream(&_mntitle, stream);
			title = std::move(_mntitle);
		}
		return true;

	case 0x80839c38: //PlayerObject.savedTerrainName
		{
			String _mnsavedTerrainName;
			TypeInfo<String >::parseFromBinaryStream(&_mnsavedTerrainName, stream);
			savedTerrainName = std::move(_mnsavedTerrainName);
		}
		return true;

	case 0x185d8184: //PlayerObject.savedParentID
		{
			unsigned long long _mnsavedParentID;
			TypeInfo<unsigned long long >::parseFromBinaryStream(&_mnsavedParentID, stream);
			savedParentID = std::move(_mnsavedParentID);
		}
		return true;

	case 0xbf409c6b: //PlayerObject.badges
		{
			Badges _mnbadges;
			TypeInfo<Badges >::parseFromBinaryStream(&_mnbadges, stream);
			badges = std::move(_mnbadges);
		}
		return true;

	case 0x5747cad2: //PlayerObject.birthDate
		{
			int _mnbirthDate;
			TypeInfo<int >::parseFromBinaryStream(&_mnbirthDate, stream);
			birthDate = std::move(_mnbirthDate);
		}
		return true;

	case 0x6f0f168c: //PlayerObject.forcePower
		{
			int _mnforcePower;
			TypeInfo<int >::parseFromBinaryStream(&_mnforcePower, stream);
			forcePower = std::move(_mnforcePower);
		}
		return true;

	case 0x626f8b12: //PlayerObject.forcePowerMax
		{
			int _mnforcePowerMax;
			TypeInfo<int >::parseFromBinaryStream(&_mnforcePowerMax, stream);
			forcePowerMax = std::move(_mnforcePowerMax);
		}
		return true;

	case 0xd9b9f82b: //PlayerObject.foodFilling
		{
			int _mnfoodFilling;
			TypeInfo<int >::parseFromBinaryStream(&_mnfoodFilling, stream);
			foodFilling = std::move(_mnfoodFilling);
		}
		return true;

	case 0xa5fa3768: //PlayerObject.foodFillingMax
		{
			int _mnfoodFillingMax;
			TypeInfo<int >::parseFromBinaryStream(&_mnfoodFillingMax, stream);
			foodFillingMax = std::move(_mnfoodFillingMax);
		}
		return true;

	case 0xe620a523: //PlayerObject.drinkFilling
		{
			int _mndrinkFilling;
			TypeInfo<int >::parseFromBinaryStream(&_mndrinkFilling, stream);
			drinkFilling = std::move(_mndrinkFilling);
		}
		return true;

	case 0x37da084: //PlayerObject.drinkFillingMax
		{
			int _mndrinkFillingMax;
			TypeInfo<int >::parseFromBinaryStream(&_mndrinkFillingMax, stream);
			drinkFillingMax = std::move(_mndrinkFillingMax);
		}
		return true;

	case 0xe59e7515: //PlayerObject.reactionFines
		{
			int _mnreactionFines;
			TypeInfo<int >::parseFromBinaryStream(&_mnreactionFines, stream);
			reactionFines = std::move(_mnreactionFines);
		}
		return true;

	case 0x911499de: //PlayerObject.reactionFineTimestamp
		{
			Time _mnreactionFineTimestamp;
			TypeInfo<Time >::parseFromBinaryStream(&_mnreactionFineTimestamp, stream);
			reactionFineTimestamp = std::move(_mnreactionFineTimestamp);
		}
		return true;

	case 0x89dba2ac: //PlayerObject.reactionFineMailTimestamp
		{
			Time _mnreactionFineMailTimestamp;
			TypeInfo<Time >::parseFromBinaryStream(&_mnreactionFineMailTimestamp, stream);
			reactionFineMailTimestamp = std::move(_mnreactionFineMailTimestamp);
		}
		return true;

	case 0x68888ebc: //PlayerObject.starterProfession
		{
			String _mnstarterProfession;
			TypeInfo<String >::parseFromBinaryStream(&_mnstarterProfession, stream);
			starterProfession = std::move(_mnstarterProfession);
		}
		return true;

	case 0xf7e4755e: //PlayerObject.bankLocation
		{
			String _mnbankLocation;
			TypeInfo<String >::parseFromBinaryStream(&_mnbankLocation, stream);
			bankLocation = std::move(_mnbankLocation);
		}
		return true;

	case 0x7a19894f: //PlayerObject.teleporting
		{
			bool _mnteleporting;
			TypeInfo<bool >::parseFromBinaryStream(&_mnteleporting, stream);
			teleporting = std::move(_mnteleporting);
		}
		return true;

	case 0xcf0cd987: //PlayerObject.onLoadScreen
		{
			bool _mnonLoadScreen;
			TypeInfo<bool >::parseFromBinaryStream(&_mnonLoadScreen, stream);
			onLoadScreen = std::move(_mnonLoadScreen);
		}
		return true;

	case 0xdf6adf19: //PlayerObject.forcedTransform
		{
			bool _mnforcedTransform;
			TypeInfo<bool >::parseFromBinaryStream(&_mnforcedTransform, stream);
			forcedTransform = std::move(_mnforcedTransform);
		}
		return true;

	case 0x9af4d57b: //PlayerObject.muted
		{
			bool _mnmuted;
			TypeInfo<bool >::parseFromBinaryStream(&_mnmuted, stream);
			muted = std::move(_mnmuted);
		}
		return true;

	case 0x2ba211bc: //PlayerObject.mutedReason
		{
			String _mnmutedReason;
			TypeInfo<String >::parseFromBinaryStream(&_mnmutedReason, stream);
			mutedReason = std::move(_mnmutedReason);
		}
		return true;

	case 0x28863ed2: //PlayerObject.tosVersionAccepted
		{
			int _mntosVersionAccepted;
			TypeInfo<int >::parseFromBinaryStream(&_mntosVersionAccepted, stream);
			tosVersionAccepted = std::move(_mntosVersionAccepted);
		}
		return true;

	case 0x9151f1d3: //PlayerObject.ownedStructures
		{
			SortedVector<unsigned long long> _mnownedStructures;
			TypeInfo<SortedVector<unsigned long long> >::parseFromBinaryStream(&_mnownedStructures, stream);
			ownedStructures = std::move(_mnownedStructures);
		}
		return true;

	case 0x3f521607: //PlayerObject.ownedVendors
		{
			SortedVector<unsigned long long> _mnownedVendors;
			TypeInfo<SortedVector<unsigned long long> >::parseFromBinaryStream(&_mnownedVendors, stream);
			ownedVendors = std::move(_mnownedVendors);
		}
		return true;

	case 0x9c2c0c3f: //PlayerObject.maximumLots
		{
			byte _mnmaximumLots;
			TypeInfo<byte >::parseFromBinaryStream(&_mnmaximumLots, stream);
			maximumLots = std::move(_mnmaximumLots);
		}
		return true;

	case 0x39b2b254: //PlayerObject.jediState
		{
			int _mnjediState;
			TypeInfo<int >::parseFromBinaryStream(&_mnjediState, stream);
			jediState = std::move(_mnjediState);
		}
		return true;

	case 0x4d1afa57: //PlayerObject.adminLevel
		{
			unsigned int _mnadminLevel;
			TypeInfo<unsigned int >::parseFromBinaryStream(&_mnadminLevel, stream);
			adminLevel = std::move(_mnadminLevel);
		}
		return true;

	case 0xdfba5208: //PlayerObject.priviledgeFlag
		{
			int _mnpriviledgeFlag;
			TypeInfo<int >::parseFromBinaryStream(&_mnpriviledgeFlag, stream);
			priviledgeFlag = std::move(_mnpriviledgeFlag);
		}
		return true;

	case 0x45728d15: //PlayerObject.languageID
		{
			byte _mnlanguageID;
			TypeInfo<byte >::parseFromBinaryStream(&_mnlanguageID, stream);
			languageID = std::move(_mnlanguageID);
		}
		return true;

	case 0x3737ff5f: //PlayerObject.xpTypeCapList
		{
			VectorMap<String, int> _mnxpTypeCapList;
			TypeInfo<VectorMap<String, int> >::parseFromBinaryStream(&_mnxpTypeCapList, stream);
			xpTypeCapList = std::move(_mnxpTypeCapList);
		}
		return true;

	case 0x890785df: //PlayerObject.commandMessageStrings
		{
			VectorMap<unsigned int, String> _mncommandMessageStrings;
			TypeInfo<VectorMap<unsigned int, String> >::parseFromBinaryStream(&_mncommandMessageStrings, stream);
			commandMessageStrings = std::move(_mncommandMessageStrings);
		}
		return true;

	case 0x33656264: //PlayerObject.experienceList
		{
			DeltaVectorMap<String, int> _mnexperienceList;
			TypeInfo<DeltaVectorMap<String, int> >::parseFromBinaryStream(&_mnexperienceList, stream);
			experienceList = std::move(_mnexperienceList);
		}
		return true;

	case 0xbcd9bd05: //PlayerObject.frsData
		{
			FrsData _mnfrsData;
			TypeInfo<FrsData >::parseFromBinaryStream(&_mnfrsData, stream);
			frsData = std::move(_mnfrsData);
		}
		return true;

	case 0xbd209913: //PlayerObject.waypointList
		{
			WaypointList _mnwaypointList;
			TypeInfo<WaypointList >::parseFromBinaryStream(&_mnwaypointList, stream);
			waypointList = std::move(_mnwaypointList);
		}
		return true;

	case 0x56e55cb2: //PlayerObject.abilityList
		{
			AbilityList _mnabilityList;
			TypeInfo<AbilityList >::parseFromBinaryStream(&_mnabilityList, stream);
			abilityList = std::move(_mnabilityList);
		}
		return true;

	case 0xdab57393: //PlayerObject.friendList
		{
			FriendList _mnfriendList;
			TypeInfo<FriendList >::parseFromBinaryStream(&_mnfriendList, stream);
			friendList = std::move(_mnfriendList);
		}
		return true;

	case 0x4d1f2cfe: //PlayerObject.ignoreList
		{
			IgnoreList _mnignoreList;
			TypeInfo<IgnoreList >::parseFromBinaryStream(&_mnignoreList, stream);
			ignoreList = std::move(_mnignoreList);
		}
		return true;

	case 0x2ebfed5f: //PlayerObject.factionStandingList
		{
			FactionStandingList _mnfactionStandingList;
			TypeInfo<FactionStandingList >::parseFromBinaryStream(&_mnfactionStandingList, stream);
			factionStandingList = std::move(_mnfactionStandingList);
		}
		return true;

	case 0x42645912: //PlayerObject.schematicList
		{
			SchematicList _mnschematicList;
			TypeInfo<SchematicList >::parseFromBinaryStream(&_mnschematicList, stream);
			schematicList = std::move(_mnschematicList);
		}
		return true;

	case 0xb0e1799d: //PlayerObject.incapacitationTimes
		{
			Vector<unsigned int> _mnincapacitationTimes;
			TypeInfo<Vector<unsigned int> >::parseFromBinaryStream(&_mnincapacitationTimes, stream);
			incapacitationTimes = std::move(_mnincapacitationTimes);
		}
		return true;

	case 0xbdbf961a: //PlayerObject.suiBoxNextID
		{
			unsigned int _mnsuiBoxNextID;
			TypeInfo<unsigned int >::parseFromBinaryStream(&_mnsuiBoxNextID, stream);
			suiBoxNextID = std::move(_mnsuiBoxNextID);
		}
		return true;

	case 0xe7ec84f4: //PlayerObject.suiBoxes
		{
			VectorMap<unsigned int, ManagedReference<SuiBoxPOD* > > _mnsuiBoxes;
			TypeInfo<VectorMap<unsigned int, ManagedReference<SuiBoxPOD* > > >::parseFromBinaryStream(&_mnsuiBoxes, stream);
			suiBoxes = std::move(_mnsuiBoxes);
		}
		return true;

	case 0xfddc58de: //PlayerObject.chatRooms
		{
			SortedVector<unsigned int> _mnchatRooms;
			TypeInfo<SortedVector<unsigned int> >::parseFromBinaryStream(&_mnchatRooms, stream);
			chatRooms = std::move(_mnchatRooms);
		}
		return true;

	case 0x71d62de1: //PlayerObject.ownedChatRooms
		{
			SortedVector<unsigned int> _mnownedChatRooms;
			TypeInfo<SortedVector<unsigned int> >::parseFromBinaryStream(&_mnownedChatRooms, stream);
			ownedChatRooms = std::move(_mnownedChatRooms);
		}
		return true;

	case 0xf2a6da3a: //PlayerObject.victimList
		{
			Vector<unsigned long long> _mnvictimList;
			TypeInfo<Vector<unsigned long long> >::parseFromBinaryStream(&_mnvictimList, stream);
			victimList = std::move(_mnvictimList);
		}
		return true;

	case 0xa70ae1f1: //PlayerObject.declaredResidence
		{
			unsigned long long _mndeclaredResidence;
			TypeInfo<unsigned long long >::parseFromBinaryStream(&_mndeclaredResidence, stream);
			declaredResidence = std::move(_mndeclaredResidence);
		}
		return true;

	case 0xb31847ad: //PlayerObject.cloningFacility
		{
			unsigned long long _mncloningFacility;
			TypeInfo<unsigned long long >::parseFromBinaryStream(&_mncloningFacility, stream);
			cloningFacility = std::move(_mncloningFacility);
		}
		return true;

	case 0xefbabd05: //PlayerObject.isPlayerCloning
		{
			bool _mnisPlayerCloning;
			TypeInfo<bool >::parseFromBinaryStream(&_mnisPlayerCloning, stream);
			isPlayerCloning = std::move(_mnisPlayerCloning);
		}
		return true;

	case 0x1c4c135a: //PlayerObject.persistentMessages
		{
			SortedVector<unsigned long long> _mnpersistentMessages;
			TypeInfo<SortedVector<unsigned long long> >::parseFromBinaryStream(&_mnpersistentMessages, stream);
			persistentMessages = std::move(_mnpersistentMessages);
		}
		return true;

	case 0x8fdcc5fd: //PlayerObject.biography
		{
			UnicodeString _mnbiography;
			TypeInfo<UnicodeString >::parseFromBinaryStream(&_mnbiography, stream);
			biography = std::move(_mnbiography);
		}
		return true;

	case 0x2e39a2da: //PlayerObject.consentList
		{
			SortedVector<String> _mnconsentList;
			TypeInfo<SortedVector<String> >::parseFromBinaryStream(&_mnconsentList, stream);
			consentList = std::move(_mnconsentList);
		}
		return true;

	case 0x20094ebc: //PlayerObject.lastNpcConvoMessage
		{
			String _mnlastNpcConvoMessage;
			TypeInfo<String >::parseFromBinaryStream(&_mnlastNpcConvoMessage, stream);
			lastNpcConvoMessage = std::move(_mnlastNpcConvoMessage);
		}
		return true;

	case 0x56616dc4: //PlayerObject.lastNpcConvo
		{
			String _mnlastNpcConvo;
			TypeInfo<String >::parseFromBinaryStream(&_mnlastNpcConvo, stream);
			lastNpcConvo = std::move(_mnlastNpcConvo);
		}
		return true;

	case 0x32b94133: //PlayerObject.lastNpcConvoOptions
		{
			Vector<String> _mnlastNpcConvoOptions;
			TypeInfo<Vector<String> >::parseFromBinaryStream(&_mnlastNpcConvoOptions, stream);
			lastNpcConvoOptions = std::move(_mnlastNpcConvoOptions);
		}
		return true;

	case 0x5cd36e0f: //PlayerObject.conversatingCreature
		{
			unsigned long long _mnconversatingCreature;
			TypeInfo<unsigned long long >::parseFromBinaryStream(&_mnconversatingCreature, stream);
			conversatingCreature = std::move(_mnconversatingCreature);
		}
		return true;

	case 0x755815b3: //PlayerObject.trainerCoordinates
		{
			Vector3 _mntrainerCoordinates;
			TypeInfo<Vector3 >::parseFromBinaryStream(&_mntrainerCoordinates, stream);
			trainerCoordinates = std::move(_mntrainerCoordinates);
		}
		return true;

	case 0xa3160433: //PlayerObject.lastLogoutWorldPosition
		{
			Vector3 _mnlastLogoutWorldPosition;
			TypeInfo<Vector3 >::parseFromBinaryStream(&_mnlastLogoutWorldPosition, stream);
			lastLogoutWorldPosition = std::move(_mnlastLogoutWorldPosition);
		}
		return true;

	case 0x891a3d47: //PlayerObject.trainerZoneName
		{
			String _mntrainerZoneName;
			TypeInfo<String >::parseFromBinaryStream(&_mntrainerZoneName, stream);
			trainerZoneName = std::move(_mntrainerZoneName);
		}
		return true;

	case 0x7645c7d6: //PlayerObject.logoutTimeStamp
		{
			Time _mnlogoutTimeStamp;
			TypeInfo<Time >::parseFromBinaryStream(&_mnlogoutTimeStamp, stream);
			logoutTimeStamp = std::move(_mnlogoutTimeStamp);
		}
		return true;

	case 0x377a6e51: //PlayerObject.onlineStatus
		{
			int _mnonlineStatus;
			TypeInfo<int >::parseFromBinaryStream(&_mnonlineStatus, stream);
			onlineStatus = std::move(_mnonlineStatus);
		}
		return true;

	case 0xb10c8ae0: //PlayerObject.skillPoints
		{
			int _mnskillPoints;
			TypeInfo<int >::parseFromBinaryStream(&_mnskillPoints, stream);
			skillPoints = std::move(_mnskillPoints);
		}
		return true;

	case 0xd49b8d6a: //PlayerObject.pvpRating
		{
			int _mnpvpRating;
			TypeInfo<int >::parseFromBinaryStream(&_mnpvpRating, stream);
			pvpRating = std::move(_mnpvpRating);
		}
		return true;

	case 0xd26b2054: //PlayerObject.lastPvpRatingUpdate
		{
			Time _mnlastPvpRatingUpdate;
			TypeInfo<Time >::parseFromBinaryStream(&_mnlastPvpRatingUpdate, stream);
			lastPvpRatingUpdate = std::move(_mnlastPvpRatingUpdate);
		}
		return true;

	case 0x908bba87: //PlayerObject.hologrindProfessions
		{
			Vector<byte> _mnhologrindProfessions;
			TypeInfo<Vector<byte> >::parseFromBinaryStream(&_mnhologrindProfessions, stream);
			hologrindProfessions = std::move(_mnhologrindProfessions);
		}
		return true;

	case 0x3166ef65: //PlayerObject.clientLastMovementStamp
		{
			unsigned int _mnclientLastMovementStamp;
			TypeInfo<unsigned int >::parseFromBinaryStream(&_mnclientLastMovementStamp, stream);
			clientLastMovementStamp = std::move(_mnclientLastMovementStamp);
		}
		return true;

	case 0x62284a10: //PlayerObject.serverLastMovementStamp
		{
			Time _mnserverLastMovementStamp;
			TypeInfo<Time >::parseFromBinaryStream(&_mnserverLastMovementStamp, stream);
			serverLastMovementStamp = std::move(_mnserverLastMovementStamp);
		}
		return true;

	case 0x3b3fbd40: //PlayerObject.lastValidatedPosition
		{
			ValidatedPosition _mnlastValidatedPosition;
			TypeInfo<ValidatedPosition >::parseFromBinaryStream(&_mnlastValidatedPosition, stream);
			lastValidatedPosition = std::move(_mnlastValidatedPosition);
		}
		return true;

	case 0x639a0c4f: //PlayerObject.accountID
		{
			unsigned int _mnaccountID;
			TypeInfo<unsigned int >::parseFromBinaryStream(&_mnaccountID, stream);
			accountID = std::move(_mnaccountID);
		}
		return true;

	case 0x70fbb795: //PlayerObject.screenPlayData
		{
			VectorMap<String, String> _mnscreenPlayData;
			TypeInfo<VectorMap<String, String> >::parseFromBinaryStream(&_mnscreenPlayData, stream);
			screenPlayData = std::move(_mnscreenPlayData);
		}
		return true;

	case 0x42257652: //PlayerObject.permissionGroups
		{
			SortedVector<String> _mnpermissionGroups;
			TypeInfo<SortedVector<String> >::parseFromBinaryStream(&_mnpermissionGroups, stream);
			permissionGroups = std::move(_mnpermissionGroups);
		}
		return true;

	case 0xc7d518a7: //PlayerObject.performanceBuffTarget
		{
			unsigned long long _mnperformanceBuffTarget;
			TypeInfo<unsigned long long >::parseFromBinaryStream(&_mnperformanceBuffTarget, stream);
			performanceBuffTarget = std::move(_mnperformanceBuffTarget);
		}
		return true;

	case 0xf80402e3: //PlayerObject.debugOutput
		{
			bool _mndebugOutput;
			TypeInfo<bool >::parseFromBinaryStream(&_mndebugOutput, stream);
			debugOutput = std::move(_mndebugOutput);
		}
		return true;

	case 0x84d965aa: //PlayerObject.visibility
		{
			float _mnvisibility;
			TypeInfo<float >::parseFromBinaryStream(&_mnvisibility, stream);
			visibility = std::move(_mnvisibility);
		}
		return true;

	case 0xf2ff7f01: //PlayerObject.lastVisibilityUpdateTimestamp
		{
			Time _mnlastVisibilityUpdateTimestamp;
			TypeInfo<Time >::parseFromBinaryStream(&_mnlastVisibilityUpdateTimestamp, stream);
			lastVisibilityUpdateTimestamp = std::move(_mnlastVisibilityUpdateTimestamp);
		}
		return true;

	case 0xdd80d638: //PlayerObject.lastBhPvpCombatActionTimestamp
		{
			Time _mnlastBhPvpCombatActionTimestamp;
			TypeInfo<Time >::parseFromBinaryStream(&_mnlastBhPvpCombatActionTimestamp, stream);
			lastBhPvpCombatActionTimestamp = std::move(_mnlastBhPvpCombatActionTimestamp);
		}
		return true;

	case 0x12de4676: //PlayerObject.lastGcwPvpCombatActionTimestamp
		{
			Time _mnlastGcwPvpCombatActionTimestamp;
			TypeInfo<Time >::parseFromBinaryStream(&_mnlastGcwPvpCombatActionTimestamp, stream);
			lastGcwPvpCombatActionTimestamp = std::move(_mnlastGcwPvpCombatActionTimestamp);
		}
		return true;

	case 0x615d7df2: //PlayerObject.lastCrackdownGcwCombatActionTimestamp
		{
			Time _mnlastCrackdownGcwCombatActionTimestamp;
			TypeInfo<Time >::parseFromBinaryStream(&_mnlastCrackdownGcwCombatActionTimestamp, stream);
			lastCrackdownGcwCombatActionTimestamp = std::move(_mnlastCrackdownGcwCombatActionTimestamp);
		}
		return true;

	case 0xa6906852: //PlayerObject.lastPvpAreaCombatActionTimestamp
		{
			Time _mnlastPvpAreaCombatActionTimestamp;
			TypeInfo<Time >::parseFromBinaryStream(&_mnlastPvpAreaCombatActionTimestamp, stream);
			lastPvpAreaCombatActionTimestamp = std::move(_mnlastPvpAreaCombatActionTimestamp);
		}
		return true;

	case 0x2dda2fc3: //PlayerObject.crackdownFactionTefCrc
		{
			unsigned int _mncrackdownFactionTefCrc;
			TypeInfo<unsigned int >::parseFromBinaryStream(&_mncrackdownFactionTefCrc, stream);
			crackdownFactionTefCrc = std::move(_mncrackdownFactionTefCrc);
		}
		return true;

	case 0x23960f0c: //PlayerObject.lastDigestion
		{
			Time _mnlastDigestion;
			TypeInfo<Time >::parseFromBinaryStream(&_mnlastDigestion, stream);
			lastDigestion = std::move(_mnlastDigestion);
		}
		return true;

	case 0xc87e4cfc: //PlayerObject.activePets
		{
			SortedVector<ManagedReference<AiAgentPOD* > > _mnactivePets;
			TypeInfo<SortedVector<ManagedReference<AiAgentPOD* > > >::parseFromBinaryStream(&_mnactivePets, stream);
			activePets = std::move(_mnactivePets);
		}
		return true;

	case 0x4ce8be67: //PlayerObject.activeQuests
		{
			DeltaBitArray _mnactiveQuests;
			TypeInfo<DeltaBitArray >::parseFromBinaryStream(&_mnactiveQuests, stream);
			activeQuests = std::move(_mnactiveQuests);
		}
		return true;

	case 0xa1791985: //PlayerObject.completedQuests
		{
			DeltaBitArray _mncompletedQuests;
			TypeInfo<DeltaBitArray >::parseFromBinaryStream(&_mncompletedQuests, stream);
			completedQuests = std::move(_mncompletedQuests);
		}
		return true;

	case 0x842b7659: //PlayerObject.installedHoloEmote
		{
			String _mninstalledHoloEmote;
			TypeInfo<String >::parseFromBinaryStream(&_mninstalledHoloEmote, stream);
			installedHoloEmote = std::move(_mninstalledHoloEmote);
		}
		return true;

	case 0x9b5705cd: //PlayerObject.holoEmoteUseCount
		{
			int _mnholoEmoteUseCount;
			TypeInfo<int >::parseFromBinaryStream(&_mnholoEmoteUseCount, stream);
			holoEmoteUseCount = std::move(_mnholoEmoteUseCount);
		}
		return true;

	case 0x7114f851: //PlayerObject.spouseName
		{
			String _mnspouseName;
			TypeInfo<String >::parseFromBinaryStream(&_mnspouseName, stream);
			spouseName = std::move(_mnspouseName);
		}
		return true;

	case 0x7e9115c8: //PlayerObject.chosenVeteranRewards
		{
			VectorMap<unsigned int, String> _mnchosenVeteranRewards;
			TypeInfo<VectorMap<unsigned int, String> >::parseFromBinaryStream(&_mnchosenVeteranRewards, stream);
			chosenVeteranRewards = std::move(_mnchosenVeteranRewards);
		}
		return true;

	case 0xd35e75cf: //PlayerObject.currentEventPerks
		{
			SortedVector<unsigned long long> _mncurrentEventPerks;
			TypeInfo<SortedVector<unsigned long long> >::parseFromBinaryStream(&_mncurrentEventPerks, stream);
			currentEventPerks = std::move(_mncurrentEventPerks);
		}
		return true;

	case 0x52db715b: //PlayerObject.playerQuestsData
		{
			DeltaVectorMap<uint32, PlayerQuestData > _mnplayerQuestsData;
			TypeInfo<DeltaVectorMap<uint32, PlayerQuestData > >::parseFromBinaryStream(&_mnplayerQuestsData, stream);
			playerQuestsData = std::move(_mnplayerQuestsData);
		}
		return true;

	case 0x7bed3550: //PlayerObject.miliSecsPlayed
		{
			unsigned long long _mnmiliSecsPlayed;
			TypeInfo<unsigned long long >::parseFromBinaryStream(&_mnmiliSecsPlayed, stream);
			miliSecsPlayed = std::move(_mnmiliSecsPlayed);
		}
		return true;

	case 0xb1bbc5bb: //PlayerObject.miliSecsSession
		{
			unsigned long long _mnmiliSecsSession;
			TypeInfo<unsigned long long >::parseFromBinaryStream(&_mnmiliSecsSession, stream);
			miliSecsSession = std::move(_mnmiliSecsSession);
		}
		return true;

	case 0x469b6d7e: //PlayerObject.sessionStatsMiliSecs
		{
			unsigned long long _mnsessionStatsMiliSecs;
			TypeInfo<unsigned long long >::parseFromBinaryStream(&_mnsessionStatsMiliSecs, stream);
			sessionStatsMiliSecs = std::move(_mnsessionStatsMiliSecs);
		}
		return true;

	}

	return false;
}

void PlayerObjectPOD::readObject(ObjectInputStream* stream) {
	uint16 _varCount = stream->readShort();
	for (int i = 0; i < _varCount; ++i) {
		uint32 _nameHashCode;
		TypeInfo<uint32>::parseFromBinaryStream(&_nameHashCode, stream);

		uint32 _varSize = stream->readInt();

		int _currentOffset = stream->getOffset();

		if(PlayerObjectPOD::readObjectMember(stream, _nameHashCode)) {
		}

		stream->setOffset(_currentOffset + _varSize);
	}

}

void PlayerObjectPOD::writeObjectCompact(ObjectOutputStream* stream) {
	IntangibleObjectPOD::writeObjectCompact(stream);

	TypeInfo<int >::toBinaryStream(&playerLogLevel.value(), stream);

	TypeInfo<PlayerBitmasks >::toBinaryStream(&playerBitmask.value(), stream);

	TypeInfo<String >::toBinaryStream(&title.value(), stream);

	TypeInfo<String >::toBinaryStream(&savedTerrainName.value(), stream);

	TypeInfo<unsigned long long >::toBinaryStream(&savedParentID.value(), stream);

	TypeInfo<Badges >::toBinaryStream(&badges.value(), stream);

	TypeInfo<int >::toBinaryStream(&birthDate.value(), stream);

	TypeInfo<int >::toBinaryStream(&forcePower.value(), stream);

	TypeInfo<int >::toBinaryStream(&forcePowerMax.value(), stream);

	TypeInfo<int >::toBinaryStream(&foodFilling.value(), stream);

	TypeInfo<int >::toBinaryStream(&foodFillingMax.value(), stream);

	TypeInfo<int >::toBinaryStream(&drinkFilling.value(), stream);

	TypeInfo<int >::toBinaryStream(&drinkFillingMax.value(), stream);

	TypeInfo<int >::toBinaryStream(&reactionFines.value(), stream);

	TypeInfo<Time >::toBinaryStream(&reactionFineTimestamp.value(), stream);

	TypeInfo<Time >::toBinaryStream(&reactionFineMailTimestamp.value(), stream);

	TypeInfo<String >::toBinaryStream(&starterProfession.value(), stream);

	TypeInfo<String >::toBinaryStream(&bankLocation.value(), stream);

	TypeInfo<bool >::toBinaryStream(&teleporting.value(), stream);

	TypeInfo<bool >::toBinaryStream(&onLoadScreen.value(), stream);

	TypeInfo<bool >::toBinaryStream(&forcedTransform.value(), stream);

	TypeInfo<bool >::toBinaryStream(&muted.value(), stream);

	TypeInfo<String >::toBinaryStream(&mutedReason.value(), stream);

	TypeInfo<int >::toBinaryStream(&tosVersionAccepted.value(), stream);

	TypeInfo<SortedVector<unsigned long long> >::toBinaryStream(&ownedStructures.value(), stream);

	TypeInfo<SortedVector<unsigned long long> >::toBinaryStream(&ownedVendors.value(), stream);

	TypeInfo<byte >::toBinaryStream(&maximumLots.value(), stream);

	TypeInfo<int >::toBinaryStream(&jediState.value(), stream);

	TypeInfo<unsigned int >::toBinaryStream(&adminLevel.value(), stream);

	TypeInfo<int >::toBinaryStream(&priviledgeFlag.value(), stream);

	TypeInfo<byte >::toBinaryStream(&languageID.value(), stream);

	TypeInfo<VectorMap<String, int> >::toBinaryStream(&xpTypeCapList.value(), stream);

	TypeInfo<VectorMap<unsigned int, String> >::toBinaryStream(&commandMessageStrings.value(), stream);

	TypeInfo<DeltaVectorMap<String, int> >::toBinaryStream(&experienceList.value(), stream);

	TypeInfo<FrsData >::toBinaryStream(&frsData.value(), stream);

	TypeInfo<WaypointList >::toBinaryStream(&waypointList.value(), stream);

	TypeInfo<AbilityList >::toBinaryStream(&abilityList.value(), stream);

	TypeInfo<FriendList >::toBinaryStream(&friendList.value(), stream);

	TypeInfo<IgnoreList >::toBinaryStream(&ignoreList.value(), stream);

	TypeInfo<FactionStandingList >::toBinaryStream(&factionStandingList.value(), stream);

	TypeInfo<SchematicList >::toBinaryStream(&schematicList.value(), stream);

	TypeInfo<Vector<unsigned int> >::toBinaryStream(&incapacitationTimes.value(), stream);

	TypeInfo<unsigned int >::toBinaryStream(&suiBoxNextID.value(), stream);

	TypeInfo<VectorMap<unsigned int, ManagedReference<SuiBoxPOD* > > >::toBinaryStream(&suiBoxes.value(), stream);

	TypeInfo<SortedVector<unsigned int> >::toBinaryStream(&chatRooms.value(), stream);

	TypeInfo<SortedVector<unsigned int> >::toBinaryStream(&ownedChatRooms.value(), stream);

	TypeInfo<Vector<unsigned long long> >::toBinaryStream(&victimList.value(), stream);

	TypeInfo<unsigned long long >::toBinaryStream(&declaredResidence.value(), stream);

	TypeInfo<unsigned long long >::toBinaryStream(&cloningFacility.value(), stream);

	TypeInfo<bool >::toBinaryStream(&isPlayerCloning.value(), stream);

	TypeInfo<SortedVector<unsigned long long> >::toBinaryStream(&persistentMessages.value(), stream);

	TypeInfo<UnicodeString >::toBinaryStream(&biography.value(), stream);

	TypeInfo<SortedVector<String> >::toBinaryStream(&consentList.value(), stream);

	TypeInfo<String >::toBinaryStream(&lastNpcConvoMessage.value(), stream);

	TypeInfo<String >::toBinaryStream(&lastNpcConvo.value(), stream);

	TypeInfo<Vector<String> >::toBinaryStream(&lastNpcConvoOptions.value(), stream);

	TypeInfo<unsigned long long >::toBinaryStream(&conversatingCreature.value(), stream);

	TypeInfo<Vector3 >::toBinaryStream(&trainerCoordinates.value(), stream);

	TypeInfo<Vector3 >::toBinaryStream(&lastLogoutWorldPosition.value(), stream);

	TypeInfo<String >::toBinaryStream(&trainerZoneName.value(), stream);

	TypeInfo<Time >::toBinaryStream(&logoutTimeStamp.value(), stream);

	TypeInfo<int >::toBinaryStream(&onlineStatus.value(), stream);

	TypeInfo<int >::toBinaryStream(&skillPoints.value(), stream);

	TypeInfo<int >::toBinaryStream(&pvpRating.value(), stream);

	TypeInfo<Time >::toBinaryStream(&lastPvpRatingUpdate.value(), stream);

	TypeInfo<Vector<byte> >::toBinaryStream(&hologrindProfessions.value(), stream);

	TypeInfo<unsigned int >::toBinaryStream(&clientLastMovementStamp.value(), stream);

	TypeInfo<Time >::toBinaryStream(&serverLastMovementStamp.value(), stream);

	TypeInfo<ValidatedPosition >::toBinaryStream(&lastValidatedPosition.value(), stream);

	TypeInfo<unsigned int >::toBinaryStream(&accountID.value(), stream);

	TypeInfo<VectorMap<String, String> >::toBinaryStream(&screenPlayData.value(), stream);

	TypeInfo<SortedVector<String> >::toBinaryStream(&permissionGroups.value(), stream);

	TypeInfo<unsigned long long >::toBinaryStream(&performanceBuffTarget.value(), stream);

	TypeInfo<bool >::toBinaryStream(&debugOutput.value(), stream);

	TypeInfo<float >::toBinaryStream(&visibility.value(), stream);

	TypeInfo<Time >::toBinaryStream(&lastVisibilityUpdateTimestamp.value(), stream);

	TypeInfo<Time >::toBinaryStream(&lastBhPvpCombatActionTimestamp.value(), stream);

	TypeInfo<Time >::toBinaryStream(&lastGcwPvpCombatActionTimestamp.value(), stream);

	TypeInfo<Time >::toBinaryStream(&lastCrackdownGcwCombatActionTimestamp.value(), stream);

	TypeInfo<Time >::toBinaryStream(&lastPvpAreaCombatActionTimestamp.value(), stream);

	TypeInfo<unsigned int >::toBinaryStream(&crackdownFactionTefCrc.value(), stream);

	TypeInfo<Time >::toBinaryStream(&lastDigestion.value(), stream);

	TypeInfo<SortedVector<ManagedReference<AiAgentPOD* > > >::toBinaryStream(&activePets.value(), stream);

	TypeInfo<DeltaBitArray >::toBinaryStream(&activeQuests.value(), stream);

	TypeInfo<DeltaBitArray >::toBinaryStream(&completedQuests.value(), stream);

	TypeInfo<String >::toBinaryStream(&installedHoloEmote.value(), stream);

	TypeInfo<int >::toBinaryStream(&holoEmoteUseCount.value(), stream);

	TypeInfo<String >::toBinaryStream(&spouseName.value(), stream);

	TypeInfo<VectorMap<unsigned int, String> >::toBinaryStream(&chosenVeteranRewards.value(), stream);

	TypeInfo<SortedVector<unsigned long long> >::toBinaryStream(&currentEventPerks.value(), stream);

	TypeInfo<DeltaVectorMap<uint32, PlayerQuestData > >::toBinaryStream(&playerQuestsData.value(), stream);

	TypeInfo<unsigned long long >::toBinaryStream(&miliSecsPlayed.value(), stream);

	TypeInfo<unsigned long long >::toBinaryStream(&miliSecsSession.value(), stream);

	TypeInfo<unsigned long long >::toBinaryStream(&sessionStatsMiliSecs.value(), stream);


}

